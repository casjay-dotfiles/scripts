#!/usr/bin/env bash
# shellcheck shell=bash
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
##@Version           :  202208082322-git
# @@Author           :  Jason Hempstead
# @@Contact          :  jason@casjaysdev.pro
# @@License          :  WTFPL
# @@ReadME           :  gitadmin --help
# @@Copyright        :  Copyright: (c) 2022 Jason Hempstead, Casjays Developments
# @@Created          :  Monday, Aug 08, 2022 23:22 EDT
# @@File             :  gitadmin
# @@Description      :  push/clone/pull from github/gitlab/private repo
# @@Changelog        :  Updated ghcreate and ghdelete functions
# @@TODO             :  Organize this a lot better and split into seperate scripts
# @@Other            :  Somethings may be broken due to variable changes
# @@Resource         :
# @@Terminal App     :  no
# @@sudo/root        :  no
# @@Template         :  bash/system
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# shellcheck disable=SC1003,SC2016,SC2031,SC2120,SC2155,SC2199,SC2317
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
APPNAME="$(basename -- "$0" 2>/dev/null)"
VERSION="202208082322-git"
USER="${SUDO_USER:-$USER}"
RUN_USER="${RUN_USER:-$USER}"
USER_HOME="${USER_HOME:-$HOME}"
SCRIPT_SRC_DIR="${BASH_SOURCE%/*}"
GITADMIN_REQUIRE_SUDO="${GITADMIN_REQUIRE_SUDO:-no}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Reopen in a terminal
#if [ ! -t 0 ] && { [ "$1" = --term ] || [ $# = 0 ]; }; then { [ "$1" = --term ] && shift 1 || true; } && TERMINAL_APP="TRUE" myterminal -e "$APPNAME $*" && exit || exit 1; fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set script title
#CASJAYS_DEV_TILE_FORMAT="${USER}@${HOSTNAME}:${PWD//$HOME/\~} - $APPNAME"
#CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}"
#[ -z "$CASJAYSDEV_TITLE_SET" ] && printf '\033]2│;%s\033\\' "$CASJAYS_DEV_TILE_FORMAT" && CASJAYSDEV_TITLE_SET="$APPNAME"
export CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}" CASJAYSDEV_TITLE_SET
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Initial debugging
[ "$1" = "--debug" ] && set -x && export SCRIPT_OPTS="--debug" && export _DEBUG="on"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Disables colorization
[ "$1" = "--raw" ] && export SHOW_RAW="true"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# pipes fail
set -o pipefail
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Import functions
CASJAYSDEVDIR="${CASJAYSDEVDIR:-/usr/local/share/CasjaysDev/scripts}"
SCRIPTSFUNCTDIR="${CASJAYSDEVDIR:-/usr/local/share/CasjaysDev/scripts}/functions"
SCRIPTSFUNCTFILE="${SCRIPTSAPPFUNCTFILE:-testing.bash}"
SCRIPTSFUNCTURL="${SCRIPTSAPPFUNCTURL:-https://github.com/dfmgr/installer/raw/main/functions}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if [ -f "$PWD/$SCRIPTSFUNCTFILE" ]; then
  . "$PWD/$SCRIPTSFUNCTFILE"
elif [ -f "$SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE" ]; then
  . "$SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE"
else
  echo "Can not load the functions file: $SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE" 1>&2
  exit 1
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Options are: *_install
# system user desktopmgr devenvmgr dfmgr dockermgr fontmgr iconmgr pkmgr systemmgr thememgr wallpapermgr
user_install && __options "$@"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Send all output to /dev/null
__devnull() {
  tee &>/dev/null && exitCode=0 || exitCode=1
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'
# Send errors to /dev/null
__devnull2() {
  [ -n "$1" ] && local cmd="$1" && shift 1 || return 1
  eval $cmd "$*" 2>/dev/null && exitCode=0 || exitCode=1
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'
# See if the executable exists
__cmd_exists() {
  exitCode=0
  [ -n "$1" ] && local exitCode="" || return 0
  for cmd in "$@"; do
    builtin command -v "$cmd" &>/dev/null && exitCode+=$(($exitCode + 0)) || exitCode+=$(($exitCode + 1))
  done
  [ $exitCode -eq 0 ] || exitCode=3
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for a valid internet connection
__am_i_online() {
  local exitCode=0
  curl -q -ISsf --max-time 2 --retry 1 "${1:-https://1.1.1.1}" 2>&1 | grep -qi 'server:.*cloudflare' || exitCode=4
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# colorization
if [ "$SHOW_RAW" = "true" ]; then
  NC=""
  RESET=""
  BLACK=""
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  PURPLE=""
  CYAN=""
  WHITE=""
  ORANGE=""
  LIGHTRED=""
  BG_GREEN=""
  BG_RED=""
  ICON_INFO="[ info ]"
  ICON_GOOD="[ ok ]"
  ICON_WARN="[ warn ]"
  ICON_ERROR="[ error ]"
  ICON_QUESTION="[ ? ]"
  printf_column() { tee | grep '^'; }
  printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
else
  printf_color() { printf "%b" "$(tput setaf "${2:-7}" 2>/dev/null)" "$1" "$(tput sgr0 2>/dev/null)"; }
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional printf_ colors
__printf_head() { printf_blue "$1"; }
__printf_opts() { printf_purple "$1"; }
__printf_line() { printf_cyan "$1"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
printf_help() {
  printf '\n'
  printf_purple "$*\n"
  exit
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# output version
__version() { printf_cyan "$VERSION"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# list options
__list_options() {
  printf_color "$1: " "$5"
  echo -ne "$2" | sed 's|:||g;s/'$3'/ '$4'/g' | tr '\n' ' '
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# create the config file
__gen_config() {
  local NOTIFY_CLIENT_NAME="$APPNAME"
  if [ "$INIT_CONFIG" != "TRUE" ]; then
    printf_blue "Generating the config file in"
    printf_cyan "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE"
  fi
  [ -d "$GITADMIN_CONFIG_DIR" ] || mkdir -p "$GITADMIN_CONFIG_DIR"
  [ -d "$GITADMIN_CONFIG_BACKUP_DIR" ] || mkdir -p "$GITADMIN_CONFIG_BACKUP_DIR"
  [ -f "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE" ] &&
    cp -Rf "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE" "$GITADMIN_CONFIG_BACKUP_DIR/$GITADMIN_CONFIG_FILE.$$"
  cat <<EOF >"$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE"
# Settings for gitadmin
GITADMIN_DEFAULT_USERNAME="${GITADMIN_DEFAULT_USERNAME:-$GITHUB_USERNAME}"
GITADMIN_DEFAULT_BRANCH="${GITADMIN_DEFAULT_BRANCH:-main}"
GITADMIN_DEFAULT_REPO_BASE="${REPO_URL:-https://github.com}"
GITADMIN_DEFAULT_README="${GITADMIN_DEFAULT_README:-default}"
GITADMIN_DEFAULT_LICENSE="${MY_LICENSE_FILE:-$CASJAYSDEVDIR/templates/wtfpl.md}"
GITADMIN_DEFAULT_PROJECT_DIR="${GITADMIN_DEFAULT_PROJECT_DIR:-$HOME/Projects}"
GITADMIN_DEFAULT_GIT_DIR_GITHUB="${GITADMIN_DEFAULT_GIT_DIR_GITHUB:-$GITADMIN_DEFAULT_PROJECT_DIR/github}"
GITADMIN_DEFAULT_GIT_DIR_GITLAB="${GITADMIN_DEFAULT_GIT_DIR_GITLAB:-$GITADMIN_DEFAULT_PROJECT_DIR/gitlab}"
GITADMIN_DEFAULT_GIT_DIR_PRIVATE="${GITADMIN_DEFAULT_GIT_DIR_PRIVATE:-$GITADMIN_DEFAULT_PROJECT_DIR/Private}"
GITADMIN_DEFAULT_USER_DOMAIN="${GITADMIN_DEFAULT_USER_DOMAIN:-}"
GITADMIN_PERSONAL_GIT_HOST="${GITADMIN_PERSONAL_GIT_HOST:-$GIT_PRIVATE_URL}"
GITADMIN_GITHUB_AUTH_TOKEN="${GITADMIN_GITHUB_AUTH_TOKEN:-$GITHUB_ACCESS_TOKEN}"
GITADMIN_DEFAULT_VERSION_FILE="${GITADMIN_DEFAULT_VERSION_FILE:-version.txt}"
GITADMIN_DEFAULT_VERSION_FORMAT="${VERSION_DATE_FORMAT:-%Y%m%d%H%M-git}"
GITADMIN_GITLAB_AUTH_TOKEN="${GITADMIN_GITLAB_AUTH_TOKEN:-$GITLAB_ACCESS_TOKEN}"
GITADMIN_PRIVATE_AUTH_TOKEN="${GITADMIN_PRIVATE_AUTH_TOKEN:-$GIT_PRIVATE_ACCESS_TOKEN}"
GITADMIN_DOMAIN_TEMPLATE="${GITADMIN_DOMAIN_TEMPLATE:-https://github.com/casjay-templates/domain-template}"
GITADMIN_DEFAULT_MAINCONFIG="${GITADMIN_DEFAULT_MAINCONFIG:-gitmainconfig}"
GITADMIN_GITHUB_API_VERSION="${GITADMIN_GITHUB_API_VERSION:-}"
GITADMIN_LFS_FILE_TYPES="${GITADMIN_LFS_FILE_TYPES:-}"
GITADMIN_BACKUP_ORG="${GITADMIN_BACKUP_ORG:-}"
GITADMIN_BACKUP_URL="${GITADMIN_BACKUP_URL:-https://github.com}"
GITADMIN_BACKUP_DIR="${GITADMIN_BACKUP_DIR:-$GITADMIN_CONFIG_DIR/repos}"
GITADMIN_MAIN_CONF_NAME="${GITADMIN_MAIN_CONF_NAME:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
GITADMIN_PRIVATE_GIST_DIR="${GITADMIN_PRIVATE_GIST_DIR:-}"
GITADMIN_PRIVATE_GIST_SERVER="${GITADMIN_PRIVATE_GIST_SERVER:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
GITADMIN_OUTPUT_COLOR_1="${GITADMIN_OUTPUT_COLOR_1:-}"
GITADMIN_OUTPUT_COLOR_2="${GITADMIN_OUTPUT_COLOR_2:-}"
GITADMIN_OUTPUT_COLOR_GOOD="${GITADMIN_OUTPUT_COLOR_GOOD:-}"
GITADMIN_OUTPUT_COLOR_ERROR="${GITADMIN_OUTPUT_COLOR_ERROR:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
GITADMIN_NOTIFY_ENABLED="${GITADMIN_NOTIFY_ENABLED:-}"
GITADMIN_GOOD_NAME="${GITADMIN_GOOD_NAME:-}"
GITADMIN_ERROR_NAME="${GITADMIN_ERROR_NAME:-}"
GITADMIN_GOOD_MESSAGE="${GITADMIN_GOOD_MESSAGE:-}"
GITADMIN_ERROR_MESSAGE="${GITADMIN_ERROR_MESSAGE:-}"
GITADMIN_NOTIFY_CLIENT_NAME="${GITADMIN_NOTIFY_CLIENT_NAME:-}"
GITADMIN_NOTIFY_CLIENT_ICON="${GITADMIN_NOTIFY_CLIENT_ICON:-}"
GITADMIN_NOTIFY_CLIENT_URGENCY="${GITADMIN_NOTIFY_CLIENT_URGENCY:-}"

EOF
  if builtin type -t __gen_config_local | grep -q 'function'; then __gen_config_local; fi
  if [ -f "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE" ]; then
    [ "$INIT_CONFIG" = "TRUE" ] || printf_green "Your config file for $APPNAME has been created"
    . "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE"
    exitCode=0
  else
    printf_red "Failed to create the config file"
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Help function - Align to 50
__help() {
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "gitadmin:  push/clone/pull from github/gitlab/private repo - $VERSION"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "Usage: gitadmin [options] [directory] [commands]"
  __printf_line "init                            - Initialize current project into a git repo"
  __printf_line "setup                           - Initialize current project into a git repo"
  __printf_line "stow                            - Keep your dotfiles in a repo"
  __printf_line "status                          - Show repo status"
  __printf_line "log                             - Show the git log"
  __printf_line "lfs                             - Run lfs commands"
  __printf_line "branch                          - Rename the current branch"
  __printf_line "commit                          - Commit the current changes"
  __printf_line "update                          - Run git pull on all repos"
  __printf_line "backup                          - backup all repos"
  __printf_line "repos [userName]                - Show all your public repo"
  __printf_line "push [directory]                - Push a project to a remote repo"
  __printf_line "pull [directory]                - Update a local git repo"
  __printf_line "clone [repo] [directory]        - Clone a git repo"
  __printf_line "create [userName] [repoName]    - Create a new github repo"
  __printf_line "delete [userName] [repoName]    - Deletes a github repo"
  __printf_line "shorten  [URL] [name]           - Shorten any github url"
  __printf_line "newsite [sitename] [repo]       - Create a site using template [$GITADMIN_DOMAIN_TEMPLATE]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Remote Repo: [show,add] [remoteURL]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "remote show                     - Show the current remote server "
  __printf_line "remote add [remoteURL]          - Add new remote url"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "User: [options] [userName]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "user [userName]                 - Clone/Pull all repos owned by you"
  __printf_line "user list [userName]            - List all repos owned by you"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Organization: [all,push,pull,clone] [userName]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "orgs all [userName]             - Clone/Pull all orgs owned by you"
  __printf_line "orgs push [userName]            - Push all your local repos to remote"
  __printf_line "orgs pull [userName]            - Update all your local repos from remote"
  __printf_line "orgs clone [userName]           - Clone a repo"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Github Gist: [clone,create,delete,edit,list,search] [userName]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "gist clone [id] [directory]     - Clone a gist repo"
  __printf_line "gist create [userName]          - Create a new github gist"
  __printf_line "gist delete [userName]          - Delete a github gist"
  __printf_line "gist edit [userName]            - Edit github gist"
  __printf_line "gist list [userName]            - List github gists"
  __printf_line "gist search [userName]          - Search for github gist"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Single Actions: [all,init,clone,push,pull] [arguments]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "single all                      - Push all repos in ~/Projects/*/[userName]/*"
  __printf_line "single init [directory]         - single init"
  __printf_line "single clone [RemoteURL]        - Clone a repo"
  __printf_line "single push [directory]         - Push your local repo to remote"
  __printf_line "single pull [directory]         - Run git pull on repo"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Github Repo Actions: [init,clone,push,pull,remote] [userName/repo]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "github init [directory]         - single init"
  __printf_line "github clone [directory]        - Clone a repo [RemoteURL]"
  __printf_line "github push [directory]         - Push your local repo to remote"
  __printf_line "github pull [directory]         - Run git pull on repo"
  __printf_line "github remote [directory]       - Add new remote url [userName/repoName]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Gitlab Repo Actions: [init,clone,push,pull,remote] [userName/repo]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "gitlab init [directory]         - single init"
  __printf_line "gitlab clone [directory]        - Clone a repo [RemoteURL]"
  __printf_line "gitlab push [directory]         - Push your local repo to remote"
  __printf_line "gitlab pull [directory]         - Run git pull on repo"
  __printf_line "gitlab remote [directory]       - Add new remote url [userName/repoName]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Private Repo Actions: [init,clone,push,pull,remote,migrate] [userName/repo]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "private init [directory]        - single init"
  __printf_line "private clone [directory]       - Clone a repo [RemoteURL]"
  __printf_line "private push [directory]        - Push your local repo to remote"
  __printf_line "private pull [directory]        - Run git pull on repo"
  __printf_line "private remote [directory]      - Add new remote url [userName/repoName]"
  __printf_line "private migrate [directory]     - Migrate from github to gitea [github_user] [github_org] [gitea_user] [gitea_org]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Github Issue: [list,count,create,edit] [userName] [repoName]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "issues count                    - Show how many issues exist"
  __printf_line "issues list [repo]              - Show current github issues for current project"
  __printf_line "issues create [repo]            - Create a new issue"
  __printf_line "issues edit [id]                - Edit a current issue"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Repo options: [--user,--org,--dir,--cd] [arguments]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "--user [userName]               - List user repos"
  __printf_line "--org [orgNAME]                 - List organization repos "
  __printf_line "--single [repoURL]              - clone a single repo "
  __printf_line "--dir [directory]               - Sets the working directory"
  __printf_line "--cd                            - cd into repo upon update/clone"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Other Options"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "--help                          - Shows this message"
  __printf_line "--config                        - Generate user config file"
  __printf_line "--version                       - Show script version"
  __printf_line "--options                       - Shows all available options"
  __printf_line "--debug                         - Enables script debugging"
  __printf_line "--raw                           - Removes all formatting on output"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "This is a work in progress"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "cron                            - Autoupdate all repos using cron"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# check if arg is a builtin option
__is_an_option() { if echo "$ARRAY" | grep -q "${1:-^}"; then return 1; else return 0; fi; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Is current user root
__user_is_root() {
  { [ $(id -u) -eq 0 ] || [ $EUID -eq 0 ] || [ "$WHOAMI" = "root" ]; } && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Is current user not root
__user_is_not_root() {
  if { [ $(id -u) -eq 0 ] || [ $EUID -eq 0 ] || [ "$WHOAMI" = "root" ]; }; then return 1; else return 0; fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check if user is a member of sudo
__sudo_group() {
  grep -sh "${1:-$USER}" "/etc/group" | grep -Eq 'wheel|adm|sudo' || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# # Get sudo password
__sudoask() {
  ask_for_password sudo true && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run sudo
__sudorun() {
  __sudoif && __cmd_exists sudo && sudo -HE "$@" || { __sudoif && eval "$@"; }
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Test if user has access to sudo
__can_i_sudo() {
  (sudo -vn && sudo -ln) 2>&1 | grep -vq 'may not' >/dev/null && return 0
  __sudo_group "${1:-$USER}" || __sudoif || __sudo true &>/dev/null || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User can run sudo
__sudoif() {
  __user_is_root && return 0
  __can_i_sudo "${RUN_USER:-$USER}" && return 0
  __user_is_not_root && __sudoask && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run command as root
requiresudo() {
  if [ "$GITADMIN_REQUIRE_SUDO" = "yes" ] && [ -z "$GITADMIN_REQUIRE_SUDO_RUN" ]; then
    export GITADMIN_REQUIRE_SUDO="no"
    export GITADMIN_REQUIRE_SUDO_RUN="true"
    __sudo "$@"
    exit $?
  else
    return 0
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute sudo
__sudo() {
  CMD="${1:-echo}" && shift 1
  CMD_ARGS="${*:--e "${RUN_USER:-$USER}"}"
  SUDO="$(builtin command -v sudo 2>/dev/null || echo 'eval')"
  [ "$(basename -- "$SUDO" 2>/dev/null)" = "sudo" ] && OPTS="--preserve-env=PATH -HE"
  if __sudoif; then
    export PATH="$PATH"
    $SUDO ${OPTS:-} $CMD $CMD_ARGS && true || false
    exitCode=$?
  else
    printf '%s\n' "This requires root to run"
    exitCode=1
  fi
  return ${exitCode:-1}
}
# End of sudo functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__trap_exit() {
  exitCode=${exitCode:-0}
  [ -f "$GITADMIN_TEMP_FILE" ] && rm -Rf "$GITADMIN_TEMP_FILE" &>/dev/null
  #unset CASJAYSDEV_TITLE_SET && printf '\033]2│;%s\033\\' "${USER}@${HOSTNAME}:${PWD//$HOME/\~} - ${CASJAYSDEV_TITLE_PREV:-$SHELL}"
  if builtin type -t __trap_exit_local | grep -q 'function'; then __trap_exit_local; fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined functions
__jq() { jq "$@" 2>/dev/null | grep -v '^$' | grep '^' || return 1; }
__test_if_number() { test -n "$1" && test -z "${1//[0-9]/}" || return 1; }
__test_if_url() { grep -E $1 'http://|https://|git://|ssh://' || return 1; }
__if_is_url() { echo "$1" | grep -Eq 'http://|https://|git://|ssh://' || return 1; }
__file_exists_and_not_empty() { [ -f "$1" ] && [ -s "$1" ] && return 0 || return 2; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__printf_space() {
  local color padlength width
  test -n "$1" && test -z "${1//[0-9]/}" && color="$1" && shift 1 || color="7"
  test -n "$1" && test -z "${1//[0-9]/}" && padlength="$1" && shift 1 || padlength="50"
  width=$((${#1} - $padlength))
  printf '%b' "$(tput setaf "$color" 2>/dev/null)"
  printf "%s%-${width}s%s" "$1" " " "$2"
  printf '%b' "$(tput sgr0 2>/dev/null)"
  printf '\n'
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# create directory structures
__create_dirs() {
  local d=""
  local dir=""
  local directories="${*:-github gitlab private local}"
  local project_dir="${GITADMIN_DEFAULT_PROJECT_DIR:-$HOME/Projects}"
  for d in $directories; do
    dir="${d//$project_dir/}"
    if [ ! -d "$project_dir/$dir" ]; then
      mkdir -p "$project_dir/$dir" || printf_exit "Failed to create $dir in $project_dir: Ensure $project_dir is mounted and writable"
    fi
  done
  return
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__update_usage() {
  printf_cyan "Usage: var=value var2=myvalue"
  exit
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# The template to create a new private github repo
create_new_private_repo_template() {
  read -r -d '' JSON_TEMPLATE <<EOF
{
  "name" : "%s",
  "description" : "%s",
  "homepage" : "%s",
  "visibility" : "private",
  "private" : true,
  "has_issues" : false,
  "has_downloads" : false,
  "has_wiki" : false,
  "has_projects" : false
}
EOF
  JSON_OUTPUT=$(printf '%s' '%s' '%s' '%s' "$JSON_TEMPLATE" "$REPO_NAME" "$DESCRIPTION" "$GITADMIN_DEFAULT_USER_DOMAIN")
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# The template to create a new public github repo
create_new_repo_template() {
  read -r -d '' JSON_TEMPLATE <<EOF
{
  "name" : "%s",
  "description" : "%s",
  "homepage" : "%s",
  "visibility" : "public",
  "private" : false,
  "has_issues" : true,
  "has_downloads" : true,
  "has_wiki" : true,
  "has_projects" : true
}
EOF
  JSON_OUTPUT=$(printf '%s' '%s' '%s' '%s' "$JSON_TEMPLATE" "$REPO_NAME" "$DESCRIPTION" "$GITADMIN_DEFAULT_USER_DOMAIN")
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__backup_repos() {
  local dirs-"${*:-GITADMIN_DEFAULT_GIT_DIR_GITHUB/*/*}"
  [ -d "$GITADMIN_DEFAULT_GIT_DIR_GITHUB" ] || return
  for d in $dirs; do
    if [ -n "$GITADMIN_BACKUP_ORG" ]; then
      local mktemp="$(mktemp 'XXXXXXXXXXXXXXXX')"
      local org_name="$(echo "$d" | awk -F '/' '{print $(NF-1)}')"
      local repo_name="$(echo "$d" | awk -F '/' '{print $NF}')"
      printf_cyan "Backing up ${d//$HOME/~} to $GITADMIN_BACKUP_URL/$GITADMIN_BACKUP_ORG/$org_name-$repo_name"
      mkdir -p ""$BUILDX_TEMP_DIR/$mktemp""
      git clone -q "$d" "$BUILDX_TEMP_DIR/$mktemp"
      $0 setup --automated --dir "$BUILDX_TEMP_DIR/$mktemp" "$GITADMIN_BACKUP_URL/$GITADMIN_BACKUP_ORG/$org_name-$repo_name" 2>/dev/null >/dev/null
      rm -Rf "${BUILDX_TEMP_DIR:?}/$mktemp"
      printf_green "Backup completed"
    else
      printf_cyan "Backing up ${d//$HOME/~} to $GITADMIN_BACKUP_URL/$GITADMIN_BACKUP_ORG/$org_name/$repo_name"
      rm -Rf "${GITADMIN_BACKUP_DIR:?}/$org_name/$repo_name"
      mkdir -p "$GITADMIN_BACKUP_DIR/$org_name/$repo_name"
      [ -d "$d/.git" ] && git clone -q "$d" "$GITADMIN_BACKUP_DIR/$org_name/$repo_name"
      printf_green "Backup completed"
    fi
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_custom() {
  local set_git_dir="$1" && shift 1 || set_git_dir="${GITADMIN_CWD:-$PWD}"
  git -C "$set_git_dir" "$@" -q 2>/dev/null
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_update_all() {
  local token="$GIT_PRIVATE_ACCESS_TOKEN"
  if [ "$1" = "all" ]; then
    org="$2"
    repos="$(curl -q -LSsf -X GET -H 'Content-Type: application/json' -H "Authorization: token $token" "$GITADMIN_PERSONAL_GIT_HOST/api/v1/users/$org/repos" 2>/dev/null | __jq -r '.[].full_name' | sort -u | grep '^' || false)"
    shift 2
    [ -n "$repos" ] || printf_exit "Failed to get repos for user: $org"
    [ -n "$1" ] && [ -n "$org" ] || __update_usage
    printf_yellow "Getting repos for user $org"
    for repo in $repos; do
      __gitea_update_repo "$repo" "$@"
    done
  else
    __gitea_update_repo "$@"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_update_repo() {
  local repo=""
  local data=""
  local json=""
  local exitCode=0
  local json_message=""
  local token="$GIT_PRIVATE_ACCESS_TOKEN"
  local host="$GITADMIN_PERSONAL_GIT_HOST"
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __update_usage
  echo "$1" | grep -q '.*./.*.' || echo "$1" | grep -q '.*.=.*.' || __update_usage
  repo="$1" && shift 1
  name="$(echo "$repo" | sed 's|/|_|g')"
  printf '%s' "$(printf_yellow "Updating $repo: ")"
  while :; do
    case "$1" in
    *=*)
      data="$(echo "$1" | awk -F '=' '{print $1}')"
      value="$(echo "$1" | awk -F '=' '{print $2}')"
      if [ "$value" = "true" ] || [ "$value" = "false" ]; then
        json='"'$data'":'$value''
      else
        json='"'$data'": "'$value'"'
      fi
      shift 1
      update="$(printf '%s' "{${json//\"\"/\",\"}}")"
      curl -q -LSsf -X PATCH -H "Content-Type: application/json" -H "Authorization: token $token" --data "$update" "$host/api/v1/repos/$repo" >"$GITADMIN_LOG_DIR/$name.log" 2>&1
      if cat "$GITADMIN_LOG_DIR/$name.log" | grep "$data" | grep -q "$value"; then
        json_message="$json"
        exitCode=$((exitCode + 0))
        message="$(printf '%s' "$(printf_green "success:")")"
      else
        json_message="$json"
        exitCode=$((exitCode + 1))
        message="$(printf '%s' "$(printf_red "failed:")")"
      fi
      json_message="$(printf '%s' "$json_message" | sed 's| $||g;s| |, |g')"
      json_message="$(printf '%s' "{${json_message//\"\"/\",\"}}")"
      printf '%s %s ' "$message" "$json_message"
      ;;
    *)
      break
      ;;
    esac
  done
  printf '%s\n' "- exitCode: $exitCode"
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_orgs() {
  local resp=""
  local token="$GIT_PRIVATE_ACCESS_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/orgs/$1/repos"
  resp="$(curl -q -LSsf -X 'GET' -H "Authorization: token $token" -H 'accept: application/json' "$url" 2>/dev/null | __jq -r '.[]' || false)"
  if [ -n "$resp" ]; then
    echo "$resp" | __jq
    exitCode=0
  else
    printf_red "Failed to retrieve the list of repos for $1"
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_users() {
  local resp=""
  local token="$GIT_PRIVATE_ACCESS_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/users/$1/repos"
  resp="$(curl -q -LSsf -X 'GET' -H "Content-Type: application/json" -H "Authorization: token $token" -H 'accept: application/json' "$url" 2>/dev/null | __jq -r '.[]' || __gitea_orgs "$1" "silent" || false)"
  if [ -n "$resp" ]; then
    [ -n "$2" ] || echo "$resp" | __jq
    exitCode=0
  else
    [ -n "$2" ] || printf_red "Failed to retrieve the list of repos for $1"
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_users_orgs() {
  local resp=""
  local token="$GIT_PRIVATE_ACCESS_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/users/$1/orgs"
  resp="$(curl -q -LSsf -X 'GET' -H "Authorization: token $token" -H "Content-Type: application/json" -H 'accept: application/json' "$url" 2>/dev/null | __jq -r '.' || false)"
  if [ -n "$resp" ]; then
    [ -n "$2" ] || echo "$resp" | __jq
    exitCode=0
  else
    [ -n "$2" ] || printf_red "Failed to retrieve the list of orgs for $1"
    exitCode=1
  fi
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_delete_repo() {
  local resp=""
  local token="$GIT_PRIVATE_ACCESS_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/$1/repos/delete"
  resp="$(curl -q -LSsf -X 'POST' -H "Authorization: token $token" -H "Content-Type: application/json" -H 'accept: application/json' "$url" 2>/dev/null | grep -v '.html_url' && echo 'deleted' || false)"
  if [ -n "$resp" ]; then
    echo "$resp" | __jq -r
    exitCode=0
  else
    printf_red "Failed to create the repo $1"
    exitCode=1
  fi
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_create_repo() {
  local resp="" description=""
  local token="$GIT_PRIVATE_ACCESS_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/user/repos"
  [ -f "$GITADMIN_CWD/DESCRIPTION" ] && description="$(<"$GITADMIN_CWD/DESCRIPTION")" || description="${2:-}"
  private="${3:-false}"
  [ "$GITADMIN_REPO_VISIBLE" = "no" ] && private="true" || private="${private:-false}"
  resp="$(curl -q -LSsf -X 'POST' -H "Authorization: token $token" -H "Content-Type: application/json" -H 'accept: application/json' --data "{ \"auto_init\":false,\"default_branch\":\"main\",\"name\":\"$1\",\"description\":\"$description\",\"private\":$private }" "$url" 2>/dev/null | __jq -r '.id' || false)"
  if [ -n "$resp" ]; then
    echo "$resp" | __jq -r
    exitCode=0
  else
    printf_red "Failed to create the repo $1"
    exitCode=1
  fi
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_create_org() {
  local token="$GIT_PRIVATE_ACCESS_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/admin/users/$1/orgs" \
    [ -f "$GITADMIN_CWD/DESCRIPTION" ] && description="$(<"$GITADMIN_CWD/DESCRIPTION")" || description="${2:-}"
  private="${5:-false}"
  [ "$GITADMIN_REPO_VISIBLE" = "no" ] && private="true" || private="${private:-false}"
  curl -q -LSsf -X 'POST' -H "Authorization: token $token" -H 'Content-Type: application/json' -H 'accept: application/json' --data "{ \"username\":\"$2\",\"description\":\"$3\",\"website\":\"$4\",\"visibility\":$private }" "$url" 2>/dev/null | __jq -r '.'
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_branch() {
  local token="$GIT_PRIVATE_ACCESS_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/repos/$1/branches"
  curl -q -LSsf -X 'POST' -H "Authorization: token $token" -H 'accept: application/json' -H 'Content-Type: application/json' --data "{ \"new_branch_name\":\"$3\",\"old_branch_name\":\"$2\" }" "$url" 2>/dev/null | __jq -r '.'
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# https://dev.to/nicolasboyer/migrate-all-of-your-repos-from-github-to-gitea-3fk
__github_to_gitea() {
  local GITHUB_USERNAME="$1"
  local GITHUB_ORG_NAME="$2"
  local GITEA_USERNAME="$3"
  local GITEA_ORG_NAME="$(echo "${4:-$2}" | tr '[:upper:]' '[:lower:]')"
  local GITEA_DOMAIN="$GITADMIN_PERSONAL_GIT_HOST"
  local GITHUB_TOKEN="$GITHUB_ACCESS_TOKEN"
  local GITEA_TOKEN="$GITADMIN_PRIVATE_AUTH_TOKEN"
  local eCode=0 REPO_NAME="" GET_REPOS=""
  [ $# -ge 3 ] || printf_help "Usage: [github_user] [github_org] [gitea_user] [gitea_org]"
  [ -n "$GITHUB_USERNAME" ] || printf_exit "Please provide the the username of the org owner on github"
  [ -n "$GITHUB_ORG_NAME" ] || printf_exit "Please provide the github org/username"
  [ -n "$GITEA_USERNAME" ] || printf_exit "Please provide the the username of the org owner on gitea"
  [ -n "$GITEA_ORG_NAME" ] || printf_exit "Please provide the gitea org/username"
  [ -n "$GITEA_DOMAIN" ] || printf_exit "Please provide the gitea url: GITADMIN_PERSONAL_GIT_HOST"
  [ -n "$GITHUB_TOKEN" ] || printf_exit "Please provide the github API Token: GITHUB_ACCESS_TOKEN"
  [ -n "$GITEA_TOKEN" ] || printf_exit "Please provide the github API Token: GITADMIN_PRIVATE_AUTH_TOKEN"
  if curl -q --retry 2 --retry-max-time 3 --retry-delay 3 -LSsf "$GITEA_DOMAIN/api/v1/orgs/$GITEA_ORG_NAME" 2>/dev/null | __jq -rc '.name' | grep -q "$GITEA_ORG_NAME"; then
    printf_green "🆗🆗 $GITEA_ORG_NAME already exists 🆗🆗"
  else
    GET_ORG="$(__curl_gh_api -f "https://api.github.com/orgs/$GITHUB_ORG_NAME" | __jq -r '.' || grep '^' || echo "")"
    ORG_LOC="$(echo "$GET_ORG" | __jq -rc '.location' | grep -v 'null' | grep '^' || echo "USA")"
    ORG_NAME="$(echo "$GET_ORG" | __jq -rc '.name' | grep -v 'null' | grep '^' || echo "$GITEA_ORG_NAME")"
    ORG_SITE="$(echo "$GET_ORG" | __jq -rc '.blog' | grep -v 'null' | grep '^' || echo "$GITEA_DOMAIN/$GITEA_ORG_NAME")"
    ORG_DESC="$(echo "$GET_ORG" | __jq -rc '.description' | sed 's|"|\"|g' | grep -v 'null' | grep '^' || echo "$GITEA_ORG_NAME")"
    echo "$ORG_SITE" | grep -q 'http.*://' || ORG_SITE="https://$ORG_SITE"
    curl -q -LSsf -X 'POST' ''$GITEA_DOMAIN'/api/v1/orgs?token='$GITEA_TOKEN'' -H 'accept: application/json' -H 'Content-Type: application/json' --data "{ \"username\": \"$GITEA_ORG_NAME\", \"description\": \"$ORG_DESC\", \"full_name\": \"$ORG_NAME\", \"location\": \"$ORG_LOC\", \"repo_admin_change_team_access\": true, \"visibility\": \"public\", \"website\": \"$ORG_SITE\" }" >"$GITADMIN_TEMP_FILE" 2>&1 || false
    [ $? -eq 0 ] && printf_blue "😹😹 Created the organization: $GITEA_ORG_NAME which is owned by $GITEA_USERNAME 😹😹" || printf_exit 5 1 "😿😿 Failed to create $GITEA_ORG_NAME: $(cat "$GITADMIN_TEMP_FILE" | grep 'curl: ' | sed 's|curl:.*) ||g' | head -n1) 😿😿 \n"
  fi
  GET_REPOS="$(__curl_gh_api "https://api.github.com/orgs/$GITHUB_ORG_NAME/repos?per_page=2000" | __jq -r '.[].html_url')"
  [ -n "$GET_REPOS" ] || printf_exit 1 2 "💔💔 No repos exist for $GITHUB_ORG_NAME 💔💔"
  for URL in $GET_REPOS; do
    REPO_NAME=$(echo "$URL" | sed 's|https://github.com/'$GITHUB_ORG_NAME'/||g' | tr '[:upper:]' '[:lower:]' | grep '^' || return)
    REPO_INFO="$(__curl_gh_api -f "https://api.github.com/repos/$GITHUB_ORG_NAME/$REPO_NAME")"
    gitea_url="$GITEA_DOMAIN/$GITEA_ORG_NAME/$REPO_NAME"
    private="$(echo "$REPO_INFO" | __jq -r '.private' | grep -v 'null' | grep '^' || echo "false")"
    website="$(echo "$REPO_INFO" | __jq -r '.homepage' | grep -v 'null' | grep '^' || echo "$gitea_url")"
    avatar="$(echo "$REPO_INFO" | __jq -r '.owner.avatar_url' | grep -v 'null' | grep '^' || echo "")"
    description="$(echo "$REPO_INFO" | __jq -r '.description' | grep -v 'null' | grep '^' || echo "$REPO_NAME")"
    [ -f "$GITADMIN_CWD/DESCRIPTION" ] && description="$(<"$GITADMIN_CWD/DESCRIPTION")" || description="${description:-}"
    [ "$GITADMIN_REPO_VISIBLE" = "no" ] && private="true" || private="${private:-false}"
    if curl -q -LSsf -X 'GET' "$GITEA_DOMAIN/api/v1/repos/$GITEA_ORG_NAME/$REPO_NAME" -H 'accept: application/json' 2>/dev/null | __jq -r '.full_name' | grep -q "$REPO_NAME"; then
      printf_yellow "🔀🔀 The repo: $GITEA_ORG_NAME/$REPO_NAME already exists 🔀🔀"
      curl -q -LfSs -X PATCH -u "$GITEA_USERNAME:$GITEA_TOKEN" "$GITEA_DOMAIN/api/v1/repos/$GITEA_ORG_NAME/$REPO_NAME" -H 'accept: application/json' -H 'Content-Type: application/json' -d "{ \"repo_name\": \"$REPO_NAME\", \"repo_owner\": \"$GITEA_ORG_NAME\", \"auth_username\": \"$GITHUB_USERNAME\", \"auth_token\": \"$GITHUB_TOKEN\", \"clone_addr\": \"$URL\", \"description\": \"$description\", \"website\": \"$website\", \"avatar_url\": \"$avatar\", \"issues\": true, \"labels\": true, \"lfs\": true, \"milestones\": true, \"mirror\": true, \"mirror_interval\": \"3600s\", \"private\": $private, \"pull_requests\": true, \"releases\": true, \"uid\": 0, \"wiki\": true , \"service\": \"git\" }" >"$GITADMIN_TEMP_FILE" 2>&1
      grep -qs 'updated_at' "$GITADMIN_TEMP_FILE" && printf_blue "🚀🚀 Successfully updated: $GITEA_ORG_NAME/$REPO_NAME 🚀🚀" || { printf_yellow "😠😠  $(cat "$GITADMIN_TEMP_FILE" | grep 'curl: ' | sed 's|curl:.*) ||g' | head -n1) 😠😠" && eCode=$((eCode + 1)); }
    else
      printf_cyan "🚀🚀 Found $GITHUB_ORG_NAME/$REPO_NAME, importing... 🚀🚀"
      curl -q -LfSs --retry 2 --retry-max-time 3 --retry-delay 3 -X POST -u "$GITEA_USERNAME:$GITEA_TOKEN" "$GITEA_DOMAIN/api/v1/repos/migrate" -H 'accept: application/json' -H 'Content-Type: application/json' -d "{ \"repo_name\": \"$REPO_NAME\", \"repo_owner\": \"$GITEA_ORG_NAME\", \"auth_username\": \"$GITHUB_USERNAME\", \"auth_token\": \"$GITHUB_TOKEN\", \"clone_addr\": \"$URL\", \"description\": \"$description\", \"website\": \"$website\", \"avatar_url\": \"$avatar\", \"issues\": true, \"labels\": true, \"lfs\": true, \"milestones\": true, \"mirror\": true, \"mirror_interval\": \"3600s\", \"private\": $private, \"pull_requests\": true, \"releases\": true, \"uid\": 0, \"wiki\": true , \"service\": \"git\" }" >"$GITADMIN_TEMP_FILE" 2>&1
      grep -qs 'created_at' "$GITADMIN_TEMP_FILE" && printf_blue "🔽⏫ Successfully imported to: $gitea_url ⏫🔽" || { printf_yellow "⚠️ ⚠️  $(cat "$GITADMIN_TEMP_FILE" | grep 'curl: ' | sed 's|curl:.*) ||g' | head -n1) ⚠️ ⚠️" && eCode=$((eCode + 1)); }
      sleep 5
    fi
  done
  printf '\n'
  return $eCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_migrate_delete() {
  GITHUB_USERNAME="$1"
  GITHUB_ORG_NAME="$2"
  GITEA_USERNAME="$3"
  GITEA_ORG_NAME="${4:-$2}"
  GITEA_DOMAIN="$GITADMIN_PERSONAL_GIT_HOST"
  GITHUB_TOKEN="$GITHUB_ACCESS_TOKEN"
  GITEA_TOKEN="$GITADMIN_PRIVATE_AUTH_TOKEN"
  [ $# -le 3 ] || printf_help "Usage: [github_user] [github_org] [gitea_user] [gitea_org]"
  [ -n "$GITHUB_USERNAME" ] || printf_exit "Please provide the the username of the org owner on github"
  [ -n "$GITHUB_ORG_NAME" ] || printf_exit "Please provide the github org/username"
  [ -n "$GITEA_USERNAME" ] || printf_exit "Please provide the the username of the org owner on gitea"
  [ -n "$GITEA_ORG_NAME" ] || printf_exit "Please provide the gitea org/username"
  [ -n "$GITEA_DOMAIN" ] || printf_exit "Please provide the gitea url: GITADMIN_PERSONAL_GIT_HOST"
  [ -n "$GITHUB_TOKEN" ] || printf_exit "Please provide the github API Token: GITHUB_ACCESS_TOKEN"
  [ -n "$GITEA_TOKEN" ] || printf_exit "Please provide the github API Token: GITADMIN_PRIVATE_AUTH_TOKEN"
  GET_REPOS=$(curl -H 'Accept: application/vnd.github.v3+json' -u $GITHUB_USERNAME:$GITHUB_TOKEN -s "https://api.github.com/orgs/$GITHUB_ORG_NAME/repos?per_page=1000" | __jq -r '.[].html_url')
  for URL in $GET_REPOS; do
    REPO_NAME="${URL//*\/$GITHUB_ORG_NAME/}"
    echo "Deleting $REPO_NAME if it exists on Gitea ..."
    curl -q -LSsf -X DELETE -u $GITEA_USERNAME:$GITEA_TOKEN "$GITEA_DOMAIN/api/v1/repos/$GITEA_ORG_NAME/$name" -H "accept: application/json"
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitlab_orgs() {
  printf_exit "Not implemented yet"
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitlab_branch() {
  curl -q -LSsf -X POST -H "PRIVATE-TOKEN: $GITADMIN_GITLAB_AUTH_TOKEN" --url "https://gitlab.com/api/v4/projects/$1" --data "default_branch=${GITADMIN_DEFAULT_BRANCH:-$2}" 2>/dev/null | __jq -r '.'
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__update_repo_usage() {
  printf_help 'Usage: '$APPNAME' github update repo "[description,homepage,visibility]=value"'
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__update_github_repo() {
  local org=""
  local repo=""
  local data=""
  local json=""
  local exitCode=0
  local exitStatus=0
  local message_bad=""
  local message_good=""
  local json_message=""
  local show_message=""
  local token="$GITADMIN_GITHUB_AUTH_TOKEN"
  local host="https://api.github.com"
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __update_usage
  echo "$1" | grep -q '.*./.*.' || echo "$1" | grep -q '.*.=.*.' || __update_usage
  [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD is not a valid repo"
  org="$(echo "$GITADMIN_CWD" | awk -F'/' '{print $(NF-1)}')"
  repo="$(echo "$GITADMIN_CWD" | awk -F'/' '{print $NF}')"
  name="$(echo "$repo" | sed 's|/|_|g')"
  printf '%s' "$(printf_yellow "Updating $org/$repo: ")"
  while :; do
    case "$1" in
    *=*)
      data="$(echo "$1" | awk -F '=' '{print $1}')"
      value="$(echo "$1" | awk -F '=' '{print $2}')"
      if [ "$value" = "true" ] || [ "$value" = "false" ]; then
        json='"'$data'":'$value''
      else
        json='"'$data'":"'$value'"'
      fi
      shift 1
      update="$(printf '%s' "$json")"
      curl -q -LSsf -X PATCH -H "Content-Type: application/json" -H "Authorization: token $token" --data "{$update}" "$host/repos/$org/$repo" >"$GITADMIN_LOG_DIR/$name.log" 2>&1
      if cat "$GITADMIN_LOG_DIR/$name.log" | grep "$data" | grep -q "$value"; then
        exitStatus=0
        json_message="$update"
        message_good="$(printf '%s' "$(printf_red "failed: $json_message")")"
        exitCode=$((exitCode + 0))
      else
        exitStatus=1
        json_message="$update"
        message_bad="$(printf '%s' "$(printf_red "failed: $json_message")")"
        exitCode=$((exitCode + 1))
      fi
      if [ "$exitStatus" -ne 0 ]; then
        printf '%s\n' "$message_bad"
      else
        message="$(printf '%s' "$(printf_green "Success:")")"
        show_message+="$(printf '%s' "$json_message," | sed 's| $||g;s| ,$| |g')"
      fi
      ;;
    *)
      break
      ;;
    esac
  done
  printf '%s %s' "$message" "{$show_message}" | sed 's|,}$|}|g'
  [ $exitCode -eq 0 ] || printf '\n%s' "Errors Observed - exitCode: $exitCode"
  printf '\n'
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#set folder name based on githost
__git_hostname() { echo "$@" | sed -e "s/[^/]*\/\/\([^@]*@\)\?\([^:/]*\).*/\2/" | awk -F. '{print $(NF-1) "." $NF}' | sed 's#\..*##g'; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#setup directory structure
__git_username_repo() {
  local re=""
  protocol="" separator="" hostname="" username="" userrepo="" githostname=""
  url="$1"
  re="^(http|https|git|ssh)(:\/\/|@)([^\/:]+)[\/:]([^\/:]+)\/(.+)$"
  githostname="$(__git_hostname $url 2>/dev/null)"
  if [ -d "$url" ]; then
    protocol=
    separator=
    folder="local"
    hostname=localhost
    userrepo="$(__basename "$url")"
    username="$(__basename "$(dirname "$url")")"
    echo "$username" | grep -q '^.$' && username="$USER"
    GITADMIN_NEW_PROJECT_DIR="${GITADMIN_DEFAULT_PROJECT_DIR:-$HOME/Projects}/$folder/$username-$userrepo"
  elif [[ $url =~ $re ]]; then
    protocol=${BASH_REMATCH[1]}
    separator=${BASH_REMATCH[2]}
    hostname=${BASH_REMATCH[3]}
    username=${BASH_REMATCH[4]}
    userrepo=${BASH_REMATCH[5]}
    folder=$githostname
    GITADMIN_NEW_PROJECT_DIR="${GITADMIN_DEFAULT_PROJECT_DIR:-$HOME/Projects}/$folder/$username/$userrepo"
  else
    return 1
  fi
  export url protocol separator hostname username userrepo GITADMIN_NEW_PROJECT_DIR
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# issues API
__api_issues_token() {
  local git_repo
  { [ $# = 2 ] && git_repo="$1/$2"; } || { [ $# = 1 ] && git_repo="$1"; }
  ISSUE_HTML="https://github.com/$git_repo/issues"
  ISSUE_API="https://api.github.com/repos/$git_repo/issues"
  export ISSUE_HTML ISSUE_API
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# call the issues api
__api_issues() {
  local resp=""
  resp="$(__curl_gh_api -X ${1:-GET} "${2:-$ISSUE_API}" 2>/dev/null)"
  [ -n "$resp" ] && printf "%s" "$resp" || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Gist API
__api_gist() {
  local user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  __curl_gh_api "https://api.github.com/users/$user/gists"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set Message for token - user
__api_user_token() {
  local user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  export GITHUBAPIREPO="https://api.github.com/user/repos?per_page=1000&sort=full_name&type=owner"
  export MESSAGE="Getting the repos for user: $GITADMIN_DEFAULT_USERNAME"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User api
__api_user() {
  local user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  __api_user_token "$user"
  __urlverify "$GITHUBAPIREPO" || return 1
  __curl_gh_api "$GITHUBAPIREPO"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set Message for token - org
__api_org_token() {
  local user="${1:-}" org=""
  export GITHUBAPIREPO="https://api.github.com/orgs/$user/repos?per_page=1000&sort=full_name"
  export MESSAGE="Getting the repos for org: $user"
  org="$(__curl_gh_api "$GITHUBAPIREPO" | __jq -r '.[]|.name' | grep -v '^$' | grep '^')"
  COUNT="$(printf '%s' "$org" | grep -v '^$' | wc -l | grep '^')"
  if [ -n "$org" ]; then
    [ "$COUNT" != 0 ] && printf '%s\n' "$org" | sort -u >"$GITADMIN_TEMP_FILE" || __api_user "$user" || return 1
  else
    printf_yellow "⛔ No repos found for $user ⛔"
    echo ""
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Organization API
__api_org() {
  local user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  __api_org_token "$user" || return 1
  __urlverify "$GITHUBAPIREPO" || return 1
  __curl_gh_api "$GITHUBAPIREPO"
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# pull function
__git_pull() {
  local git_dir="" args="" regex=""
  [ -n "$1" ] && [ -d "$1/.git" ] && git_dir="$1" && shift 1 || git_dir="$GITADMIN_CWD"
  args="$*"
  regex="(https?|ftp|file|git|ssh)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]"
  if [[ "$(__git_remote_origin "$git_dir")" =~ $regex ]]; then
    if __am_i_online; then
      git -C "$git_dir" pull $args -f -q &>/dev/null && return 0 || return 1
    else return 1; fi
  else
    git -C "$git_dir" pull $args -f -q &>/dev/null && return 0 || return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Push function
__git_push() {
  local git_dir="" args="" regex=""
  [ -n "$1" ] && [ -d "$1/.git" ] && git_dir="$1" && shift 1 || git_dir="$GITADMIN_CWD"
  args="$*"
  regex="(https?|ftp|file|git|ssh)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]"
  [ -f "$git_dir/.no_push" ] || return 0
  if [[ "$(__git_remote_origin "$git_dir")" =~ $regex ]]; then
    if __am_i_online; then
      git -C "$git_dir" push $args -q &>/dev/null && return 0 || return 1
    else
      return 1
    fi
  else
    git -C "$git_dir" push $args -q &>/dev/null && return 0 || return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Clone function
__git_clone() {
  local git_url="" git_dir="" args="" regex="" exitCode=0
  git_url="$1" && shift 1
  git_dir="$1" && shift 1
  [ -n "$git_dir" ] || git_dir="$GITADMIN_CWD"
  args="$*" && shift $#
  regex="(http|https|ftp|file|git|ssh)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]"
  if [[ "$git_url" =~ $regex ]]; then
    if __am_i_online; then
      [ -d "$git_dir" ] &&
        git -C "$git_dir" pull -q &>/dev/null ||
        git clone "$git_url" "$git_dir" -q $args &>/dev/null
      exitCode=$?
    else
      return 1
    fi
  else
    [ -d "$git_dir" ] &&
      git -C "$git_dir" pull -q &>/dev/null ||
      git clone "$git_url" "$git_dir" -q $args &>/dev/null
    exitCode=$?
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__clone_success() {
  exitCode=${1:-$?}
  git_dir="${2:-$1}"
  [ -n "$git_dir" ] || git_dir="$GITADMIN_CWD"
  if [ -d "$git_dir/.git" ] && [ $exitCode = 0 ]; then
    printf_cyan "Successfully cloned to $git_dir"
  else
    printf_red "Failed to clone $git_url"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Creates a README.md file if one doesn't exist
create_new_readme_template() {
  local git_dir="" author="" GitBaseDir="" BaseDir=""
  [ "$NOREADME" = "yes" ] && return 0
  git_dir="${1:-$GITADMIN_CWD}"
  if [ -f "$(command -v gen-readme)" ] && [ ! -f "$git_dir/README.md" ]; then
    gen-readme "$git_dir" "$(basename -- "${GITADMIN_DEFAULT_README:-default}")" "README.md" &>/dev/null
  else
    author="$(__git_globaluser)"
    GitBaseDir="$(__git_top_dir "$git_dir")"
    BaseDir="${GitBaseDir##*/}"
    [ -f "$CASJAYSDEVDIR/templates/readmes/projects/default.md" ] &&
      cat "$CASJAYSDEVDIR/templates/readmes/projects/default.md" >"$git_dir/README.md"
    [ -f "$git_dir/README.md" ] && __sed -i "s#ProjectName#${BaseDir}#g" "$git_dir/README.md"
    [ -f "$git_dir/README.md" ] && __sed -i "s#AuthorName#${author}#g" "$git_dir/README.md"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Creates a license if a LICENSE.md file doesn't exist
create_new_license() {
  local git_dir="" author="" year=""
  [ "$NOLICENSE" = "yes" ] && return 0
  git_dir="${1:-$GITADMIN_CWD}"
  if [ -f "$(command -v gen-license)" ] && [ ! -f "$git_dir/LICENSE.md" ]; then
    gen-license "$git_dir" "$(basename -- "$GITADMIN_DEFAULT_LICENSE")" &>/dev/null
  else
    author="$(__git_globaluser)"
    year="$(date +'%Y')"
    [ -f "$GITADMIN_DEFAULT_LICENSE" ] && cat "$GITADMIN_DEFAULT_LICENSE" >"$git_dir/LICENSE.md"
    [ -f "$git_dir/LICENSE.md" ] && __sed -i "s#CURYEAR#${year}#g" "$git_dir/LICENSE.md"
    [ -f "$git_dir/LICENSE.md" ] && __sed -i "s#AuthorName#${author}#g" "$git_dir/LICENSE.md"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check if input is a url
do_not_add_a_url() {
  local string="" regex=""
  string="$1"
  regex="(http|https|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]"
  if [[ "$string" =~ $regex ]]; then
    printf_red "Do not provide the full url"
    printf_red "only provide the username/repo"
    exit 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# The initialize git function
run_git_init() {
  local GITADMIN_EXITCODE=0 git_dir="" git_push="" git_confirm="" git_confirm_repo=""
  git_dir="${1:-$GITADMIN_CWD}"
  git_remote_repo="${2:-$git_remote_repo}"
  git_repo="${git_remote_repo:-$git_repo}"
  git_push=""
  git_confirm=""
  git_confirm_repo=""
  [ "$GITADMIN_SETUP_PUSH" = "no" ] && git_push="no"
  if [ -n "$git_repo" ]; then
    if git -C "$git_dir" remote add origin "$git_repo" >/dev/null || return 1; then
      printf_cyan "$git_repo has been added"
    else
      printf_exit 'Failed to add $git_repo'
    fi
    [ "$git_push" = "no" ] && return 0
    printf_read_question "3" "Should I push to the remote repo? [y/n]" "1" "git_push"
    if printf_answer_yes "$git_push"; then
      printf_read_question "3" "This will overwrite the repo if it exists. Continue? [y/n]" "1" "git_confirm_repo"
      if printf_answer_yes "$git_confirm_repo"; then
        if [ -f "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" ]; then
          cp -Rf "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" "$git_dir/.git/config"
        fi
        [ -f "$git_dir/.no_push" ] || git -C "$git_dir" push -q -f --set-upstream origin "$GITADMIN_DEFAULT_BRANCH" &>/dev/null
        git -C "$git_dir" remote show origin 2>&1 | grep -q 'Repository not found' && git_push="n"
        [ "$git_push" = "n" ] || __git_push "$git_dir"
        GITADMIN_EXITCODE=$?
        if [ -d "$git_dir/.git" ] && [ "$GITADMIN_EXITCODE" = 0 ]; then
          [ "$git_push" = "n" ] && printf_yellow "The remote repository wasn't found: not pushing" || __git_push "$git_dir"
          GITADMIN_EXITCODE=0
        else
          printf_red "Push to $git_repo has failed"
          GITADMIN_EXITCODE=1
        fi
      else
        printf_yellow "Not pushing due to user canceling"
        GITADMIN_EXITCODE=1
      fi
    else
      printf_yellow "Not pushing due to user canceling"
      GITADMIN_EXITCODE=1
    fi
  else
    printf_red "No remote repo specified"
    GITADMIN_EXITCODE=1
  fi
  return ${GITADMIN_EXITCODE:-$?}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__split_create_repo() {
  local repo="$1"
  if check_uri "$repo" || echo "$repo" | grep -q '\..*/.*/.*/*' || echo "$repo" | __test_if_url -q; then
    username="$(echo "$repo" | sed 's|.*//||g' | awk -F'/' '{print $(NF-1)}' | grep '^')"
    reponame="$(echo "$repo" | sed 's|.*//||g' | awk -F'/' '{print $NF}' | grep '^')"
  elif echo "$repo" | grep -q '/'; then
    username="$(echo "$repo" | awk -F'/' '{print $1}' | grep '^')"
    reponame="$(echo "$repo" | awk -F'/' '{print $2}' | grep '^')"
  else
    username="$1"
    reponame="$2"
  fi
  if [ -n "$username" ] && [ -n "$reponame" ]; then
    ghcreate "$username" "$reponame" "Repo for $reponame" &>/dev/null
    return $?
  else
    return 1
  fi
  #curl -q -LSsf -X GET -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${GITADMIN_GITHUB_AUTH_TOKEN}" "${url}/${username}/${reponame}" >"$GITADMIN_TEMP_FILE"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup a new git repo
run_git_setup() {
  local GITADMIN_EXITCODE=0 git_dir="" git_continue="" git_reuse="" git_version_file=""
  git_dir="$(__basedir "$GITADMIN_CWD/.git" | grep -v '^$' | grep '^')"
  git_continue="${continue:-}"
  git_reuse="${reuse:-}"
  git_version_file="$GITADMIN_DEFAULT_VERSION_FILE"
  git_version_fmt="$GITADMIN_DEFAULT_VERSION_FORMAT"
  remote_repo="${2:-$1}"
  git_prev="${remote_repo:-$(__git_remote_push "$GITADMIN_CWD")}"
  GITADMIN_SETUP_MESSAGE="${GITADMIN_SETUP_MESSAGE:-$GITCOMMIT_MESSAGE}"
  GITCOMMIT_MESSAGE="${GITADMIN_SETUP_MESSAGE:- 🦈🏠🐜❗ Initial Commit ❗🐜🦈🏠 }"
  show_git_repo="$(__git_repobase "$git_dir")"
  printf_green "Initializing the repo in $git_dir"
  [ -n "$git_prev" ] || git_prev="github.com/$(basename -- "$(dirname $GITADMIN_CWD)")/$(basename -- "$GITADMIN_CWD")"
  [ -f "$git_dir/.gitattributes" ] || gen-gitattr $git_dir save default lfs &>/dev/null
  [ -f "$git_dir/.gitignore" ] || gitignore "$git_dir" default --automated &>/dev/null
  if [ -d "$git_dir/.git" ]; then
    printf_error "This project already has git setup"
    if [ -n "$git_prev" ]; then
      printf_green "Remote repo is: $git_prev"
    fi
    printf_read_question "3" "Should I continue to reset this repo? [y/n]" "1" "git_continue"
    if printf_answer_yes "$git_continue"; then
      __rm_rf "$git_dir/.git"
    else
      printf_red "Initialization has failed due to user"
      exit 1
    fi
  fi
  [ -f "$git_version_file" ] && date +"$git_version_fmt" >"$git_version_file"
  ls "$git_dir/README"* >/dev/null 2>&1 || create_new_readme_template "$git_dir"
  ls "$git_dir/LICENSE"* >/dev/null 2>&1 || create_new_license "$git_dir"
  if git -C "$git_dir" init . |& __devnull && git -C "$git_dir" add . |& __devnull && git -C "$git_dir" commit -q -m "$GITCOMMIT_MESSAGE"; then
    printf_green "Success: $show_git_repo has been initialized"
  else
    printf_exit "Failed to initialize $show_git_repo"
  fi
  if [ -n "$git_prev" ]; then
    printf_read_question "3" "Should I reuse the remote repo ($git_prev)? [y/n] " "1" "git_reuse"
  else
    git_prev=""
    git_repo=""
    git_remote_repo=""
  fi
  echo "$git_prev" | __test_if_url -q || git_prev="https://$git_prev"
  if printf_answer_yes "$git_reuse"; then
    git_remote="y"
    git_remote_repo="$git_prev"
    __split_create_repo "$git_prev" || printf_exit "$git_prev repo does not exist"
    run_git_init "$git_dir"
  else
    printf_read_question "3" "Should I add a remote repo? [y/n] " "1" "git_remote"
    if printf_answer_yes "$git_remote"; then
      if printf_read_question "3" "Should I use ${GREEN}($remote_repo_init) " "1" "reply"; then
        git_remote_repo="https://$remote_repo_init"
        reply=$git_remote_repo
      else
        printf_read_input "3" "Enter remote repo: " "120" "git_remote_repo"
      fi
      export git_remote_repo
      if run_git_init "$git_dir" $git_remote_repo; then
        GITADMIN_EXITCODE=0
      else
        GITADMIN_EXITCODE=1
      fi
    else
      printf_yellow "You have decided not to add a remote repository"
    fi
  fi
  if [ $GITADMIN_EXITCODE -ne 0 ]; then
    printf_red "Initialization has failed"
  fi
  echo ""
  exit $GITADMIN_EXITCODE
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run git setup with no interactions
run_git_setup_automated() {
  remote_repo="$1"
  git_dir="$(__basedir "$GITADMIN_CWD/.git" | grep -v '^$' | grep '^')"
  git_version_file="$GITADMIN_DEFAULT_VERSION_FILE"
  git_version_fmt="$GITADMIN_DEFAULT_VERSION_FORMAT"
  git_prev="${remote_repo:-$(__git_remote_push "$GITADMIN_CWD")}"
  GITADMIN_SETUP_MESSAGE="${GITADMIN_SETUP_MESSAGE:-$GITCOMMIT_MESSAGE}"
  GITCOMMIT_MESSAGE="${GITADMIN_SETUP_MESSAGE:- 🦈🏠🐜❗ Initial Commit ❗🐜🦈🏠 }"
  GITADMIN_EXITCODE=0
  printf_green "Initializing the repo in $git_dir"
  [ -n "$git_prev" ] || git_prev="github.com/$(basename -- "$(dirname $GITADMIN_CWD)")/$(basename -- "$GITADMIN_CWD")"
  [ -f "$git_dir/.gitattributes" ] || gen-gitattr $git_dir save default lfs &>/dev/null
  [ -f "$git_dir/.gitignore" ] || gitignore "$git_dir" default --automated &>/dev/null
  if [ -d "$git_dir/.git" ]; then
    printf_yellow "This project already has git setup"
    if [ -n "$git_prev" ]; then
      printf_green "Remote repo is: $git_prev"
    fi
    __rm_rf "$git_dir/.git"
  fi
  [ -f "$git_version_file" ] && date +"$git_version_fmt" >"$git_version_file"
  ls "$git_dir/README"* >/dev/null 2>&1 || create_new_readme_template "$git_dir"
  ls "$git_dir/LICENSE"* >/dev/null 2>&1 || create_new_license "$git_dir"
  if git -C "$git_dir" init . |& __devnull && git -C "$git_dir" add . |& __devnull && git -C "$git_dir" commit -q -m "$GITCOMMIT_MESSAGE"; then
    printf_green "Success: $(__git_repobase "$git_dir") has been initialized"
  else
    printf_exit "Failed to initialize $(__git_repobase "$git_dir")"
  fi
  echo "$git_prev" | __test_if_url -q || git_prev="https://$git_prev"
  __split_create_repo "$git_prev" || printf_exit "$git_prev repo does not exist"
  run_git_init_automated "$git_dir" "$git_prev"
  GITADMIN_EXITCODE=$?
  if [ $GITADMIN_EXITCODE -ne 0 ]; then
    printf_red "Initialization has failed"
  fi
  echo ""
  exit $GITADMIN_EXITCODE
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
run_git_init_automated() {
  git_dir="${1:-$GITADMIN_CWD}"
  git_repo="${2:-$git_prev}"
  if [ -n "$git_repo" ]; then
    git -C "$git_dir" remote add origin "$git_repo" &>/dev/null
    if __git_remote_push | grep -q "$git_repo"; then
      printf_cyan "$git_repo has been added"
    else
      printf_exit "Failed to add $git_repo"
    fi
    if [ -f "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" ]; then
      cp -Rf "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" "$git_dir/.git/config"
    fi
    [ ! -f "$git_dir/.no_push" ] && git -C "$git_dir" push -q -f --set-upstream origin "$GITADMIN_DEFAULT_BRANCH" &>/dev/null || return
    git -C "$git_dir" remote show origin 2>&1 | grep -q 'Repository not found' && git_push="n"
    [ "$git_push" = "n" ] && printf_yellow "The remote repository wasn't found: not pushing" || __git_push "$git_dir"
    GITADMIN_EXITCODE=$?
    if [ -d "$git_dir/.git" ] && [ "$GITADMIN_EXITCODE" = 0 ]; then
      [ "$git_push" = "n" ] || printf_green "Successfully pushed to $git_repo"
      GITADMIN_EXITCODE=0
    else
      printf_red "Push to $git_repo has failed"
      GITADMIN_EXITCODE=1
    fi
  else
    printf_red "No remote repo specified"
    GITADMIN_EXITCODE=1
  fi
  return ${GITADMIN_EXITCODE:-$?}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Makes a new jeckyll site
make_newsite() {
  local site_dir="" site_folder="" site_repo=""
  site_dir="$HOME/Public/sites"
  site_folder="${1:-newsite}"
  site_repo="${2:-$GITADMIN_DOMAIN_TEMPLATE}"
  printf_green "Setting up site in: $site_dir/$site_folder"
  printf_blue "Using $site_repo as template"
  if __git_clone "$site_repo" "$site_dir/$site_folder"; then
    cd "$site_dir/$site_folder" || return 1
    __rm_rf "$site_dir/$site_folder/.git"
    [[ "$EDITOR" =~ code ]] && code . || "$EDITOR" _config.yml
    printf_pause "Prease any key when you are done."
    gitadmin --dir "$site_dir/$site_folder" setup
  else
    printf_error "Failed to clone $GITADMIN_DOMAIN_TEMPLATE"
    false
  fi
  exit $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Gets the organizations from the user
git_retrieve_orgs() {
  git_user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  api_url="https://api.github.com"
  if [ -n "$GITADMIN_GITHUB_AUTH_TOKEN" ]; then
    git_user="$(__curl_gh_api "$api_url/user/orgs?per_page=1000" | __jq -rc '.[].login' | sort -u | grep '^')"
  else
    git_user="$(__curl_gh_api "$api_url/users/$git_user/orgs?per_page=1000" | __jq -rc '.[].login' 2>/dev/null | sort -u | grep '^')"
  fi
  export GIT_ALL_REPOS="${git_user}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
git_all_orgs_clone() {
  git_retrieve_orgs "${1:-$GITADMIN_DEFAULT_USERNAME}"
  total="$(printf '%s\n' "$GIT_ALL_REPOS" | tr ' ' '\n ' | grep -v '^$' | grep '^' | wc -l)"
  [ -n "$total" ] && printf_blue "$GITADMIN_DEFAULT_USERNAME has $total organizations"
  for org in $GIT_ALL_REPOS; do
    $0 orgs clone "$org"
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Initializes a repo with default options
repos_init() {
  local git_dir="" git_version_file="" git_version_fmt=""
  git_dir="$(__basedir "${1:-$GITADMIN_CWD}/.git")"
  git_version_file="$GITADMIN_DEFAULT_VERSION_FILE"
  git_version_fmt="$GITADMIN_DEFAULT_VERSION_FORMAT"
  [ -f "$git_version_file" ] && date +"$git_version_fmt" >"$git_version_file"
  git -C "$git_dir" add .
  if [ -f "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" ]; then
    cp -Rf "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" "$git_dir/.git/config"
  fi
  __devnull2 git -C "$git_dir" commit -m ' 🦈🏠🐜 Initial Commit 🐜🦈🏠 '
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Initializes a repo for github
git_init() {
  local git_dir="" git_version_file="" git_version_fmt="" git_remote=""
  username="$(echo "$*" | grep -q '/' && echo "$*" | awk '{print $1}' || echo "$1")"
  reponame="$(echo "$*" | grep -q '/' && echo "$*" | awk '{print $2}' || echo "$2")"
  git_dir="$(__basedir "${username:-$GITADMIN_CWD}/.git")"
  git_version_file="$GITADMIN_DEFAULT_VERSION_FILE"
  git_version_fmt="$GITADMIN_DEFAULT_VERSION_FORMAT"
  git_remote=""
  [ "${1:-$username}" = "" ] && printf_red "Usage: userName repoName\n" && return 1
  [ "${2:-$reponame}" = "" ] && printf_red "Usage: userName repoName\n" && return 1
  #git_setup "$git_dir"
  [ -f "$git_version_file" ] && date +"$git_version_fmt" >"$git_version_file"
  __devnull2 git -C "$git_dir" add .
  if [ -f "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" ]; then
    cp -Rf "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" "$git_dir/.git/config"
  fi
  __devnull2 git -C "$git_dir" commit -m ' 🦈🏠🐜 Initial Commit 🐜🦈🏠 '
  __devnull2 git -C "$git_dir" remote add origin "${remote:-https://github.com/$username/$reponame}"
  __git_push "$git_dir" -u origin "$GITADMIN_DEFAULT_BRANCH"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# List gists
ghgist_list() {
  local user=""
  user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  shift 1
  __api_gist "$user" | __jq ".[] | .description, .id" 2>/dev/null | awk 'NR%2{printf "%s ",$0;next;}1' | sed 's|""|"No Description"|g;s/" "/ | ID: /g;s|^"|Gist Title: |g;s|"||g' && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# search gists
search_list() {
  local user=""
  user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  shift 1
  __api_gist "$1" | __jq ".[] | .description, .id" 2>/dev/null | awk 'NR%2{printf "%s ",$0;next;}1' | sed 's|""|"No Description"|g;s/" "/ | ID: /g;s|^"|Gist Title: |g;s|"||g' | grep -is "$2"
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Delete gist
ghgist_delete() {
  local gist_id="" gist_exit="" gist_succes="" gist_failed=""
  gist_exit="0"
  gist_id="$(basename -- "$1")" && shift 1
  gist_succes="Deleted gist: $gist_id"
  gist_failed="failed to delete gist: $gist_id"
  [ -n "$gist_id" ] || printf_exit "Please provide the gist ID"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1
  __curl_gh_api -X DELETE "https://api.github.com/gists/$gist_id" >"$GITADMIN_TEMP_FILE" && gist_exit=0 || gist_exit=1
  if grep -viqs "Not Found" "$GITADMIN_TEMP_FILE"; then
    gist_succes="[ ✖ ] gist: $gist_id was not found"
    gist_exit=0
  fi
  __getexitcode $gist_exit "$gist_succes" "$gist_failed"
  return $gist_exit
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
format_file_as_JSON_string() {
  sed -e 's/\\/\\\\/g' \
    -e 's/$/\\n/g' \
    -e 's/"/\\"/g' \
    -e 's/\t/\\t/g' |
    tr -d "\n"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Creates a new gist from - https://github.com/kathawala/gist/blob/master/gist.sh
ghgist_create() {
  local gist_exit="0" gist_describe="" gist_filename="" gist_content="" gist_succes="" gist_failed="" save_dir=""
  gist_describe="$(echo "$1" | awk '{gsub(/"/, "\\\"")} 1' | grep '' || echo '')"
  gist_filename="$2"
  gist_get_content="${3:-}"
  format_gist="$(echo "$gist_get_content" | format_file_as_JSON_string)"
  save_dir="${GISTADMIN_GIST_SAVE_DIR:-$HOME/Documents/myscripts/gists}"
  gist_content="$(printf "%s\r" "{ \"description\": \"$gist_describe\", \"public\": true, \"files\": {\"$gist_filename\": { \"content\": \"$format_gist\" }}}" >${GITADMIN_TEMP_FILE}-data.txt)"
  [ $# -eq 3 ] || printf_help "Usage: $APPNAME gist create description filename contents"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1
  printf_green "Creating gist with Description $gist_describe and filename: $gist_filename"
  mkdir -p "$save_dir"
  [ -f "$save_dir/all.txt" ] || printf '%s\n' "# My saved gists" >"$save_dir/all.txt"
  __curl_gh_api -X POST -if "https://api.github.com/gists" --data @"${GITADMIN_TEMP_FILE}-data.txt" | grep -w "html_url" | grep "gist" | awk '{print $2}' | __sed 's/\,//;s|"||g' >"${GITADMIN_TEMP_FILE}"
  results="$(grep -qs '^' "${GITADMIN_TEMP_FILE}" && echo Success || echo '')"
  if [ "$results" = "Success" ]; then
    gist_exit=0
    gist_id="Gist ID: $(basename $(head -n1 "$GITADMIN_TEMP_FILE") 2>/dev/null)"
    gist_succes="Gist Url: $(cat "$GITADMIN_TEMP_FILE" 2>/dev/null)"
    printf '%s: %s\n' "$gist_filename" "${gist_id// *:/}" >>"$save_dir/all.txt"
    printf_cyan "$gist_id"
    __rm_rf "${GITADMIN_TEMP_FILE}-data.txt"
  else
    gist_exit=1
    gist_failed="Failed to create the gist"
    [ -f "${GITADMIN_TEMP_FILE}.err" ] && cat "${GITADMIN_TEMP_FILE}.err" | printf_readline '1'
    [ -f "${GITADMIN_TEMP_FILE}-data.txt" ] && cp -Rf "${GITADMIN_TEMP_FILE}-data.txt" "${GITADMIN_TEMP_FILE}-data.failed.txt"
  fi
  __getexitcode $gist_exit "$gist_succes" "$gist_failed"
  return $gist_exit
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Edits a gist
ghgist_edit() {
  local gist_exit="" gist_id="" gist_describe="" gist_filename="" gist_content="" gist_succes="" gist_failed=""
  gist_exit=0
  gist_id="$1"
  gist_describe="$2"
  gist_filename="$3"
  gist_content="$4"
  gist_describe="${gist_describe:-$(basename -- "$gist_filename")}"
  gist_content="$(printf "%s\r" "{ \"description\": \"$gist_describe\", \"public\": true, \"files\": { \"$gist_filename\": {\"content\": \"$gist_content\" }}}" >$GITADMIN_TEMP_FILE-data.txt)"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1
  printf_green "Editing $gist_id with Description $gist_describe and filename: $gist_filename"
  if __curl_gh_api -X PATCH -i --data @$GITADMIN_TEMP_FILE-data.txt https://api.github.com/gists/$gist_id | grep -w "html_url" | grep "gist" | awk '{print $2}' | __sed 's/\,//;s|"||g' >"$GITADMIN_TEMP_FILE"; then
    gist_exit=0
    gist_id="Gist ID: $(basename $(head -n1 "$GITADMIN_TEMP_FILE"))"
    gist_succes="🚄 Gist Url: $(cat "$GITADMIN_TEMP_FILE" | grep -v '^$') 🚄"
    __rm_rf "$GITADMIN_TEMP_FILE-data.txt"
  else
    gist_exit=1
    gist_failed="🤪 Failed to create the gist 🤪"
  fi
  printf_cyan "$gist_id"
  __getexitcode $gist_exit "$gist_succes" "$gist_failed"
  return $gist_exit
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Reusable function for delete
ghdelete_user() {
  local git_user=""
  local git_repo=""
  local url="https://api.github.com/repos"
  if echo "$1" | grep -q '/'; then
    git_user="${1//\/*/}"
    git_repo="${1//*\//}"
  else
    git_user="${1:-$GITADMIN_DEFAULT_USERNAME}"
    git_repo="${2:-$REPONAME}"
  fi
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1
  curl -q -LSsf -X DELETE -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${GITADMIN_GITHUB_AUTH_TOKEN}" "${url}/${git_user}/${git_repo}" >"$GITADMIN_TEMP_FILE"
  if grep -qs 'Not Found' "$GITADMIN_TEMP_FILE"; then
    return 0
  elif [ -s "$GITADMIN_TEMP_FILE" ]; then
    return 0
  elif __api_user "$git_user" | grep -qvi "$git_repo$"; then
    return 0
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Creates a new repo on github
ghcreate() {
  local git_user="" git_repo="" git_describe="" git_failed="" git_succes GITADMIN_EXITCODE=0 git_describe=""
  if echo "$1" | grep -q '/'; then
    git_user="${1//\/*/}"
    git_repo="${1//*\//}"
    git_describe="${2:-repo for $git_repo}"
    shift 2
  else
    git_user="$1"
    git_repo="$2"
    git_describe="${3:-repo for $git_repo}"
    shift 3
  fi
  [ -f "$GITADMIN_CWD/DESCRIPTION" ] && description="$(<"$GITADMIN_CWD/DESCRIPTION")" || git_describe="${git_describe:-}"
  api_url="https://api.github.com/repos"
  git_succes="😻 Success: https://github.com/$git_user/$git_repo 😻"
  git_failed="👿 Creation of https://github.com/$git_user/$git_repo failed 👿"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1
  printf_blue "This may take a few seconds."
  printf_blue "Sending your request to the github API."
  printf_green "Creating $git_repo for user $git_user"
  if __api_repo_verify "$api_url" "$git_user" "$git_repo"; then
    printf_cyan "$git_succes"
    GITADMIN_EXITCODE=0
  elif curl_orgs_create "$git_user" "$git_repo" "$git_describe" "$1" "$2" "$3" "$4" || curl_user_create "$git_user" "$git_repo" "$git_describe" "$1" "$2" "$3" "$4"; then
    sleep 5
    if __api_repo_verify "$api_url" "$git_user" "$git_repo" &>/dev/null; then
      printf_cyan "$git_succes"
      GITADMIN_EXITCODE=0
    else
      printf_yellow "$git_failed"
      GITADMIN_EXITCODE=1
    fi
  else
    printf_yellow "😠 An error occured while trying to create github.com/$git_user/$git_repo 😠"
    GITADMIN_EXITCODE=1
  fi
  return "$GITADMIN_EXITCODE"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Deletes a github repo
ghdelete() {
  local git_user="" git_repo="" git_failed="" git_succes="" GITADMIN_EXITCODE=""
  local api_url="https://api.github.com/repos"
  if echo "$1" | grep -q '/'; then
    git_user="$(echo "$@" | awk -F '/' '{print $(NF-1)}')"
    git_repo="$(echo "$@" | awk -F '/' '{print $NF}')"
  else
    git_user="$1"
    git_repo="$2"
  fi
  if __api_repo_verify "$api_url" "$git_user" "$git_repo"; then
    git_failed="💢 Deletion of http://github.com/$git_user/$git_repo failed 💢"
    git_succes="🌱 Deletion of http://github.com/$git_user/$git_repo successful 🌱"
    GITADMIN_EXITCODE=0
    printf_green "Deleting repo $git_repo for user $git_user"
    ghdelete_user "$git_user" "$git_repo"
    if __api_repo_verify "$api_url" "$git_user" "$git_repo"; then
      GITADMIN_EXITCODE=1
    fi
  else
    printf_yellow "❔ The repo http://github.com/$git_user/$git_repo does not exist ❔"
    exit "1"
  fi
  __getexitcode $GITADMIN_EXITCODE "$git_succes" "$git_failed"
  return $GITADMIN_EXITCODE
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Reusable function for create repo
curl_orgs_create() {
  local user="$1"
  local repo="$2"
  local DESCR="${3:-$DESCR}"
  local SITE="${4:-$HOMEPAGE}"
  local VISIBLE="${5:-$GITADMIN_REPO_VISIBLE}"
  local SITE="${SITE:-http://github.com/$user/$repo}"
  local url="https://api.github.com/orgs/$user/repos"
  echo "$SITE" | grep -q '://.*\.[a-zA-Z0-9].*/.*' || SITE="https://github.com/$SITE"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1
  [ "$GITADMIN_REPO_VISIBLE" = "no" ] && VISIBLE="true" || VISIBLE="${VISIBLE:-false}"
  __curl_gh_api "$url" --data "{ \"name\":\"$repo\",\"description\":\"$DESCR\",\"homepage\":\"$SITE\",\"private\":$VISIBLE,\"has_issues\":\"true\" }" >"$GITADMIN_TEMP_FILE"
  if grep -qis '"full_name".*"'$user'/'$repo'"' "$GITADMIN_TEMP_FILE"; then
    printf_green "https://github.com/$user/$repo has been created"
    return 0
  elif grep -qis 'name already exists on this account' "$GITADMIN_TEMP_FILE"; then
    printf_green "https://github.com/$user/$repo already exists"
    return 0
  elif grep -qis 'Not Found' "$GITADMIN_TEMP_FILE"; then
    return 1
  else
    if [ -f "$GITADMIN_TEMP_FILE" ]; then
      cat "$GITADMIN_TEMP_FILE" | __jq -r '.errors | .[].message' 2>/dev/null | printf_readline
    fi
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
curl_user_create() {
  local user="$1"
  local repo="$2"
  local DESCR="${3:-$DESCR}"
  local SITE="${4:-$HOMEPAGE}"
  local VISIBLE="${5:-$GITADMIN_REPO_VISIBLE}"
  local url="https://api.github.com/user/repos"
  local SITE="${SITE:-http://github.com/$user/$repo}"
  echo "$SITE" | grep -q '://.*\.[a-zA-Z0-9].*/.*' || SITE="https://github.com/$SITE"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1
  [ "$GITADMIN_REPO_VISIBLE" = "no" ] && VISIBLE="true" || VISIBLE="${VISIBLE:-false}"
  __curl_gh_api -f "$url" --data "{ \"name\":\"$repo\",\"description\":\"$DESCR\",\"homepage\":\"$SITE\",\"private\":$VISIBLE,\"has_issues\":\"true\",\"has_projects\":\"false\" }" >"$GITADMIN_TEMP_FILE"
  if grep -qis '"full_name".*"'$user'/'$repo'"' "$GITADMIN_TEMP_FILE"; then
    return 0
  elif grep -qis 'name already exists on this account' "$GITADMIN_TEMP_FILE"; then
    return 0
  elif grep -qis 'Not Found' "$GITADMIN_TEMP_FILE"; then
    return 1
  else
    if [ -f "$GITADMIN_TEMP_FILE" ]; then
      cat "$GITADMIN_TEMP_FILE" | __jq -r '.errors | .[].message' 2>/dev/null | printf_readline
    fi
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# clone a single repo from user
ghsinglerepo() {
  username="$(echo "$*" | grep -q '/' && echo "$*" | awk '{print $1}' || echo "$1")"
  reponame="$(echo "$*" | grep -q '/' && echo "$*" | awk '{print $2}' || echo "$2")"
  [ "${1:-$username}" = "" ] && printf_red "Usage: --single userName repoName" && return 1
  [ "${2:-$reponame}" = "" ] && printf_red "Usage: --single userName repoName" && return 1
  __git_clone "https://github.com/$1/$2" "${3:-}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_push_mirror() {
  local workingDir="${1:-$workingDir:-GITADMIN_CWD}"
  if [ -f "$workingDir/.gitmirror" ]; then
    while read -r url; do
      printf '%b' "$(printf_blue "👾 Pushing to $url: ")" && git -C "$workingDir" push $url -q 2>/dev/null
      retVal=$?
      if [ $retVal -eq 0 ]; then
        retVal=0
        printf_green "success 👾"
      else
        printf_red "Failed ⚠️"
        exitCode=$((exitCode + retVal))
      fi
    done <"$workingDir/.gitmirror"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# push local repo
git_push_single() {
  local SET_BASE_REPO="" GITADMIN_EXITCODE="0" username="" user_repo=""
  SUCCESS_MSG() { echo "👾 Push to $(__git_remote_origin "${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_CWD}") has completed 👾"; }
  FAILED_MSG() { echo "😿 Push to $(__git_remote_origin "${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_CWD}") has failed 😿"; }
  SET_BASE_REPO="$1"
  GITADMIN_CWD_NAME="$(basename -- "${SET_BASE_REPO:-$GITADMIN_CWD}")"
  [ -d "$SET_BASE_REPO" ] && shift 1
  if [ -d "$SET_BASE_REPO/.git" ]; then
    printf_custom "4" "🐛 Pushing the repo in $SET_BASE_REPO 🐛"
    __git_push_mirror "$SET_BASE_REPO"
    __git_custom "$SET_BASE_REPO" push && GITADMIN_EXITCODE=0 || GITADMIN_EXITCODE=1
    __getexitcode $GITADMIN_EXITCODE "$(SUCCESS_MSG)" "$(FAILED_MSG)"
  else
    if [ -n "$1" ]; then
      GITADMIN_CWD_NAME="$(__git_hostname "$1")"
      GITADMIN_NEW_PROJECT_DIR="$1"
      __git_username_repo "$1"
      username="${username:-}"
      userrepo="${userrepo:-}"
    else
      GITADMIN_NEW_PROJECT_DIR="${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_CWD_NAME/$username/$userrepo}"
    fi
    if [ -d "$GITADMIN_NEW_PROJECT_DIR/.git" ]; then
      printf_custom "4" "🐛 Pushing the repo in $GITADMIN_NEW_PROJECT_DIR 🐛"
      __git_push_mirror "$GITADMIN_NEW_PROJECT_DIR"
      __git_push "$GITADMIN_NEW_PROJECT_DIR" && GITADMIN_EXITCODE=0 || GITADMIN_EXITCODE=1
      __getexitcode $GITADMIN_EXITCODE "$(SUCCESS_MSG)" "$(FAILED_MSG)"
    else
      GITADMIN_EXITCODE=1
    fi
  fi
  return $GITADMIN_EXITCODE
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# pull a single repo
git_pull_single() {
  local SET_BASE_REPO="" GITADMIN_EXITCODE="0" username="" user_repo=""
  SUCCESS_MSG() { echo "Pull from $(__git_remote_origin "${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_CWD}") has completed"; }
  FAILED_MSG() { echo "Pull from $(__git_remote_origin "${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_CWD}") has failed"; }
  SET_BASE_REPO="$1"
  GITADMIN_CWD="$(realpath $SET_BASE_REPO)"
  GITADMIN_CWD_NAME="$(basename -- "${SET_BASE_REPO:-$GITADMIN_CWD}")"
  [ -d "$SET_BASE_REPO" ] && shift 1
  if [ -d "$GITADMIN_CWD/.git" ]; then
    printf_custom "4" "Updating the repo in $GITADMIN_CWD"
    __git_custom "$GITADMIN_CWD" pull && GITADMIN_EXITCODE=0 || GITADMIN_EXITCODE=1
    __getexitcode $GITADMIN_EXITCODE "$(SUCCESS_MSG)" "$(FAILED_MSG)"
  else
    if [ -n "$SET_BASE_REPO" ]; then
      __git_username_repo "$SET_BASE_REPO"
      GITADMIN_CWD_NAME="$(__git_hostname "$SET_BASE_REPO")"
      GITADMIN_NEW_PROJECT_DIR="$1"
    else
      GITADMIN_NEW_PROJECT_DIR="${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_CWD_NAME/$username/$userrepo}"
    fi
    if [ -d "$GITADMIN_NEW_PROJECT_DIR/.git" ]; then
      printf_custom "4" "Updating the repo in $GITADMIN_NEW_PROJECT_DIR"
      __git_pull "$GITADMIN_NEW_PROJECT_DIR" && GITADMIN_EXITCODE=0 || GITADMIN_EXITCODE=1
      __getexitcode $GITADMIN_NEW_PROJECT_DIR "$(SUCCESS_MSG)" "$(FAILED_MSG)"
    else
      return 1
    fi
  fi
  return "${GITADMIN_EXITCODE:-$?}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# clone a single repo
git_clone_single() {
  local set_url="$1" git_url="" FAILED_MSG="" SUCCESS_MSG="" GITADMIN_EXITCODE=""
  git_url="$set_url"
  __git_username_repo "$git_url"
  GITADMIN_NEW_PROJECT_DIR="${2:-$GITADMIN_NEW_PROJECT_DIR}"
  GITADMIN_NEW_PROJECT_DIR="${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_CWD_NAME/$username/$userrepo}"
  FAILED_MSG="😿 Cloning from $git_url has failed 😿"
  SUCCESS_MSG="😻 Cloning from $git_url has completed 😻"
  GITADMIN_EXITCODE=0
  if [ -d "$GITADMIN_NEW_PROJECT_DIR/.git" ]; then
    printf_custom "4" "👾 Updating the repo in $GITADMIN_NEW_PROJECT_DIR 👾"
    __git_pull "$GITADMIN_NEW_PROJECT_DIR" && GITADMIN_EXITCODE=0 || GITADMIN_EXITCODE=1
    __getexitcode $GITADMIN_EXITCODE "$SUCCESS_MSG" "$FAILED_MSG"
  else
    printf_custom "4" "👾 Cloning the repo to $GITADMIN_NEW_PROJECT_DIR 👾 "
    __git_clone "$git_url" "$GITADMIN_NEW_PROJECT_DIR" && GITADMIN_EXITCODE=0 || GITADMIN_EXITCODE=1
    __getexitcode $GITADMIN_EXITCODE "$SUCCESS_MSG" "$FAILED_MSG"
  fi
  return "$?"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#continue pulling
git_update_loop() {
  if [[ "$*" =~ "--while" ]]; then
    while true; do
      for project in $(ls -d "$GITADMIN_DEFAULT_PROJECT_DIR"/*/*/*); do
        printf_green "Updating $project $(__git_pull "$project" |& __devnull) $(__getexitcode)"
      done && clear
      printf_custom "3" "Sleeping for a minute $(sleep 60)"
    done
  else
    for project in $(ls -d "$GITADMIN_DEFAULT_PROJECT_DIR"/*/*/*); do
      printf_green "Updating $project $(__git_pull "$project" |& __devnull) $(__getexitcode)"
    done
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# cron functions
__run_cron() {
  local frequency="0 4 * * 6"
  local croncmd="$APPNAME cron run"
  case $1 in
  run)
    logr -name gitadmin 'am_i_online --console && $(expr $RANDOM \% 300) && gitadmin org all && gitadmin --user'
    ;;
  remove)
    shift 1
    removecrontab "$frequency $croncmd"
    ;;
  add)
    addtocrontab "$frequency $croncmd"
    ;;
  *)
    addtocrontab "$frequency $croncmd"
    ;;
  esac
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Shorten URL
git_io() {
  ptintf_exit "This has been disabled by github: Will create my own"
  local short_url="" short_name=""
  short_url="$1"
  short_name="$2"
  printf_blue "Attempting to create $short_url on git.io"
  if [ -n "$short_name" ]; then
    MESSAGE="$(curl -q -LSsi https://git.io -F "url=$short_url" -F "code=$short_name" 2>/dev/null | grep 'Location: ')"
  else
    MESSAGE="$(curl -q -LSsi https://git.io -F "url=$short_url" 2>/dev/null | grep 'Location: ')"
  fi
  if [ -n "$MESSAGE" ]; then
    printf_green "$MESSAGE"
  else
    printf_return "Failed to create the shortened URL"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# rename branch
__rename_branch_api() {
  local git_branch="" git_user="" git_repo=""
  git_branch="$1"
  git_user="${2:-$(basename -- "$(dirname "$GITADMIN_CWD")")}"
  git_repo="${3:-$(basename -- "$GITADMIN_CWD")}"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1
  if __curl_gh_api -X PATCH "https://api.github.com/repos/$git_user/$git_repo" -d '{"default_branch":"'$git_branch'"}' | grep -qs '"default_branch": "'$git_branch'"' >/dev/null; then
    git -C "$GITADMIN_CWD" push --delete origin ${git_old_branch:-master} -fq &>/dev/null || return 1
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_config_branch() {
  git config init.defaultBranch "${1:-main}" &>/dev/nulll
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# rename master to main
__rename_branch() {
  local git_branch="" git_user="" git_repo=""
  local exitCode=0
  git_branch="${1:-main}"
  git_user="${2:-$(basename -- "$(dirname "$GITADMIN_CWD")")}"
  git_repo="${3:-$(basename -- "$GITADMIN_CWD")}"
  git_config_branch="$(git config --get init.defaultBranch | grep '')"
  printf_blue "Changing git branch to $git_branch on $git_repo"
  if [ -f "$GITADMIN_CWD/.git/config" ]; then
    git -C "$GITADMIN_CWD" branch -m ${git_old_branch:-master} "$git_branch" &>/dev/null
    git -C "$GITADMIN_CWD" push -u origin "$git_branch" -fq &>/dev/null
    git -C "$GITADMIN_CWD" push --set-upstream origin $git_branch
  fi
  if __rename_branch_api "$git_branch" "$git_user" "$git_repo"; then
    printf_green "Changed the default branch on github.com/$git_user/$git_repo"
  fi &&
    printf_green "Successfully renamed the default branch" ||
    { printf_red "Failed to rename the default branch" && exitCode=1; }
  if [ "$git_config_branch" != "$git_branch" ]; then
    __git_config_branch "$git_branch"
  fi
  #grep -rl --exclude-dir='.git' '/raw/'${git_old_branch:-master}'/' "$GITADMIN_CWD" | xargs sed -i 's|/raw/'${git_old_branch:-master}'/|/raw/'$branch'/|g'
  #gitcommit
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__clone_orgs() {
  GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
  GITADMIN_DEFAULT_REPO_BASE="${2:-$GITADMIN_DEFAULT_REPO_BASE}/$GITADMIN_DEFAULT_USERNAME"
  GITADMIN_NEW_PROJECT_DIR="$GITADMIN_DEFAULT_PROJECT_DIR/github"
  __api_org_token "$GITADMIN_DEFAULT_USERNAME" || return 1
  printf_green "$MESSAGE"
  printf_blue "There's currently $COUNT repos available"
  main "$GITADMIN_DEFAULT_REPO_BASE"
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# main cloning function
main() {
  local git_user="" git_repo="" git_base="" git_dir="" git_failed="" git_succes="" user_repo=""
  sleep 3
  __git_username_repo "$1"
  git_user="$1"
  git_repo="${2:-$GITADMIN_DEFAULT_REPO_BASE}"
  git_base="${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_DEFAULT_PROJECT_DIR/github}"
  printf_yellow "ProjectDir: ${git_base}"
  printf_yellow "BaseRepo URL: $git_repo"
  echo ""
  for i in $(<"$GITADMIN_TEMP_FILE"); do
    local_dir_name="$(basename -- "$i")"
    user_repo="$git_repo/$local_dir_name"
    local_user_name="$(basename -- "$git_repo")"
    git_dir="$git_base/$local_user_name/$local_dir_name"
    if [ -d "$git_dir/.git" ]; then
      git_failed="👿 Failed to update repo in $git_dir 👿"
      git_succes="😼 Updated git repo in $git_dir 😼 "
      printf_purple "💽 Now running git pull $user_repo 💽"
      if [ -f "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" ]; then
        cp -Rf "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" "$git_dir/.git/config"
      fi
      __git_pull "$git_dir"
      __getexitcode "$git_succes" "$git_failed"
    else
      git_failed="👿 Failed to clone to $git_dir 👿 "
      git_succes="😼 Successfully cloned to $git_dir 😼 "
      printf_purple "🌀 Now running git clone $user_repo 🌀"
      __git_clone "$user_repo" "$git_dir"
      __getexitcode "$git_succes" "$git_failed"
    fi
    echo ""
  done
  return "${EXIT:-$?}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__cd_into() {
  [ "$GITADMIN_AUTO_CD" = "true" ] || return 0
  if [ "$PWD" != "$1" ]; then
    if [ -d "$1" ] && builtin cd "$1"; then
      printf_green "Changing the directory to $1"
      printf_yellow "Type exit to return to your previous directory"
      exec bash || return 1
    else
      exit 1
    fi
  fi
}
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_remote_push() {
  local dir="${1:-${GITADMIN_CWD:-.}}"
  local gitconfig="${GITADMIN_DEFAULT_MAINCONFIG:-gitmainconfig}"
  local set_remote="" get_remote=""
  get_remote="$(grep -sh 'pushurl =' "$dir/$gitconfig" "$dir/.git/config" | awk -F '=' '{print $2}' | grep '^' || grep -sh 'push =' "$dir/$gitconfig" "$dir/.git/config" | awk -F '=' '{print $2}')"
  get_remote="$(echo "${get_remote// /}" | head -n1)"
  if [ -z "$get_remote" ]; then
    set_remote="$(git -C "$dir" remote -v 2>/dev/null | grep 'push' | __test_if_url | head -n 1 | awk '{print $2}' 2>/dev/null | grep '^' || echo "$git_prev")"
  fi
  printf '%s\n' "${get_remote:-$set_remote}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_status() { git -C "${1:-${GITADMIN_CWD:-.}}" status -b -s 2>/dev/null && return 0 || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_log() {
  local head="" args="${2:-$1}"
  if __test_if_number "$args"; then
    git -C "${1:-${GITADMIN_CWD:-.}}" log --pretty='%C(magenta)%h%C(red)%d %C(yellow)%ar %C(green)%s %C(yellow)(%an)' --max-count=$args 2>/dev/null
    return $?
  else
    git -C "${1:-${GITADMIN_CWD:-.}}" log --pretty='%C(magenta)%h%C(red)%d %C(yellow)%ar %C(green)%s %C(yellow)(%an)' 2>/dev/null
    return $?
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_org_clone_repos() {
  local exitCode=0
  GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
  GITADMIN_DEFAULT_REPO_BASE="$GITADMIN_DEFAULT_REPO_BASE/$GITADMIN_DEFAULT_USERNAME"
  __api_org_token "$GITADMIN_DEFAULT_USERNAME" | grep -w clone_url | awk -F / '{print $NF}' | __sed 's/\",//' | __sed 's/\.[^.]*$//' >"$GITADMIN_TEMP_FILE"
  COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
  if [ -n "$COUNT" ]; then
    printf_green "$MESSAGE"
    printf_blue "There's currently $COUNT repos available"
    printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
    main "$GITADMIN_DEFAULT_USERNAME"
    exitCode=$?
  else
    exitCode=1
    printf_red "No repos found for $GITADMIN_DEFAULT_USERNAME"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_org_list_repos() {
  local exitCode=0
  GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
  GITADMIN_DEFAULT_REPO_BASE="https://github.com/$GITADMIN_DEFAULT_USERNAME"
  __api_org_token "$GITADMIN_DEFAULT_USERNAME" | sort -u >"$GITADMIN_TEMP_FILE" || echo >>"$GITADMIN_TEMP_FILE"
  COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
  if [ -n "$COUNT" ]; then
    printf_green "$MESSAGE"
    printf_blue "There's currently $COUNT repos available"
    printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
    __file_exists_and_not_empty "$GITADMIN_TEMP_FILE" && cat "$GITADMIN_TEMP_FILE" | printf_column "5" || exitCode=2
  else
    exitCode=1
    printf_red "😿 No repos found for $GITADMIN_DEFAULT_USERNAME 😿"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_org_push_repos() {
  local exitCode=0
  local ERROR SUCCES
  local GIT_MAIN_FILE="${GITADMIN_MAIN_CONF_NAME:-gitmainconfig}"
  GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
  GITADMIN_DEFAULT_REPO_BASE="$GITADMIN_DEFAULT_REPO_BASE/$GITADMIN_DEFAULT_USERNAME"
  __api_user_token "$GITADMIN_DEFAULT_USERNAME"
  __curl_gh_api "$GITHUBAPIREPO" | grep -w clone_url | awk -F / '{print $NF}' | __sed 's/\",//' | __sed 's/\.[^.]*$//' >"$GITADMIN_TEMP_FILE"
  COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
  if [ -n "$COUNT" ]; then
    printf_green "$MESSAGE"
    printf_blue "There's currently $COUNT repos available"
    printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
    repo_list="$(<"$GITADMIN_TEMP_FILE")"
    for i in $repo_list; do
      if [ -d "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i" ]; then
        printf_purple "Now running git push $1/$i"
        ERROR="git push failed for $GITADMIN_DEFAULT_USERNAME/$i"
        SUCCES="git push completed for $GITADMIN_DEFAULT_USERNAME/$i"
        if [ -f "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i/$GIT_MAIN_FILE" ]; then
          cp -Rf "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i/$GIT_MAIN_FILE" "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i/.git/config"
        fi
        if (__devnull2 git -C "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i" status | grep -q "working tree clean"); then
          __getexitcode "$?" "$ERROR" "$SUCCES"
          exitCode=$((exitCode + $?))
        else
          [ -f "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i/version.txt" ] && date +"$GITADMIN_DEFAULT_VERSION_FORMAT" >"$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i/version.txt"
          git -C "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i" add . |& __devnull &&
            git -C "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i" commit -a -m " ❇🦈🏠❗ General Fixes ❗🏠🦈❇ " |& __devnull &&
            __git_push "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i" |& __devnull
          __getexitcode "$?" "$ERROR" "$SUCCES"
          exitCode=$((exitCode + $?))
        fi
      fi
    done
  else
    exitCode=1
    printf_red "😿 No repos found for $GITADMIN_DEFAULT_USERNAME 😿"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_org_options_set() {
  while :; do
    case "$@" in
    description=*)
      ORG_REPO_DESCR="${1//*=/}"
      shift 1
      ;;
    private=*)
      ORG_REPO_PRIVATE="${1//*=/}"
      shift 1
      ;;
    homepage=*)
      ORG_REPO_PRIVATE="${1//*=/}"
      shift 1
      ;;
    projects=*)
      ORG_REPO_PROJECTS="${1//*=/}"
      shift 1
      ;;
    issues=*)
      ORG_REPO_ISSUES="${1//*=/}"
      shift 1
      ;;
    wiki=*)
      ORG_REPO_WIKI="${1//*=/}"
      shift 1
      ;;
    *)
      echo "$1" | grep -q '=' || break
      ;;
    esac
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_org_options_repos() {
  local statusCode=0
  local repo="${1:-$ORG_REPO_NAME}"
  local private="${2:-$ORG_REPO_PRIVATE}"
  local description="${3:-$ORG_REPO_DESCR}"
  local homepage="${4:-$ORG_REPO_HOMEPAGE}"
  local issues="${5:-$ORG_REPO_HOMEPAGE}"
  local projects="${6:-$ORG_REPO_PROJECTS}"
  local wiki="${7:-$ORG_REPO_WIKI}"
  if ! echo "$repo" | grep -q '/'; then printf_red "Please format repo as username/reponame" && return 1; fi
  [ -n "$private" ] && is_private="\"private\":$private,"
  [ -n "$description" ] && is_description="\"description\":\"$description\"."
  [ -n "$homepage" ] && is_homepage="\"homepage\":\"$homepage\","
  [ -n "$issues" ] && has_issues="\"has_issues\":$issues,"
  [ -n "$projects" ] && has_projects="\"has_projects\":$projects,"
  [ -n "$wiki" ] && has_wiki="\"has_wiki\":$wiki,"
  json_data="$(echo "${is_homepage}${is_private}${has_issues}${has_projects}${has_wiki}" | sed 's|,$||g')"
  __github_api_update_repo "$1" -d '{'${json_data}'}'
  statusCode=$?
  if [ "$statusCode" = 0 ]; then
    __printf_space 2 50 "$repo has been updated:" "${json_data//\"/}"
  else
    printf_red "Failed to update the repo"
  fi
  return $statusCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_api_update_repo() {
  local repo="$1" && shift 1
  curl -q -LSsf -X 'PATCH' -H "Authorization: token $GITADMIN_GITHUB_AUTH_TOKEN" -H "Accept: application/vnd.github.v3+json" -H "X-GitHub-Api-Version: $GITADMIN_GITHUB_API_VERSION" "https://api.github.com/repos/$repo" "$@" >/dev/null 2>&1 || return 2
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__is_clean() { __git_status "$1" | grep -v '##' | grep -q '^' && return 1 || return 0; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__is_dirty() { __git_status "$1" | grep -v '##' | grep -q '^' && return 0 || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__strip_git_url() { echo "$1" | sed 's|\.git$||g' | sed -e "s/\r//g"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__curl_gh_api() {
  if [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ]; then
    curl -q -LSs -H "Accept: application/vnd.github.v3+json" -H "X-GitHub-Api-Version: $GITADMIN_GITHUB_API_VERSION" "$@" 2>${GITADMIN_TEMP_FILE}.err
    return $?
  else
    curl -q -LSs -H "Authorization: token $GITADMIN_GITHUB_AUTH_TOKEN" -H "Accept: application/vnd.github.v3+json" -H "X-GitHub-Api-Version: $GITADMIN_GITHUB_API_VERSION" "$@" 2>${GITADMIN_TEMP_FILE}.err
    return $?
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__api_repo_verify() {
  curl -q -LSsf -X GET -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${GITADMIN_GITHUB_AUTH_TOKEN}" "${1}/${2}/${3}" 2>/dev/null | jq -r '.html_url' | grep -qF "${2}/${3}" &>/dev/null
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined variables/import external variables
REPO_URL="${REPO_URL:-}"
PROJECT_DIR="${PROJECT_DIR:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Application Folders
GITADMIN_CONFIG_FILE="${GITADMIN_CONFIG_FILE:-settings.conf}"
GITADMIN_CONFIG_DIR="${GITADMIN_CONFIG_DIR:-$HOME/.config/myscripts/gitadmin}"
GITADMIN_CONFIG_BACKUP_DIR="${GITADMIN_CONFIG_BACKUP_DIR:-$HOME/.local/share/myscripts/gitadmin/backups}"
GITADMIN_LOG_DIR="${GITADMIN_LOG_DIR:-$HOME/.local/log/gitadmin}"
GITADMIN_TEMP_DIR="${GITADMIN_TEMP_DIR:-$HOME/.local/tmp/system_scripts/gitadmin}"
GITADMIN_CACHE_DIR="${GITADMIN_CACHE_DIR:-$HOME/.cache/gitadmin}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
GITADMIN_OUTPUT_COLOR_1="${GITADMIN_OUTPUT_COLOR_1:-33}"
GITADMIN_OUTPUT_COLOR_2="${GITADMIN_OUTPUT_COLOR_2:-5}"
GITADMIN_OUTPUT_COLOR_GOOD="${GITADMIN_OUTPUT_COLOR_GOOD:-2}"
GITADMIN_OUTPUT_COLOR_ERROR="${GITADMIN_OUTPUT_COLOR_ERROR:-1}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
GITADMIN_NOTIFY_ENABLED="${GITADMIN_NOTIFY_ENABLED:-yes}"
GITADMIN_GOOD_NAME="${GITADMIN_GOOD_NAME:-Great:}"
GITADMIN_ERROR_NAME="${GITADMIN_ERROR_NAME:-Error:}"
GITADMIN_GOOD_MESSAGE="${GITADMIN_GOOD_MESSAGE:-No errors reported}"
GITADMIN_ERROR_MESSAGE="${GITADMIN_ERROR_MESSAGE:-Errors were reported}"
GITADMIN_NOTIFY_CLIENT_NAME="${GITADMIN_NOTIFY_CLIENT_NAME:-$APPNAME}"
GITADMIN_NOTIFY_CLIENT_ICON="${GITADMIN_NOTIFY_CLIENT_ICON:-notification-new}"
GITADMIN_NOTIFY_CLIENT_URGENCY="${GITADMIN_NOTIFY_CLIENT_URGENCY:-normal}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional Variables
GITADMIN_DEFAULT_USERNAME="${GITADMIN_DEFAULT_USERNAME:-$GITHUB_USERNAME}"
GITADMIN_DEFAULT_BRANCH="${GITADMIN_DEFAULT_BRANCH:-main}"
GITADMIN_DEFAULT_REPO_BASE="${REPO_URL:-https://github.com}"
GITADMIN_DEFAULT_README="${GITADMIN_DEFAULT_README:-default}"
GITADMIN_DEFAULT_LICENSE="${MY_LICENSE_FILE:-$CASJAYSDEVDIR/templates/wtfpl.md}"
GITADMIN_DEFAULT_PROJECT_DIR="${GITADMIN_DEFAULT_PROJECT_DIR:-$HOME/Projects}"
GITADMIN_DEFAULT_GIT_DIR_GITHUB="${GITADMIN_DEFAULT_GIT_DIR_GITHUB:-$GITADMIN_DEFAULT_PROJECT_DIR/github}"
GITADMIN_DEFAULT_GIT_DIR_GITLAB="${GITADMIN_DEFAULT_GIT_DIR_GITLAB:-$GITADMIN_DEFAULT_PROJECT_DIR/gitlab}"
GITADMIN_DEFAULT_GIT_DIR_PRIVATE="${GITADMIN_DEFAULT_GIT_DIR_PRIVATE:-$GITADMIN_DEFAULT_PROJECT_DIR/Private}"
GITADMIN_DEFAULT_USER_DOMAIN="${GITADMIN_DEFAULT_USER_DOMAIN:-}"
GITADMIN_PERSONAL_GIT_HOST="${GITADMIN_PERSONAL_GIT_HOST:-$GIT_PRIVATE_URL}"
GITADMIN_GITHUB_AUTH_TOKEN="${GITADMIN_GITHUB_AUTH_TOKEN:-$GITHUB_ACCESS_TOKEN}"
GITADMIN_DEFAULT_VERSION_FILE="${GITADMIN_DEFAULT_VERSION_FILE:-version.txt}"
GITADMIN_DEFAULT_VERSION_FORMAT="${VERSION_DATE_FORMAT:-%Y%m%d%H%M-git}"
GITADMIN_GITLAB_AUTH_TOKEN="${GITADMIN_GITLAB_AUTH_TOKEN:-$GITLAB_ACCESS_TOKEN}"
GITADMIN_PRIVATE_AUTH_TOKEN="${GITADMIN_PRIVATE_AUTH_TOKEN:-$GIT_PRIVATE_ACCESS_TOKEN}"
GITADMIN_DOMAIN_TEMPLATE="${GITADMIN_DOMAIN_TEMPLATE:-https://github.com/casjay-templates/domain-template}"
GITADMIN_REPO_TYPE="${GITADMIN_REPO_TYPE:-owner}"
GITADMIN_GITHUB_API_VERSION="${GITADMIN_GITHUB_API_VERSION:-2022-11-28}"
GITADMIN_LFS_FILE_TYPES="${GITADMIN_LFS_FILE_TYPES:-*.tar *.gz *.bzip2 *.zip *.rpm *.xz *.7zip *.7z}"
GITADMIN_BACKUP_ORG="${GITADMIN_BACKUP_ORG:-}"
GITADMIN_BACKUP_URL="${GITADMIN_BACKUP_URL:-https://github.com}"
GITADMIN_BACKUP_DIR="${GITADMIN_BACKUP_DIR:-$GITADMIN_CONFIG_DIR/repos}"
GITADMIN_PRIVATE_GIST_SERVER="${GITADMIN_PRIVATE_GIST_SERVER:-https://gist.casjay.work}"
GITADMIN_PRIVATE_GIST_DIR="${GITADMIN_PRIVATE_GIST_DIR:-$GITADMIN_DEFAULT_PROJECT_DIR/gists/${GITADMIN_PRIVATE_GIST_SERVER//*\/\//}}"
GITADMIN_MAIN_CONF_NAME="${GITADMIN_MAIN_CONF_NAME:-gitmainconfig}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Generate config files
[ -f "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE" ] || [ "$*" = "--config" ] || INIT_CONFIG="${INIT_CONFIG:-TRUE}" __gen_config ${SETARGS:-$@}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Import config
[ -f "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE" ] && . "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Ensure Directories exist
[ -d "$GITADMIN_LOG_DIR" ] || mkdir -p "$GITADMIN_LOG_DIR" |& __devnull
[ -d "$GITADMIN_TEMP_DIR" ] || mkdir -p "$GITADMIN_TEMP_DIR" |& __devnull
[ -d "$GITADMIN_CACHE_DIR" ] || mkdir -p "$GITADMIN_CACHE_DIR" |& __devnull
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
GITADMIN_TEMP_FILE="${GITADMIN_TEMP_FILE:-$(mktemp $GITADMIN_TEMP_DIR/XXXXXX 2>/dev/null)}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup trap to remove temp file
trap '__trap_exit' EXIT
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup notification function
__notifications() {
  __cmd_exists notifications || return
  [ "$GITADMIN_NOTIFY_ENABLED" = "yes" ] || return
  [ "$SEND_NOTIFICATION" = "no" ] && return
  (
    export SCRIPT_OPTS="" _DEBUG=""
    export NOTIFY_GOOD_MESSAGE="${NOTIFY_GOOD_MESSAGE:-$GITADMIN_GOOD_MESSAGE}"
    export NOTIFY_ERROR_MESSAGE="${NOTIFY_ERROR_MESSAGE:-$GITADMIN_ERROR_MESSAGE}"
    export NOTIFY_CLIENT_ICON="${NOTIFY_CLIENT_ICON:-$GITADMIN_NOTIFY_CLIENT_ICON}"
    export NOTIFY_CLIENT_NAME="${NOTIFY_CLIENT_NAME:-$GITADMIN_NOTIFY_CLIENT_NAME}"
    export NOTIFY_CLIENT_URGENCY="${NOTIFY_CLIENT_URGENCY:-$GITADMIN_NOTIFY_CLIENT_URGENCY}"
    notifications "$@"
  ) |& __devnull &
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set custom actions
GITADMIN_DEFAULT_USERNAME="${GITADMIN_DEFAULT_USERNAME:-$GITHUB_USERNAME}"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Argument/Option settings
SETARGS=("$@")
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
SHORTOPTS="u:,o:,s:"
SHORTOPTS+=""
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
LONGOPTS="completions:,config,debug,dir:,help,options,raw,version,silent"
LONGOPTS+=",user:,org:,single:,nolicense,noreadme,automated,cd,desc:,site:,delete,nopush,message:,type:,all,visible:"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
ARRAY="project is shorten web latest newsite stow s status l log init setup reset lfs diff branch commit update create "
ARRAY+="delete push pull clone merge rebase switch squash remote list gist single user orgs github gitlab private issues cron "
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
LIST=""
LIST+=""
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup application options
setopts=$(getopt -o "$SHORTOPTS" --long "$LONGOPTS" -n "$APPNAME" -- "$@" 2>/dev/null)
eval set -- "${setopts[@]}" 2>/dev/null
while :; do
  case "$1" in
  --raw)
    shift 1
    export SHOW_RAW="true"
    NC=""
    RESET=""
    BLACK=""
    RED=""
    GREEN=""
    YELLOW=""
    BLUE=""
    PURPLE=""
    CYAN=""
    WHITE=""
    ORANGE=""
    LIGHTRED=""
    BG_GREEN=""
    BG_RED=""
    ICON_INFO="[ info ]"
    ICON_GOOD="[ ok ]"
    ICON_WARN="[ warn ]"
    ICON_ERROR="[ error ]"
    ICON_QUESTION="[ ? ]"
    printf_column() { tee | grep '^'; }
    printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
    ;;
  --debug)
    shift 1
    set -xo pipefail
    export SCRIPT_OPTS="--debug"
    export _DEBUG="on"
    __devnull() { tee || return 1; }
    __devnull2() { eval "$@" |& tee -p || return 1; }
    ;;
  --completions)
    if [ "$2" = "short" ]; then
      printf '%s\n' "-$SHORTOPTS" | sed 's|"||g;s|:||g;s|,|,-|g' | tr ',' '\n'
    elif [ "$2" = "long" ]; then
      printf '%s\n' "--$LONGOPTS" | sed 's|"||g;s|:||g;s|,|,--|g' | tr ',' '\n'
    elif [ "$2" = "array" ]; then
      printf '%s\n' "$ARRAY" | sed 's|"||g;s|:||g' | tr ',' '\n'
    elif [ "$2" = "list" ]; then
      printf '%s\n' "$LIST" | sed 's|"||g;s|:||g' | tr ',' '\n'
    else
      exit 1
    fi
    shift 2
    exit $?
    ;;
  --options)
    shift 1
    printf_blue "Current options for ${PROG:-$APPNAME}"
    [ -z "$SHORTOPTS" ] || __list_options "Short Options" "-${SHORTOPTS}" ',' '-' 4
    [ -z "$LONGOPTS" ] || __list_options "Long Options" "--${LONGOPTS}" ',' '--' 4
    [ -z "$ARRAY" ] || __list_options "Base Options" "${ARRAY}" ',' '' 4
    [ -z "$LIST" ] || __list_options "LIST Options" "${LIST}" ',' '' 4
    exit $?
    ;;
  --version)
    shift 1
    __version
    exit $?
    ;;
  --help)
    shift 1
    __help
    exit $?
    ;;
  --config)
    shift 1
    __gen_config
    exit $?
    ;;
  --silent)
    shift 1
    GITADMIN_SILENT="true"
    ;;
  --dir)
    CWD_IS_SET="TRUE"
    GITADMIN_CWD="$2"
    [ -d "$GITADMIN_CWD" ] || mkdir -p "$GITADMIN_CWD" |& __devnull
    shift 2
    ;;
  --all)
    shift 1
    GITADMIN_RUN_ALL="true"
    ;;
  -s | --single)
    shift 1
    [ "$2" == "help" ] && printf_help "Usage: $APPNAME --single | clone a single repo"
    ghsinglerepo "$@"
    exit $?
    ;;
  -u | --user)
    [ "$2" == "help" ] && printf_help "Usage: $APPNAME --user | List user repos"
    __api_user "${2:-$GITADMIN_DEFAULT_USERNAME}" | __jq -r '.[] | .name' 2>/dev/null | printf_column '4'
    shift 2
    exit $?
    ;;
  -o | --org)
    [ "$2" == "help" ] && printf_help "Usage: $APPNAME --org | List organization repos"
    __api_org "${2:-$GITADMIN_DEFAULT_USERNAME}" | __jq -r '.[] | .name' 2>/dev/null | printf_column '4'
    shift 2
    exit $?
    ;;
  --nolicense)
    shift 1
    NOLICENSE="yes"
    ;;
  --noreadme)
    shift 1
    NOREADME="yes"
    ;;
  --automated)
    shift 1
    AUTOMATED="true"
    ;;
  --cd)
    shift 1
    GITADMIN_AUTO_CD="true"
    ;;
  --visible)
    GITADMIN_REPO_VISIBLE="$2"
    shift 2
    ;;
  --desc)
    DESCR="$2"
    shift 2
    ;;
  --site)
    SITE="$2"
    shift 2
    ;;
  --delete)
    shift 1
    GITADMIN_MIGRATE_DELETE="true"
    ;;
  --nopush)
    shift 1
    GITADMIN_SETUP_PUSH="no"
    ;;
  --message)
    GITADMIN_SETUP_MESSAGE="$2"
    shift 2
    ;;
  --type)
    GITADMIN_REPO_TYPE="$2"
    shift 2
    ;;
  --)
    shift 1
    break
    ;;
  esac
done
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Get directory from args
# set -- "$@"
# for arg in "$@"; do
# if [ -d "$arg" ]; then
# GITADMIN_CWD="$arg" && shift 1 && SET_NEW_ARGS=("$@") && break
# elif [ -f "$arg" ]; then
# GITADMIN_CWD="$(dirname "$arg" 2>/dev/null)" && shift 1 && SET_NEW_ARGS=("$@") && break
# else
# SET_NEW_ARGS+=("$arg")
# fi
# done
# set -- "${SET_NEW_ARGS[@]}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set directory to first argument
[ -d "$1" ] && __is_an_option "$1" && GITADMIN_CWD="$1" && shift 1 || GITADMIN_CWD="${GITADMIN_CWD:-$PWD}"
GITADMIN_CWD="$(realpath "${GITADMIN_CWD:-$PWD}" 2>/dev/null)"
# if [ -d "$GITADMIN_CWD" ] && cd "$GITADMIN_CWD"; then
# if [ "$GITADMIN_SILENT" != "true" ] && [ "$CWD_SILENCE" != "true" ]; then
# printf_cyan "Setting working dir to $GITADMIN_CWD"
# fi
# else
# printf_exit "💔 $GITADMIN_CWD does not exist 💔"
# fi
export GITADMIN_CWD
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set actions based on variables

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for required applications/Network check
#requiresudo "$0" "$@" || exit 2     # exit 2 if errors
#cmd_exists --error --ask bash || exit 3 # exit 3 if not found
#am_i_online --error || exit 4           # exit 4 if no internet
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# APP Variables overrides
PREVREPO=""
echo "$GITADMIN_PERSONAL_GIT_HOST" | grep -q '://' || GITADMIN_PERSONAL_GIT_HOST="https://$GITADMIN_PERSONAL_GIT_HOST"
[ -d "$GITADMIN_CWD/.git" ] && GITADMIN_CWD="$(__git_top_dir "$GITADMIN_CWD" 2>/dev/null)"
[ -f "$GITADMIN_CWD/$GITADMIN_DEFAULT_VERSION_FILE" ] && GITADMIN_DEFAULT_VERSION_FILE="$GITADMIN_CWD/$GITADMIN_DEFAULT_VERSION_FILE"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions based on env
[ -n "$GITADMIN_DEFAULT_USERNAME" ] || printf_yellow "Please set GITADMIN_DEFAULT_USERNAME or GITHUB_USERNAME variable in settings" >&2
[ -n "$GITADMIN_GITHUB_AUTH_TOKEN" ] || [ -n "$GITADMIN_GITHUB_AUTH_MESSAGE_SHOWN" ] || printf_exit "Please set GITADMIN_GITHUB_AUTH_TOKEN or GITHUB_ACCESS_TOKEN variable in settings" >&2
export GITADMIN_GITHUB_AUTH_MESSAGE_SHOWN="true"
if [ "$(git config --get user.name | wc -m)" -lt 2 ]; then
  printf_read_input "What is you Name" "120" "GIT_NAME"
  git config --global user.name "$GIT_NAME" 2>/dev/null
  unset GIT_NAME
fi
if [ "$(git config --get user.email | wc -m)" -lt 2 ]; then
  printf_read_input "What is you Email" "120" "GIT_EMAIL"
  git config --global user.email "$GIT_EMAIL" 2>/dev/null
  unset GIT_EMAIL
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute functions

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute commands

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# begin main app
case "$1" in
#
project)
  shift 1
  if [ "$1" = "" ] || [ $# -eq 0 ]; then
    dirs="$(find "$GITADMIN_DEFAULT_PROJECT_DIR"/*/* -maxdepth 1 -type d -not -path '*/.git*' 2>/dev/null | grep -Ev '.*/.Trash-*|.*/local/*')"
    [ -n "$dirs" ] && printf '%s\n' "${dirs//$GITADMIN_DEFAULT_PROJECT_DIR\//}" | printf_readline
    exit
  fi
  if [ -d "$GITADMIN_DEFAULT_PROJECT_DIR/$1" ]; then
    printf_cyan "Setting working directory to $GITADMIN_DEFAULT_PROJECT_DIR/$1"
    cd "$GITADMIN_DEFAULT_PROJECT_DIR/$1" && $SHELL
  elif [ -d "$1" ]; then
    printf_cyan "Setting working directory to $1"
    cd "$1" && $SHELL
  else
    printf_exit "$1 is not a valid directory"
  fi
  ;;
  # repo status is? clean,dirty
is)
  shift 1
  case "$1" in
  # returns 1 if repo changed
  clean)
    shift 1
    __is_clean "${1:-$GITADMIN_CWD}"
    exit $?
    ;;
  # returns 0 if repo changed
  dirty)
    shift 1
    __is_dirty "${1:-$GITADMIN_CWD}"
    exit $?
    ;;
  # same as clean
  *)
    __is_clean "${1:-$GITADMIN_CWD}"
    exit $?
    ;;
  esac
  ;;

# show git info
show)
  shift 1
  case $1 in
  dir | root)
    git -C "$GITADMIN_CWD" rev-parse --show-toplevel 2>/dev/null
    exit $?
    ;;
  url | remote)
    shift 1
    git -C "$GITADMIN_CWD" remote show origin | grep 'Push' | awk -F 'URL: ' '{print $2}' 2>/dev/null
    exit $?
    ;;
  *) exit 1 ;;
  esac
  ;;

# github url shortner
shorten)
  shift 1
  { [ "$1" = "help" ] || [ -z "$1" ]; } && printf_help "Usage: gitadmin shorten [url] [name]"
  git_io "$@"
  ;;

web)
  shift 1
  REMOTE_REPO="$(__git_remote_push "$GITADMIN_CWD")"
  if [ -n "$REMOTE_REPO" ]; then mybrowser "$REMOTE_REPO"; else printf_return "ERROR: Can not get remote "; fi
  exit $?
  ;;

# get the latest release
latest)
  shift 1
  { [ "$1" = "help" ] || [ -z "$1" ]; } && printf_help "Usage: gitadmin latest [userName] [repoName] [arch]"
  printf_red "This has been moved to install-latest"
  install-latest install "$@"
  ;;
  # create a new site
newsite)
  shift 1
  { [ "$1" = "help" ] || [ -z "$1" ]; } && printf_help "Usage: gitadmin newsite [sitename] [template:default]"
  make_newsite "$@"
  ;;

  # backup dotfiles
stow)
  shift 1
  { [ "$1" = "help" ] || [ -z "$1" ]; } && printf_help "Usage: gitadmin stow [files]"
  config "$@"
  ;;

# repo status
s | status)
  shift 1
  [ "$1" = "help" ] && printf_help "Usage: gitadmin status"
  [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
  [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD doesn't seem to be a git repo"
  __git_status "$GITADMIN_CWD"
  exit $?
  ;;

# git log
l | log)
  shift 1
  [ "$1" = "help" ] && printf_help "Usage: gitadmin log"
  [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
  [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD doesn't seem to be a git repo"
  __test_if_number $1 && count=$1 && shift 1
  __git_log "$GITADMIN_CWD" $count
  exit $?
  ;;

# initialize repo
init)
  shift 1
  [ "$1" = "help" ] && printf_help "Usage: gitadmin init"
  [ -d "$1" ] && GITADMIN_CWD="$1" && shift 1
  git_init "$@"
  ;;

# initialize repo
setup)
  shift 1
  [ "$1" = "help" ] && printf_help "Usage: gitadmin setup [--automated]"
  [ -d "$1" ] && GITADMIN_CWD="$1" && shift 1
  if [ "$AUTOMATED" = "true" ]; then
    run_git_setup_automated "$@"
  else
    run_git_setup "$@"
  fi
  ;;

# Reset the repo
reset)
  shift 1
  [ "$1" = "yes" ] && reset_repo=y && shift 1
  set_number="$1"
  [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD is not valid repo"
  { __test_if_number $set_number || [ "$set_number" != "help" ] || [ $# -ne 0 ]; } || printf_help "Usage: $APPNAME reset 2"
  [ "$reset_repo" = "y" ] || printf_read_question "3" "Are you sure you want to reset? " "1" "reset_repo"
  [ "$set_number" = "1" ] && set_number=2
  current_id="$(__git_log "$GITADMIN_CWD" | head -n1 | awk '{print $1}')"
  if printf_answer_yes "$reset_repo"; then
    #if git -C "$GITADMIN_CWD" log | grep -wF "$set_number"; then
    #  go_back="$set_number"
    #else
    go_back="$(__git_log "$GITADMIN_CWD" | head -n$set_number | tail -n1 | awk '{print $1}')"
    #fi
    if [ -n "$go_back" ]; then
      [ "$go_back" = "$current_id" ] && printf_exit "You seem to be at the first commit: $current_id"
      printf_purple "reverting back to commit $go_back from $current_id"
      git -C "$GITADMIN_CWD" reset --hard $go_back | printf_readline
      exit $?
    else
      printf_exit "Can not determine the git id"
    fi
  else
    printf_exit 1 1 "Guess you decided against the reset"
  fi
  ;;

# lfs
lfs)
  shift 1
  exitCode=0
  [ "$1" = "help" ] && printf_help "gitadmin lfs [fetch,checkout,add]"
  [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD is not a git repo"
  git lfs --help 2>&1 | grep -vq 'is not a git command' || pkmgr silent install git-lfs || printf_exit "git lfs is not installed"
  [ -f "$GITADMIN_CONFIG_DIR/lfs_init" ] || { git lfs install &>/dev/null && touch "$GITADMIN_CONFIG_DIR/lfs_init"; }
  case "$1" in
  init)
    shift 1
    if [ ! -f "$GITADMIN_CWD/.gitattributes" ]; then
      if [ ! -f "$GITADMIN_CWD/.gitignore" ]; then
        printf_cyan "Creating .gitignore in $GITADMIN_CWD"
        gitignore $d default &>/dev/null
      fi
      if [ ! -f "$GITADMIN_CWD/.gitattributes" ]; then
        printf_cyan "Creating .gitattributes in $GITADMIN_CWD"
        gen-gitattr $d save default lfs &>/dev/null
      fi
      for repo_file in $GITADMIN_LFS_FILE_TYPES; do
        printf_cyan "Adding $repo_file to LFS"
        git -C "$GITADMIN_CWD" lfs track "$repo_file" &>/dev/null
        git -C "$GITADMIN_CWD" commit -m "🔵 Added LFS object: $repo_file 🔵" --quiet
      done
      git -C "$GITADMIN_CWD" add .gitattributes &>/dev/null && git -C "$GITADMIN_CWD" commit -m "🔵 Added .gitattributes 🔵" --quiet
      exitCode=$?
      [ $exitCode -eq 0 ] && { [ "$GITADMIN_SETUP_PUSH" != "no" ] && git -C "$GITADMIN_CWD" push --quiet && exitCode=0 || exitCode=1; }
    fi
    [ "$exitCode" -eq 0 ] && printf_cyan "$GITADMIN_CWD has been initialized for LFS support" || printf_red "Failed to setup $GITADMIN_CWD for LFS support"
    exit $exitCode
    ;;
  fetch)
    shift 1
    git -C "$GITADMIN_CWD" fetch --all && exitCode=0 || exitCode=1
    printf '\n'
    exit $exitCode
    ;;
  checkout)
    shift 1
    git -C "$GITADMIN_CWD" lfs checkout && exitCode=0 || exitCode=1
    printf '\n'
    exit $exitCode
    ;;
  add)
    shift 1
    exitCode=0
    add_files="${*:-$GITADMIN_LFS_FILE_TYPES}"
    touch "$GITADMIN_CWD/.gitattributes"
    for file in $add_files; do
      repo_file="${file//$GITADMIN_CWD\//}"
      printf_cyan "Adding $repo_file to LFS"
      git -C "$GITADMIN_CWD" lfs track "$repo_file" &>/dev/null
      git -C "$GITADMIN_CWD" commit -m "🔵 Added LFS object: $repo_file 🔵" --quiet
      git -C "$GITADMIN_CWD" lfs migrate import --no-rewrite --yes --include="$repo_file"
    done
    if [ "$GITADMIN_SETUP_PUSH" != "no" ]; then
      git -C "$GITADMIN_CWD" push && exitCode=0 || exitCode=1
    fi
    printf '\n'
    exit $exitCode
    ;;
  pull | clone)
    printf_green "Running git lfs fetch in $GITADMIN_CWD"
    git -C "$GITADMIN_CWD" fetch --all && git -C "$GITADMIN_CWD" lfs checkout && exitCode=0 || exitCode=1
    exit $exitCode
    ;;
  *)
    printf_green "Running git lfs fetch in $GITADMIN_CWD"
    git -C "$GITADMIN_CWD" fetch --all && git -C "$GITADMIN_CWD" lfs checkout && exitCode=0 || exitCode=1
    exit $exitCode
    ;;
  esac
  exit $?
  ;;

diff)
  shift 1
  __test_if_number $1 && count=$1 || count=6
  git -C "$GITADMIN_CWD" diff HEAD^ HEAD -- file | grep '@@' -B10 | head -n$count
  exit $?
  ;;

# branch options
branch)
  shift 1
  case $1 in
  rename)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin rename branch newname userName repoName"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD doesn't seem to be a git repo"
    __rename_branch "${1:-main}" $2 $3
    exit $?
    ;;
  *)
    { [ $# = 0 ] || [ "$1" = "help" ] && printf_exit 1 2 "Usage: $APPNAME branch fromBranch toBranch - $APPNAME branch rename master main"; }
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    fromBranch="${1:-master}"
    toBranch="${2:-main}"
    git -C "$GITADMIN_CWD" branch -m $fromBranch $toBranch
    git -C "$GITADMIN_CWD" fetch origin
    git -C "$GITADMIN_CWD" branch -u origin/$fromBranch $toBranch
    git -C "$GITADMIN_CWD" remote set-head origin -a
    git -C "$GITADMIN_CWD" push --set-upstream origin $toBranch
    git -C "$GITADMIN_CWD" branch -d $fromBranch
    exit $?
    ;;
  esac
  ;;

backup)
  shift 1
  __backup_repos "$@"
  exit $?
  ;;

# commit changes
commit)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin commit [message]"
  [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
  gitcommit --dir "$GITADMIN_CWD" "${@:-all}"
  ;;

# update local repos
update)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin update [--while]"
  git_update_loop "$@"
  ;;

# create github repo
create)
  shift 1
  { [ $# -lt 1 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin create userName repoName Description"
  ghcreate "$@"
  exit $?
  ;;

# delete github repo
delete)
  shift 1
  [ $# -lt 1 ] && echo $#
  { [ $# -lt 1 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin delete userName repoName"
  ghdelete "$@"
  exit $?
  ;;

  # push a repo
push)
  shift 1
  [ "$1" = "help" ] && printf_help "Usage: gitadmin push [MyProjectDir,all]"
  if [ "$1" = "all" ] || [ "$GITADMIN_RUN_ALL" = "true" ]; then
    repo_dirs="$(ls -d "$GITADMIN_DEFAULT_PROJECT_DIR"/*/*/* 2>/dev/null | grep -v "$GITADMIN_DEFAULT_PROJECT_DIR/local/**" | grep '^' || false)"
    #repo_dirs="$(find "$GITADMIN_DEFAULT_PROJECT_DIR"/*/"$GITADMIN_DEFAULT_USERNAME"/* -maxdepth 0 -type d | grep '^' || echo '')"
    [ -n "$repo_dirs" ] || printf_exit "Could not find any directories for $GITADMIN_DEFAULT_USERNAME in $GITADMIN_DEFAULT_PROJECT_DIR"
    for dir in $repo_dirs; do
      [ -d "$dir/.git" ] && git_push_single "$dir"
    done
  else
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    git_push_single "${@:-$GITADMIN_CWD}"
  fi
  ;;

  # update repo
pull)
  shift 1
  [ "$1" = "help" ] && printf_help "Usage: gitadmin pull [MyProjectDir]"
  GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
  if [ "$1" = "all" ] || [ "$GITADMIN_RUN_ALL" = "true" ]; then
    repo_dirs="$(ls -d "$GITADMIN_DEFAULT_PROJECT_DIR"/*/*/* 2>/dev/null | grep -v "$GITADMIN_DEFAULT_PROJECT_DIR/local/**" | grep '^' || false)"
    #repo_dirs="$(find "$GITADMIN_DEFAULT_PROJECT_DIR"/*/"$GITADMIN_DEFAULT_USERNAME"/* -maxdepth 0 -type d | grep '^' || echo '')"
    [ -n "$repo_dirs" ] || printf_exit "Could not find any directories for $GITADMIN_DEFAULT_USERNAME in $GITADMIN_DEFAULT_PROJECT_DIR"
    for dir in $repo_dirs; do
      [ -d "$dir/.git" ] && git_pull_single "$dir"
    done
  else
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    git_pull_single "${@:-$GITADMIN_CWD}"
  fi

  ;;

# Clone repo from url
clone)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin clone MyURL"
  REPO_URL="$(__strip_git_url "$1")" && shift 1
  __if_is_url "$REPO_URL" || REPO_URL="https://github.com/$REPO_URL"
  __create_dirs "${1:-}"
  git_clone_single "$REPO_URL" "${1:-}"
  ;;

  # merge options
merge)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin merge [toBranch] [fromBranch]"
  [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
  git -C "$GITADMIN_CWD" switch $1
  git -C "$GITADMIN_CWD" merge $2
  ;;

  # rebase options
rebase)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin rebase [fromBranch] [toBranch]"
  [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
  git -C "$GITADMIN_CWD" switch $1
  git -C "$GITADMIN_CWD" rebase $2
  ;;

# switch between branches
switch)
  shift 1
  case $1 in
  create)
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin switch create [branchName]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" switch -c $1
    exit $?
    ;;

  *)
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin switch [branchName]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" switch $1
    exit $?
    ;;
  esac
  ;;

# squash options
squash)
  shift 1
  case $1 in
  head)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin squash head [number]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" rebase -i HEAD~$1
    exit $?
    ;;
  merge)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin squash merge [hash]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" merge --squash $1
    exit $?
    ;;
  rebase)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin squash rebase [hash]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" rebase -i $1
    exit $?
    ;;
  *)
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin squash [hash]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" rebase -i $1
    exit $?
    ;;
  esac
  ;;

# Remote options
remote)
  shift 1
  [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
  case "$1" in
  show)
    shift 1
    [ "$1" = "help" ] && printf_help "Usage: gitadmin remote show [name]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" remote show "${1:-origin}"
    exit $?
    ;;
  add)
    shift 1
    [ "$1" = "help" ] && printf_help "Usage: gitadmin remote add [remoteURL] [name]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    REPO_URL="$(__strip_git_url "$1")"
    printf_cyan "Adding remote: $REPO_URL"
    git -C "$GITADMIN_CWD" remote add ${2:-origin} "$REPO_URL" &>/dev/null &&
      git push --set-upstream origin main -q
    exit $?
    ;;
  *)
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    [ "$1" = "help" ] && printf_help "Usage: gitadmin remote [show,add]"
    git -C "$GITADMIN_CWD" remote show ${1:-origin}
    exit $?
    ;;
  esac
  ;;

# list user orgs
list)
  shift 1
  [ "$1" = "help" ] && printf_help "Usage: gitadmin list [user]"
  if [ "$1" = "raw" ]; then
    shift 1
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    [ -n "$GITADMIN_DEFAULT_USERNAME" ] || printf_help "Usage: $APPNAME list [raw] github_user"
    git_retrieve_orgs "$GITADMIN_DEFAULT_USERNAME"
    echo "$GIT_ALL_REPOS" | tr ' ' '\n'
  else
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    [ -n "$GITADMIN_DEFAULT_USERNAME" ] || printf_help "Usage: $APPNAME list [raw] github_user"
    git_retrieve_orgs "$GITADMIN_DEFAULT_USERNAME"
    printf_green "I have found the following organizations"
    echo "$GIT_ALL_REPOS" | tr ' ' '\n' | printf_column "5"
    printf_newline
  fi
  ;;

# gist options
gist)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin gist [clone,create,delete,edit,list,search]"
  case "$1" in
  clone)
    shift 1
    [ $# -lt 1 ] && printf_help "Usage: gitadmin gist clone id [directory]"
    SET_REPO="$(curl -q -LSsfI "https://gist.github.com/$1" | grep 'location: https://' | head -n1 | awk -F': ' '{print $2}' | grep "$1" || echo '')"
    REPO_URL="$(__strip_git_url "$SET_REPO")"
    GIST_USER="$(basename -- "$(dirname "$SET_REPO")" | grep '^')"
    GISTNAME="$(basename -- "$REPO_URL")"
    GISTDIR="${2:-$GITADMIN_DEFAULT_PROJECT_DIR/gists/$GIST_USER/$GISTNAME}"
    printf_cyan "Cloning $REPO_URL > $GISTDIR"
    __git_clone "$REPO_URL" "$GISTDIR"
    exit $?
    ;;

  create)
    shift 1
    [ "$1" = "help" ] && printf_help "Usage: gitadmin gist create 'description' 'filename' [text/file]"
    if [ $# -eq 3 ]; then
      descript="$1" && shift 1
      filename="$1" && shift 1
      contents="$1" && shift 1
    elif [ $# -eq 2 ]; then
      filename="$1" && shift 1
      descript="$1" && shift 1
    elif [ $# -eq 1 ]; then
      filename="$1" && shift 1
    fi
    [ -f "$filename" ] && contents="$filename" || contents="${contents:-$filename}"
    [ $# -ne 0 ] && contents="${contents:-$(cat -)}"
    if [ $# -eq 0 ] && [ -p "/dev/stdin" ]; then
      cat - >"$GITADMIN_TEMP_FILE" 2>/dev/null
      descript="${descript:-$(grep -sh ' @@Description' "$GITADMIN_TEMP_FILE" | awk -F ':  ' '{print $2}' | sed 's|^  ||g' | head -n1 | grep '^' || echo 'new gist')}"
    elif [ -f "$contents" ]; then
      descript="${descript:-$(basename -- "$contents")}"
      cat "$contents" >"$GITADMIN_TEMP_FILE"
      filename="$contents"
    elif [ -n "$contents" ]; then
      descript="${descript:-}"
      printf '%s\n' "$contents" >"$GITADMIN_TEMP_FILE"
    else
      printf '' >"$GITADMIN_TEMP_FILE"
    fi
    descript="${DESCR:-${descript:-New Gist}}"
    filename="${filename:-$(basename -- "${filename:-gistfile1.txt}")}"
    [ -s "$GITADMIN_TEMP_FILE" ] && contents="$(<"$GITADMIN_TEMP_FILE")"
    [ -n "$contents" ] || printf_exit "Usage: gitadmin gist create 'description' 'filename' [text/file]"
    ghgist_create "$descript" "$filename" "$contents"
    exit $?
    ;;

  delete)
    shift 1
    { [ $# -lt 1 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin gist delete [GIT_URL or GIST_ID]"
    ghgist_delete "$@"
    exit $?
    ;;

  edit)
    shift 1
    { [ $# -lt 3 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin gist edit GIST_ID description filename text"
    ghgist_edit "$@"
    exit $?
    ;;

  list)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin gist list GIST_USER"
    ghgist_list "$@"
    exit $?
    ;;

  search)
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin gist search GIST_USER SearchTerm"
    search_list "$@"
    exit $?
    ;;
  esac
  ;;

  # Single repo options
single)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __help
  case $1 in
  # init a github repo
  init)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin single init RepoName"
    do_not_add_a_url "${1:-$GITADMIN_CWD}"
    if echo "${1:-$GITADMIN_CWD}" | grep -q '\.git$'; then
      homerepo="$(echo "${1:-$GITADMIN_CWD}" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(__strip_git_url "${1:-$GITADMIN_CWD}")"
    fi
    __mkd "$homerepo" && [ ! -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to initialize $homerepo"
    repos_init "$homerepo"
    exit "$?"
    ;;

    # push a repo
  push)
    shift 1
    [ "$1" = "help" ] && printf_help "Usage: $APPNAME push >$GISTDIR"
    __git_clone "$REPO_URL" "$GISTDIR"
    exit $?
    ;;

    # update repo
  pull)
    shift 1
    [ "$1" = "help" ] && printf_help "Usage: $APPNAME update | pull the repos"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git_pull_single "${@:-$GITADMIN_CWD}"
    ;;

    # Clone repo from url
  clone)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: $APPNAME clone [URL] [directory] | clone the repos"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    [ $# -eq 0 ] && printf_help "Usage: $APPNAME clone [URL] [directory] | clone the repos"
    REPO_URL="$(__strip_git_url "$1")"
    git_clone_single "$REPO_URL" "${2:-$GITADMIN_CWD}"
    ;;
  esac
  ;;

# User repos
user)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin user [clone,orgs] [userName]"
  case "$1" in
  orgs)
    shift 1
    [ "$1" = "help" ] && printf_help "Usage: gitadmin user orgs [userName]"
    GITADMIN_DEFAULT_USERNAME="$1"
    git_retrieve_orgs "$GITADMIN_DEFAULT_USERNAME"
    printf_newline
    printf_green "I have found the following organizations"
    echo "$GIT_ALL_REPOS" | tr ' ' '\n' | grep -v '^$' | printf_column "5"
    ;;
  clone)
    shift 1
    __github_org_clone_repos "$1"
    ;;
  *)
    __github_org_clone_repos "$1"
    ;;
  esac
  ;;

# organization options
org)
  shift 1
  [ "$1" = "help" ] && printf_help "Usage: gitadmin org [list,all,push,pull,clone] [userName]"
  case "$1" in
  repos) # Show repos owned by org
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin org repos [userName]"
    __github_org_list_repos "$1"
    ;;

  all)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin org all [userName]"
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    git_all_orgs_clone "$GITADMIN_DEFAULT_USERNAME"
    ;;

  push)
    shift 1
    [ "$1" = "help" ] && printf_help "Usage: gitadmin org push [userName]"
    [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_exit "ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set"
    __github_org_push_repos "$1"
    exit $?
    ;;

  pull)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin org pull [userName]"
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    GITADMIN_DEFAULT_REPO_BASE="$GITADMIN_DEFAULT_REPO_BASE/$GITADMIN_DEFAULT_USERNAME"
    __api_user_token "$GITADMIN_DEFAULT_USERNAME"
    __curl_gh_api "$GITHUBAPIREPO" | grep -w clone_url | awk -F / '{print $NF}' | __sed 's/\",//' | __sed 's/\.[^.]*$//' >"$GITADMIN_TEMP_FILE"
    COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
    [ -n "$COUNT" ] || printf_exit "No repos found for $GITADMIN_DEFAULT_USERNAME"
    printf_green "$MESSAGE"
    printf_blue "There's currently $COUNT repos available"
    printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
    main "$GITADMIN_DEFAULT_USERNAME"
    ;;

  clone)
    shift 1
    { [ $# -eq 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin org clone [userName]"
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    GITADMIN_DEFAULT_REPO_BASE="$GITADMIN_DEFAULT_REPO_BASE/$GITADMIN_DEFAULT_USERNAME"
    __create_dirs
    __api_org_token "$GITADMIN_DEFAULT_USERNAME" || exit 1
    __curl_gh_api $GITHUBAPIREPO | grep -w clone_url | awk -F / '{print $NF}' | __sed 's/\",//' | __sed 's/\.[^.]*$//' >"$GITADMIN_TEMP_FILE"
    COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
    [ -n "$COUNT" ] || printf_exit "No repos found for $GITADMIN_DEFAULT_USERNAME"
    printf_green "$MESSAGE"
    printf_blue "There's currently $COUNT repos available"
    printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
    main "$GITADMIN_DEFAULT_REPO_BASE"
    ;;

  *)
    [ "$1" = "all" ] && shift
    { [ -z $1 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin org [userName]"
    __create_dirs
    GIT_ALL_REPOS="$*"
    repo_base="$GITADMIN_DEFAULT_REPO_BASE"
    for org in ${GIT_ALL_REPOS//,/ }; do
      GITADMIN_DEFAULT_USERNAME="$org"
      GITADMIN_DEFAULT_REPO_BASE="$repo_base"
      git_retrieve_orgs "$org"
      __clone_orgs "$org"
    done
    ;;
  esac
  ;;

# github repo
github)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __help
  case $1 in
  # create github repo
  create)
    shift 1
    { [ $# -lt 1 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin github create userName repoName Description"
    ghcreate "$@"
    exit $?
    ;;

    # init a github repo
  init)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin github init RepoName"
    __create_dirs
    do_not_add_a_url "$1"
    if echo "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$1" | grep -q '\.git$'; then
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$1" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$1")"
    fi
    __mkd "$homerepo" && [ ! -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to initialize $homerepo"
    repos_init "$homerepo"
    exit "$?"
    ;;

    # Clone repo from github
  clone)
    shift 1
    { [ $# -lt 1 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin github clone username/projectname"
    url="$(echo "$*" | tr ' ' '/')"
    __create_dirs
    do_not_add_a_url "$url"
    remote_repo="https://github.com/$(__strip_git_url "$url")"
    if echo "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$1" | grep -q '\.git$'; then
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$url" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$url")"
    fi
    if [ -d "$homerepo/.git" ]; then
      printf_green "The repo already exists so attempting update"
      git_pull_single "$homerepo"
      retVal=$?
    else
      printf_green "Cloning the repo from $remote_repo"
      mkdir -p "$homerepo"
      git_clone_single "$remote_repo" "$homerepo"
      retVal=$?
    fi
    [ -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to clone to $homerepo"
    exit "$retVal"
    ;;

    # Push
  push)
    shift 1
    [ $# -eq 0 ] && [ -d "$PWD/.git" ] && homerepo="$PWD" || { [ -n "$1" ] && [ -d "$1/.git" ] && homerepo="$1"; } || homerepo="$(ls -d "$GITADMIN_DEFAULT_GIT_DIR_GITHUB"/*/*)"
    for d in $homerepo; do
      __mkd "$d" && [ -d "$d/.git" ] && __cd_into "$d" || printf_exit 1 1 "failed to push from: $d"
      git_push_single "$d"
    done
    ;;

    # update repo
  pull)
    shift 1
    [ "$1" = "help" ] && printf_help "Usage: $APPNAME update | pull the repos"
    [ $# -eq 0 ] && [ -d "$PWD/.git" ] && homerepo="$PWD" || { [ -n "$1" ] && [ -d "$1/.git" ] && homerepo="$1"; } || homerepo="$(ls -d "$GITADMIN_DEFAULT_GIT_DIR_GITHUB"/*/*)"
    for d in $homerepo; do
      __mkd "$d" && [ -d "$d/.git" ] && __cd_into "$d" || printf_exit 1 1 "failed to pull to: $d"
      git_pull_single "$d"
    done
    ;;

    # add github to remote
  remote)
    shift 1
    { [ $# -lt 2 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin github remote [username/projectname] [name]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    do_not_add_a_url "$1"
    git -C "$GITADMIN_CWD" remote add "${2:-orgin}" "https://github.com/$1.git"
    exit "$?"
    ;;

    # update repo info
  update)
    shift 1
    __update_github_repo "$@"
    exit $?
    ;;

  orgs)
    shift 1
    case "$1" in
    clone)
      shift 1
      exitStatus=0
      repo_base="$GITADMIN_DEFAULT_REPO_BASE"
      project_dir="$GITADMIN_DEFAULT_GIT_DIR_GITHUB"
      for org in "$@"; do
        GITADMIN_DEFAULT_REPO_BASE="$repo_base"
        GITADMIN_DEFAULT_GIT_DIR_GITHUB="$project_dir"
        __github_org_clone_repos "$org"
        exitStatus=$((exitStatus + $?))
      done
      exit $exitStatus
      ;;

    list)
      shift 1
      exitStatus=0
      repo_base="$GITADMIN_DEFAULT_REPO_BASE"
      project_dir="$GITADMIN_DEFAULT_GIT_DIR_GITHUB"
      for org in "$@"; do
        GITADMIN_DEFAULT_REPO_BASE="$repo_base"
        GITADMIN_DEFAULT_GIT_DIR_GITHUB="$project_dir"
        __github_org_list_repos "$org"
        exitStatus=$((exitStatus + $?))
      done
      exit $exitStatus
      ;;

    update)
      shift 1
      if [ "$1" = "all" ]; then
        shift 1
        ORG_REPO_NAME="${1//\/*/}" && shift 1
        __api_org_token "$ORG_REPO_NAME" | sort -u >"$GITADMIN_TEMP_FILE" || echo >"$GITADMIN_TEMP_FILE"
        COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
        if [ -n "$COUNT" ]; then
          printf_green "$MESSAGE"
          printf_blue "There's currently $COUNT repos available"
          printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
          repo_list="$(<"$GITADMIN_TEMP_FILE")"
          __github_org_options_set "$@"
          for i in $repo_list; do
            __github_org_options_repos "$ORG_REPO_NAME/$i"
          done
        else
          exitCode=1
          printf_red "😿 No repos found for $ORG_REPO_NAME/$i 😿"
        fi
      else
        ORG_REPO_NAME="$1" && shift 1
        __github_org_options_set "$@"
        __github_org_options_repos "$ORG_REPO_NAME"
      fi
      exit $?
      ;;
    *) ;;
    esac
    ;;

    # github pages
  pages)
    shift 1
    case "$1" in
    # force a build
    build)
      shift 1
      [ $# -ne 0 ] && [ "$1" != "help" ] || printf_exit 1 3 "Usage: build [username/repo]"
      status="$(curl -q -LSsf -X "POST" -H 'Accept: application/vnd.github+json' -H 'Authorization: token '$GITADMIN_GITHUB_AUTH_TOKEN'' -H 'X-GitHub-Api-Version: 2022-11-28' 'https://api.github.com/repos/'$1'/pages/builds' | __jq -rc '.url')"
      [ -n "$status" ] && printf_cyan "Build info: $status" || printf_exit 33 1 "The server returned an error: $(cat "$GITADMIN_TEMP_FILE" | grep 'error' | sed 's|.*error: ||g' | head -n1)"
      exit $?
      ;;

      # create a page
    create)
      shift 1
      [ $# -ne 0 ] && [ "$1" != "help" ] || printf_exit 1 3 "Usage: create [username/repo [domain] [dir] [type] [branch]"
      status="$(curl -q -LSsf -X "POST" -H 'Accept: application/vnd.github+json' -H 'Authorization: Bearer '$GITADMIN_GITHUB_AUTH_TOKEN'' -H 'X-GitHub-Api-Version: 2022-11-28' "https://api.github.com/repos/$1/pages" --data "{ \"cname\":\"$2\",\"build_type\":\"${4:-legacy}\",\"source\":{\"branch\":\"${5:-main}\",\"path\":\"${3:-/}\" } }" 2>"$GITADMIN_TEMP_FILE" | __jq -rc '.cname')"
      [ -n "$status" ] && printf_cyan "Created: $status" || printf_exit 33 1 "The server returned an error: $(cat "$GITADMIN_TEMP_FILE" | grep 'error' | sed 's|.*error: ||g' | head -n1)"
      exit $?
      ;;

      # update a page
    update)
      shift 1
      [ $# -ne 0 ] && [ "$1" != "help" ] || printf_exit 1 3 "Usage: update [username/repo [domain] [dir] [type] [branch]"
      status="$(curl -q -LSsf -X "PUT" -H 'Accept: application/vnd.github+json' -H 'Authorization: token '$GITADMIN_GITHUB_AUTH_TOKEN'' -H 'X-GitHub-Api-Version: 2022-11-28' 'https://api.github.com/repos/'$1'/pages' --data "{ \"cname\":\"$2\",\"build_type\":\"${4:-legacy}\",\"custom_404\":\"/404.html\",\"source\":{\"branch\":\"${5:-main}\",\"path\":\"${3:-/}\" } }" 2>"$GITADMIN_TEMP_FILE" && echo "$1" || echo '')"
      [ -n "$status" ] && printf_cyan "Updated: $status" || printf_exit 33 1 "The server returned an error: $(cat "$GITADMIN_TEMP_FILE" | grep 'error' | sed 's|.*error: ||g' | head -n1)"
      exit $?
      ;;

      # delete a page
    delete)
      shift 1
      [ $# -ne 0 ] && [ "$1" != "help" ] || printf_exit 1 3 "Usage: delete [username/repo]"
      status="$(curl -q -LSsf -X "DELETE" -H 'Accept: application/vnd.github+json' -H 'Authorization: token '$GITADMIN_GITHUB_AUTH_TOKEN'' -H 'X-GitHub-Api-Version: 2022-11-28' 'https://api.github.com/repos/'$1'/pages' 2>"$GITADMIN_TEMP_FILE" && echo "$1" || echo '')"
      [ -n "$status" ] && printf_cyan "Deleted: $status" || printf_exit 33 1 "The server returned an error: $(cat "$GITADMIN_TEMP_FILE" | grep 'error' | sed 's|.*error: ||g' | head -n1)"
      exit $?
      ;;

      # get dns info
    health)
      shift 1
      [ $# -ne 0 ] && [ "$1" != "help" ] || printf_exit 1 3 "Usage: health [username/repo]"
      status="$(curl -q -LSsf --retry-all-errors --retry 3 --retry-delay 5 -X "GET" -H 'Accept: application/vnd.github+json' -H 'Authorization: token '$GITADMIN_GITHUB_AUTH_TOKEN'' -H 'X-GitHub-Api-Version: 2022-11-28' 'https://api.github.com/repos/'$1'/pages/health' 2>"$GITADMIN_TEMP_FILE" | __jq -r '.' || echo '')"
      [ -n "$status" ] && echo "$status" | __jq -r '.' || printf_exit 33 1 "The server returned an error: $(cat "$GITADMIN_TEMP_FILE" | grep 'error' | sed 's|.*error: ||g' | head -n1)"
      exit $?
      ;;

      # get info
    *)
      [ "$1" = "info" ] && shift 1
      [ $# -ne 0 ] && [ "$1" != "help" ] || printf_exit 1 3 "Usage: [build,create,update,delete,health] [username/repo]"
      status="$(curl -q -LSsf -X "GET" -H 'Accept: application/vnd.github+json' -H 'Authorization: token '$GITADMIN_GITHUB_AUTH_TOKEN'' -H 'X-GitHub-Api-Version: 2022-11-28' 'https://api.github.com/repos/'$1'/pages' 2>"$GITADMIN_TEMP_FILE" | __jq -r '{"status":.status,"url":.cname,"url":.html_url,"build":.build_type,"https":.https_enforced,"404":.custom_404}' || echo '')"
      [ -n "$status" ] && echo "$status" | __jq -r '.' || printf_exit 33 1 "The server returned an error: $(cat "$GITADMIN_TEMP_FILE" | grep 'error' | sed 's|.*error: ||g' | head -n1)"
      exit $?
      ;;
    esac
    ;;
  esac
  ;;

# gitlab repos commands
gitlab)
  shift 1
  [ "$1" = "help" ] && __help
  [ -z "$1" ] && __help
  case $1 in
  # init a gitlab repo
  init)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin gitlab init RepoName"
    __create_dirs
    do_not_add_a_url "$1"
    if echo "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$1" | grep -q '\.git$'; then
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$1" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$1")"
    fi
    __mkd "$homerepo" && [ ! -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to initialize $homerepo"
    repos_init "$homerepo"
    exit "$?"
    ;;

    # Clone repo from gitlab
  clone)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin gitlab clone username/projectname"
    __create_dirs
    do_not_add_a_url "$1"
    remote_repo="https://gitlab.com/$(__strip_git_url "$1")"
    if echo "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$1" | grep -q '\.git$'; then
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$1" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$1")"
    fi
    if [ -d "$homerepo/.git" ]; then
      printf_green "The repo already exists so attempting update"
      __git_pull "$homerepo"
      retVal=$?
    else
      printf_green "Cloning the repo from $remote_repo"
      mkdir -p "$homerepo"
      __git_clone "$remote_repo" "$homerepo"
      retVal=$?
    fi
    __clone_success $retVal "$homerepo"
    [ -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to clone to: $homerepo"
    exit "$?"
    ;;

    # Push
  push)
    shift 1
    [ $# -eq 0 ] && [ -d "$PWD/.git" ] && homerepo="$PWD" || { [ -d "$1/.git" ] && homerepo="$1"; } || homerepo="$(ls -d "$GITADMIN_DEFAULT_GIT_DIR_GITLAB"/*/*)"
    for d in $homerepo; do
      __mkd "$d" && [ -d "$d/.git" ] && __cd_into "$d" || printf_exit 1 1 "failed to push from: $d"
      git_push_single "$d"
    done
    ;;

    # update repo
  pull)
    shift 1
    [ "$1" = "help" ] && printf_help "Usage: $APPNAME update | pull the repos"
    [ $# -eq 0 ] && [ -d "$PWD/.git" ] && homerepo="$PWD" || { [ -d "$1/.git" ] && homerepo="$1"; } || homerepo="$(ls -d "$GITADMIN_DEFAULT_GIT_DIR_GITLAB"/*/*)"
    for d in $homerepo; do
      __mkd "$d" && [ -d "$d/.git" ] && __cd_into "$d" || printf_exit 1 1 "failed to pull to: $d"
      git_pull_single "$d"
    done
    ;;

    # add gitlab to remote
  remote)
    shift 1
    { [ $# -ne 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin gitlab remote [username/projectname] [name]"
    do_not_add_a_url "$1"
    remote_repo="https://gitlab.com/$(__strip_git_url "$1")"
    git -C "$GITADMIN_CWD" remote add "${2:-orgin}" "https://github.com/$1.git"
    exit "$?"
    ;;

  repos)
    shift 1
    __gitlab_orgs "$@"
    exit $?
    ;;

  branch)
    shift 1
    { [ $# -ne 2 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin gitlab branch projectID branch"
    __gitlab_branch "$@"
    exit $?
    ;;
  esac
  ;;

  # private repos commands
private)
  shift 1
  if [ $# = 0 ] || [ "$1" = "help" ] || [ -z "$GITADMIN_PERSONAL_GIT_HOST" ]; then
    [ -n "$GITADMIN_PERSONAL_GIT_HOST" ] || printf_red "You dont have the env variable GITADMIN_PERSONAL_GIT_HOST set in settings.conf"
    printf_green "Useful if you have a private server such as gitea"
    exit 0
  fi
  case $1 in
  # init a private repo
  init)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin private init RepoName"
    __create_dirs
    do_not_add_a_url "$1"
    if echo "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$1" | grep -q '\.git$'; then
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$1" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$1")"
    fi
    __mkd "$homerepo" && [ ! -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to initialize $homerepo"
    repos_init "$homerepo"
    exit "$?"
    ;;

    # Clone repo from private
  clone)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin private clone username/projectname"
    __create_dirs
    do_not_add_a_url "$1"
    remote_repo="$GITADMIN_PERSONAL_GIT_HOST/$(__strip_git_url "$1")"
    if echo "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$1" | grep -q '\.git$'; then
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$1" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$1")"
    fi
    if [ -d "$homerepo" ]; then
      printf_green "The repo already exists so attempting update"
      __git_pull "$homerepo"
      retVal=$?
    else
      printf_green "Cloning the repo from $remote_repo"
      mkdir -p "$homerepo"
      __git_clone "$remote_repo" "$homerepo"
      retVal=$?
    fi
    __clone_success $retVal "$homerepo"
    [ -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to initialize $homerepo"
    exit "$?"
    ;;

    # Push
  push)
    shift 1
    [ $# -eq 0 ] && [ -d "$PWD/.git" ] && homerepo="$PWD" || { [ -d "$1/.git" ] && homerepo="$1"; } || homerepo="$(ls -d "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE"/*/*)"
    for d in $homerepo; do
      __mkd "$d" && [ -d "$d/.git" ] && __cd_into "$d" || printf_exit 1 1 "failed to push from: $d"
      git_push_single "$d"
    done
    ;;

    # update repo
  pull)
    shift 1
    [ "$1" = "help" ] && printf_help "Usage: $APPNAME update | pull the repos"
    [ $# -eq 0 ] && [ -d "$PWD/.git" ] && homerepo="$PWD" || { [ -d "$1/.git" ] && homerepo="$1"; } || homerepo="$(ls -d "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE"/*/*)"
    for d in $homerepo; do
      __mkd "$d" && [ -d "$d/.git" ] && __cd_into "$d" || printf_exit 1 1 "failed to pull to: $d"
      git_pull_single "$d"
    done
    ;;

    # add private to remote
  remote)
    shift 1
    { [ $# -ne 2 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin private remote username/projectname [name]"
    do_not_add_a_url "$1"
    git -C "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$2" remote add "${2:-orgin}" "https://github.com/$(__strip_git_url "$1").git"
    exit "$?"
    ;;

    # update repo
  update)
    shift 1
    __gitea_update_all "$@"
    exit "$?"
    ;;

  create)
    shift 1
    case "$1" in
    # create a private repo
    repo)
      shift 1
      { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin private create RepoName 'description'"
      __gitea_create_repo "$@"
      exit "$?"
      ;;

      # create a private org
    org)
      shift 1
      { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin private create orgname 'reponame' 'description'"
      __gitea_create_org "$@"
      exit "$?"
      ;;
    esac
    ;;

    # create a branch
  branch)
    shift 1
    [ "$1" = "help" ] && printf_help "Usage: gitadmin private branch RepoName branch"
    __gitea_branch "$@"
    exit "$?"
    ;;

    # list private repos
  repos)
    shift 1
    if [ "$1" = "delete" ]; then
      shift 1
      { [ $# = 0 ] || [ "$1" = "help" ] && printf_help "Usage: gitadmin private repos delete RepoName"; }
      __gitea_delete_repo "$@"
    else
      { [ $# = 0 ] || [ "$1" = "help" ] && printf_help "Usage: gitadmin private repos"; }
      __gitea_users "$@"
    fi
    exit "$?"
    ;;

  migrate)
    shift 1
    printf_purple " 👁️‍🗨️  Initializing the migration utility  👁️‍🗨️ "
    if [ "$GITADMIN_MIGRATE_DELETE" = "true" ]; then
      __gitea_migrate_delete "$@"
    else
      __github_to_gitea "$@"
    fi
    exit $?
    ;;

  gist)
    shift 1
    [ -n "$GITADMIN_PRIVATE_GIST_SERVER" ] || printf_exit "Please set the variable $GITADMIN_PRIVATE_GIST_SERVER"
    case "$1" in
    init)
      shift 1
      exitCode=0
      if [ -d "$GITADMIN_CWD/.git" ]; then
        (git -C "$GITADMIN_CWD" remote add origin $GITADMIN_PRIVATE_GIST_SERVER/init && git -C "$GITADMIN_CWD" push -u origin main >/dev/null) 2>&1
        exitCode=$?
      else
        (git -C "$GITADMIN_CWD" init && git -C "$GITADMIN_CWD" add . && git -C "$GITADMIN_CWD" commit -m "🦈🏠🐜❗ Initial Commit ❗🐜🦈🏠" && git -C "$GITADMIN_CWD" remote add origin $GITADMIN_PRIVATE_GIST_SERVER/init) >/dev/null 2>&1
        results="$(git -C "$GITADMIN_CWD" push -u origin main 2>&1 | grep 'remote: Your new gist has been created here' | sed 's|.*been created here: ||g;s| ||g' | grep '://')"
        if [ -n "$results" ]; then
          if git remote set-url origin "$results" >/dev/null 2>&1; then
            printf_cyan "$GITADMIN_CWD has been initialized: $results"
          else
            exitCode=1
          fi
        else
          exitCode=1
        fi
      fi
      [ $exitCode -eq 0 ] || printf_exit "Failed to init $GITADMIN_CWD"
      ;;
    add)
      shift 1
      [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD is not a git repo"
      git -C "$GITADMIN_CWD" add . >/dev/null 2>&1 && printf_green "" || printf_return ""
      exit $?
      ;;
    commit)
      shift 1
      message="🦈🏠🐜❗ Updated Gist ❗🐜🦈🏠"
      [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD is not a git repo"
      git -C "$GITADMIN_CWD" add . && git -C "$GITADMIN_CWD" commit -m "$message" 2>&1 && printf_green "Commited $GITADMIN_CWD: $message" || printf_return "Failed to commit $GITADMIN_CWD"
      exit $?
      ;;
    push)
      shift 1
      [ -d "$GITADMIN_CWD/.git" ] && git -C "$GITADMIN_CWD" push -q || printf_exit "$GITADMIN_CWD is not a git repo"
      [ $? -eq 0 ] || printf_exit "Failed to push"
      ;;
    pull)
      if [ -d "$GITADMIN_PRIVATE_GIST_DIR/$1/.git" ]; then
        git -C "$GITADMIN_PRIVATE_GIST_DIR/$1" pull -q && printf_green "Updated $GITADMIN_PRIVATE_GIST_DIR/$1" || printf_exit "Failed to update $GITADMIN_PRIVATE_GIST_DIR/$1"
      fi
      ;;
    clone)
      shift 1
      mkdir -p "$GITADMIN_PRIVATE_GIST_DIR/$1"
      if [ -d "$GITADMIN_PRIVATE_GIST_DIR/$1/.git" ]; then
        git -C "$GITADMIN_PRIVATE_GIST_DIR/$1" pull -q
      else
        git -q -C "$GITADMIN_CWD" clone -q "$GITADMIN_PRIVATE_GIST_SERVER/$1" "$GITADMIN_PRIVATE_GIST_DIR/$1"
      fi
      [ -d "$GITADMIN_PRIVATE_GIST_DIR/$1/.git" ] && printf_green "Cloned $GITADMIN_PRIVATE_GIST_SERVER/$1 to $GITADMIN_PRIVATE_GIST_DIR/$1" || printf_exit "Failed to clone"
      ;;
    esac
    ;;
  esac
  ;;

# Issue options
issues)
  shift 1
  case "$1" in
  count)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ] && printf_help "Usage: gitadmin issues count username/projectname"; }
    __api_issues_token "$@"
    get_count="$(__api_issues "GET" | __jq 'map(select(.pull_request == null)) | length' 2>/dev/null || false)"
    [ -n "$get_count" ] || printf_exit 1 1 "failed to get count"
    printf_blue "You currently have $get_count issues"
    printf_cyan "$ISSUE_HTML"
    exit $?
    ;;

  list)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ] && printf_help "Usage: gitadmin issues count username/projectname"; }
    if [ "$1" = "json" ]; then
      shift 1
      __api_issues_token "$@"
      __api_issues "GET" | __jq
    else
      printf_green "Showing 10 of the most recent issues"
      __api_issues_token "$@"

      __api_issues "GET" | __jq -rc '.[]|[.title,.html_url]' 2>/dev/null | sed 's|","|: |g;s|"||g;s|\]||g;s|\[||g' | head -n 10 | printf_readline "5"
    fi
    ;;

  create)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ] && printf_help "Usage: gitadmin issues count username/projectname"; }
    user="${1:-$GITADMIN_DEFAULT_USERNAME}" && shift 1
    issue_repo="$1" && shift 1
    issue_title="$1" && shift 1
    [ -f "$1" ] && issue_body="$(cat "$1" | sed 's|^| |g')" || issue_body="$1"
    shift
    content="$(printf "%s\r" "{ \"title\": \"$issue_title\", \"body\": \"$issue_body\" }" >$GITADMIN_TEMP_FILE)"
    __api_issues_token ${user} ${issue_repo:-}
    printf_green "Attempting to create a new issue "
    __curl_gh_api -X "POST" "$ISSUE_API" -d @$GITADMIN_TEMP_FILE 2>/dev/null | __jq -r ".html_url" 2>/dev/null | grep -v 'null' | printf_readline | grep '^' || printf_exit 1 "Failed to create the issue on\n$ISSUE_API"
    ;;

  edit)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ] && printf_help "Usage: gitadmin issues count username/projectname"; }
    issue_number="$1" && shift 1
    user="${1:-$GITADMIN_DEFAULT_USERNAME}" && shift 1
    issue_repo="$1" && shift 1
    issue_title="$1" && shift 1
    [ -f "$1" ] && issue_body="$(cat "$1" | sed 's|^| |g')" || issue_body="$1"
    shift
    content="$(printf "%s\r" "{ \"title\": \"$issue_title\", \"body\": \"$issue_body\" }" >$GITADMIN_TEMP_FILE)"
    __api_issues_token "$user" "$issue_repo"
    printf_green "Attempting to edit issue $issue_number"
    __curl_gh_api -X "PATCH" "$ISSUE_API/$issue_number" -d @$GITADMIN_TEMP_FILE 2>/dev/null | __jq -r ".html_url" 2>/dev/null | grep -v 'null' | printf_readline | grep '^' || printf_exit 1 "Failed to edit the issue at\n$ISSUE_API/$issue_number"
    ;;

  delete)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ] && printf_help "Usage: gitadmin issues count username/projectname"; }
    printf_exit "Not implemented yet"
    issue_number="$1" && shift 1
    __api_issues_token "$@"
    ;;

  *)
    { [ $# = 0 ] || [ "$1" = "help" ] && printf_help "Usage: gitadmin issues [list,count,create] username/projectname"; }
    $APPNAME issues list "$@"
    exit $?
    ;;
  esac
  ;;

cron | updater)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && printf_help "Usage: gitadmin cron [run,remove,add]"
  case "$1" in
  run)
    shift 1
    __run_cron "run"
    ;;
  remove)
    shift 1
    __run_cron "remove"
    ;;
  add)
    shift 1
    __run_cron "add"
    ;;
  esac
  ;;

*)
  if [ $# -eq 0 ] || [ "$1" = "help" ]; then
    __help
    exit 0
  else
    git_cmd="$(builtin type -P git 2>/dev/null)"
    if $git_cmd $1 --help 2>&1 | grep -vq 'is not a git command'; then
      $git_cmd -C "$GITADMIN_CWD" "$@"
      exitCode=$?
    else
      printf_red "git $1 is not valid command"
      exitCode=127
    fi
  fi
  ;;
esac
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set exit code
exitCode="${exitCode:-0}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# End application
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# lets exit with code
exit ${exitCode:-0}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# ex: ts=2 sw=2 et filetype=sh
