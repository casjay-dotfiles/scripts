#!/usr/bin/env bash
# shellcheck shell=bash
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
##@Version           :  202501191000-git
# @@Author           :  Jason Hempstead
# @@Contact          :  jason@casjaysdev.pro
# @@License          :  WTFPL
# @@ReadME           :  gitadmin --help
# @@Copyright        :  Copyright: (c) 2022 Jason Hempstead, Casjays Developments
# @@Created          :  Monday, Aug 08, 2022 23:22 EDT
# @@File             :  gitadmin
# @@Description      :  push/clone/pull from github/gitlab/private repo
# @@Changelog        :  Fixed default platform (github), improved Gitea create, better error handling
# @@TODO             :  Organize this a lot better and split into seperate scripts
# @@Other            :  Somethings may be broken due to variable changes
# @@Resource         :
# @@Terminal App     :  no
# @@sudo/root        :  no
# @@Template         :  bash/system
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# shellcheck disable=SC1001,SC1003,SC2001,SC2003,SC2016,SC2031,SC2120,SC2155,SC2199,SC2317,SC2329
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
APPNAME="$(basename -- "$0" 2>/dev/null)"
VERSION="202501191000-git"
USER="${SUDO_USER:-$USER}"
RUN_USER="${RUN_USER:-$USER}"
USER_HOME="${USER_HOME:-$HOME}"
SCRIPT_SRC_DIR="${BASH_SOURCE%/*}"
REQUIRE_SUDO="${REQUIRE_SUDO:-no}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Reopen in a terminal
#if [ ! -t 0 ] && { [ "$1" = --term ] || [ $# = 0 ]; }; then { [ "$1" = --term ] && shift 1 || true; } && TERMINAL_APP="TRUE" myterminal -e "$APPNAME $*" && exit || exit 1; fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set script title
#CASJAYS_DEV_TILE_FORMAT="${USER}@${HOSTNAME}:${PWD//$HOME/\~} - $APPNAME"
#CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}"
#[ -z "$CASJAYSDEV_TITLE_SET" ] && printf '\033]2‚îÇ;%s\033\\' "$CASJAYS_DEV_TILE_FORMAT" && CASJAYSDEV_TITLE_SET="$APPNAME"
export CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}" CASJAYSDEV_TITLE_SET
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Initial debugging
[ "$1" = "--debug" ] && set -x && export SCRIPT_OPTS="--debug" && export _DEBUG="on"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Disables colorization
[ "$1" = "--raw" ] && export SHOW_RAW="true"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# pipes fail
set -o pipefail
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Import functions
CASJAYSDEVDIR="${CASJAYSDEVDIR:-/usr/local/share/CasjaysDev/scripts}"
SCRIPTSFUNCTDIR="${CASJAYSDEVDIR:-/usr/local/share/CasjaysDev/scripts}/functions"
SCRIPTSFUNCTFILE="${SCRIPTSAPPFUNCTFILE:-testing.bash}"
SCRIPTSFUNCTURL="${SCRIPTSAPPFUNCTURL:-https://github.com/dfmgr/installer/raw/main/functions}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if [ -f "$PWD/$SCRIPTSFUNCTFILE" ]; then
  . "$PWD/$SCRIPTSFUNCTFILE"
elif [ -f "$SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE" ]; then
  . "$SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE"
else
  echo "Can not load the functions file: $SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE" 1>&2
  exit 1
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Options are: *_install
# system user desktopmgr devenvmgr dfmgr dockermgr fontmgr iconmgr pkmgr systemmgr thememgr wallpapermgr
user_install && __options "$@"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Send all output to /dev/null
__devnull() {
  if tee &>/dev/null; then
    exitCode=0
  else
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Send errors to /dev/null
__devnull2() {
  if [ -n "$1" ]; then
    local cmd="$1"
    shift 1
  else
    return 1
  fi
  if eval $cmd "$*" 2>/dev/null; then
    exitCode=0
  else
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# See if the executable exists
__cmd_exists() {
  local exitCode=0
  [ -n "$1" ] || return 0
  for cmd in "$@"; do
    if builtin command -v "$cmd" &>/dev/null; then
      exitCode=$((exitCode + 0))
    else
      exitCode=$((exitCode + 1))
    fi
  done
  [ $exitCode -eq 0 ] || exitCode=3
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for a valid internet connection
__am_i_online() {
  local exitCode=0
  curl -q -ISsf --max-time 2 --retry 1 "${1:-https://1.1.1.1}" 2>&1 | grep -qi 'server:.*cloudflare' || exitCode=4
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# colorization
if [ "$SHOW_RAW" = "true" ]; then
  NC=""
  RESET=""
  BLACK=""
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  PURPLE=""
  CYAN=""
  WHITE=""
  ORANGE=""
  LIGHTRED=""
  BG_GREEN=""
  BG_RED=""
  ICON_INFO="[ info ]"
  ICON_GOOD="[ ok ]"
  ICON_WARN="[ warn ]"
  ICON_ERROR="[ error ]"
  ICON_QUESTION="[ ? ]"
  printf_column() { tee | grep '^'; }
  printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
else
  printf_color() { printf "%b" "$(tput setaf "${2:-7}" 2>/dev/null)" "$1" "$(tput sgr0 2>/dev/null)"; }
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional printf_ colors
__printf_head() { printf_blue "$1"; }
__printf_opts() { printf_purple "$1"; }
__printf_line() { printf_cyan "$1"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__printf_help() {
  printf '\n'
  printf_purple "$*\n"
  exit
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# output version
__version() { printf_cyan "$VERSION"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# list options
__list_options() {
  printf_color "$1: " "$5"
  echo -ne "$2" | sed 's|:||g;s/'$3'/ '$4'/g' | tr '\n' ' '
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# create the config file
__gen_config() {
  local NOTIFY_CLIENT_NAME="$APPNAME"
  if [ "$INIT_CONFIG" != "TRUE" ]; then
    printf_blue "Generating the config file in"
    printf_cyan "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE"
  fi
  [ -d "$GITADMIN_CONFIG_DIR" ] || mkdir -p "$GITADMIN_CONFIG_DIR"
  [ -d "$GITADMIN_CONFIG_BACKUP_DIR" ] || mkdir -p "$GITADMIN_CONFIG_BACKUP_DIR"
  [ -f "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE" ] &&
    cp -Rf "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE" "$GITADMIN_CONFIG_BACKUP_DIR/$GITADMIN_CONFIG_FILE.$$"
  cat <<EOF >"$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE"
# Settings for gitadmin
GITADMIN_DEFAULT_USERNAME="${GITADMIN_DEFAULT_USERNAME:-$GITHUB_USERNAME}"
GITADMIN_DEFAULT_PLATFORM="${GITADMIN_DEFAULT_PLATFORM:-github}"
GITADMIN_DEFAULT_BRANCH="${GITADMIN_DEFAULT_BRANCH:-main}"
GITADMIN_DEFAULT_REPO_BASE="${GITADMIN_REPO_URL:-https://github.com}"
GITADMIN_DEFAULT_README="${GITADMIN_DEFAULT_README:-default}"
GITADMIN_DEFAULT_LICENSE="${MY_LICENSE_FILE:-$CASJAYSDEVDIR/templates/wtfpl.md}"
GITADMIN_DEFAULT_PROJECT_DIR="${GITADMIN_DEFAULT_PROJECT_DIR:-$HOME/Projects}"
GITADMIN_DEFAULT_GIT_DIR_GITHUB="${GITADMIN_DEFAULT_GIT_DIR_GITHUB:-$GITADMIN_DEFAULT_PROJECT_DIR/github}"
GITADMIN_DEFAULT_GIT_DIR_GITLAB="${GITADMIN_DEFAULT_GIT_DIR_GITLAB:-$GITADMIN_DEFAULT_PROJECT_DIR/gitlab}"
GITADMIN_DEFAULT_GIT_DIR_PRIVATE="${GITADMIN_DEFAULT_GIT_DIR_PRIVATE:-$GITADMIN_DEFAULT_PROJECT_DIR/Private}"
GITADMIN_DEFAULT_USER_DOMAIN="${GITADMIN_DEFAULT_USER_DOMAIN:-}"
GITADMIN_PERSONAL_GIT_HOST="${GITADMIN_PERSONAL_GIT_HOST:-$GIT_PRIVATE_URL}"
GITADMIN_GITHUB_AUTH_TOKEN="${GITADMIN_GITHUB_AUTH_TOKEN:-$GITHUB_ACCESS_TOKEN}"
GITADMIN_DEFAULT_VERSION_FILE="${GITADMIN_DEFAULT_VERSION_FILE:-version.txt}"
GITADMIN_DEFAULT_VERSION_FORMAT="${VERSION_DATE_FORMAT:-%Y%m%d%H%M-git}"
GITADMIN_GITLAB_AUTH_TOKEN="${GITADMIN_GITLAB_AUTH_TOKEN:-$GITLAB_ACCESS_TOKEN}"
GITADMIN_PRIVATE_AUTH_TOKEN="${GITADMIN_PRIVATE_AUTH_TOKEN:-$GIT_PRIVATE_ACCESS_TOKEN}"
GITADMIN_DOMAIN_TEMPLATE="${GITADMIN_DOMAIN_TEMPLATE:-https://github.com/casjay-templates/domain-template}"
GITADMIN_DEFAULT_MAINCONFIG="${GITADMIN_DEFAULT_MAINCONFIG:-gitmainconfig}"
GITADMIN_GITHUB_API_VERSION="${GITADMIN_GITHUB_API_VERSION:-}"
GITADMIN_LFS_FILE_TYPES="${GITADMIN_LFS_FILE_TYPES:-}"
GITADMIN_BACKUP_ORG="${GITADMIN_BACKUP_ORG:-}"
GITADMIN_BACKUP_URL="${GITADMIN_BACKUP_URL:-https://github.com}"
GITADMIN_BACKUP_DIR="${GITADMIN_BACKUP_DIR:-$GITADMIN_CONFIG_DIR/repos}"
GITADMIN_MAIN_CONF_NAME="${GITADMIN_MAIN_CONF_NAME:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
GITADMIN_PRIVATE_GIST_DIR="${GITADMIN_PRIVATE_GIST_DIR:-}"
GITADMIN_PRIVATE_GIST_SERVER="${GITADMIN_PRIVATE_GIST_SERVER:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
GITADMIN_OUTPUT_COLOR_1="${GITADMIN_OUTPUT_COLOR_1:-}"
GITADMIN_OUTPUT_COLOR_2="${GITADMIN_OUTPUT_COLOR_2:-}"
GITADMIN_OUTPUT_COLOR_GOOD="${GITADMIN_OUTPUT_COLOR_GOOD:-}"
GITADMIN_OUTPUT_COLOR_ERROR="${GITADMIN_OUTPUT_COLOR_ERROR:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
GITADMIN_NOTIFY_ENABLED="${GITADMIN_NOTIFY_ENABLED:-}"
GITADMIN_GOOD_NAME="${GITADMIN_GOOD_NAME:-}"
GITADMIN_ERROR_NAME="${GITADMIN_ERROR_NAME:-}"
GITADMIN_GOOD_MESSAGE="${GITADMIN_GOOD_MESSAGE:-}"
GITADMIN_ERROR_MESSAGE="${GITADMIN_ERROR_MESSAGE:-}"
GITADMIN_NOTIFY_CLIENT_NAME="${GITADMIN_NOTIFY_CLIENT_NAME:-}"
GITADMIN_NOTIFY_CLIENT_ICON="${GITADMIN_NOTIFY_CLIENT_ICON:-}"
GITADMIN_NOTIFY_CLIENT_URGENCY="${GITADMIN_NOTIFY_CLIENT_URGENCY:-}"

EOF
  if builtin type -t __gen_config_local | grep -q 'function'; then __gen_config_local; fi
  if [ -f "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE" ]; then
    [ "$INIT_CONFIG" = "TRUE" ] || printf_green "Your config file for $APPNAME has been created"
    . "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE"
    exitCode=0
  else
    printf_red "‚ùå Failed to create the config file"
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Help function - Align to 50
__help() {
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "gitadmin:  push/clone/pull from github/gitlab/private repo - $VERSION"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "Usage: gitadmin [options] [directory] [commands]"
  __printf_line "init                            - Initialize current project into a git repo"
  __printf_line "setup                           - Initialize current project into a git repo"
  __printf_line "stow                            - Keep your dotfiles in a repo"
  __printf_line "status                          - Show repo status"
  __printf_line "log                             - Show the git log"
  __printf_line "lfs                             - Run lfs commands"
  __printf_line "branch                          - Rename the current branch"
  __printf_line "commit                          - Commit the current changes"
  __printf_line "update                          - Run git pull on all repos"
  __printf_line "backup                          - backup all repos"
  __printf_line "repos [userName]                - Show all your public repo"
  __printf_line "push [directory]                - Push a project to a remote repo"
  __printf_line "pull [directory]                - Update a local git repo"
  __printf_line "clone [repo] [directory]        - Clone a git repo"
  __printf_line "modify [user/repo|.]            - Modify repo settings [--platform] [--description] [--homepage]"
  __printf_line "create [user/repo] [desc]       - Create a new repo [--platform] [--private|--public]"
  __printf_line "delete [user/repo|.]            - Delete a repo [--platform github|gitlab|gitea]"
  __printf_line "shorten  [URL] [name]           - Shorten any github url"
  __printf_line "newsite [sitename] [repo]       - Create a site using template [$GITADMIN_DOMAIN_TEMPLATE]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Remote Repo: [show,add] [remoteURL]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "remote show                     - Show the current remote server "
  __printf_line "remote add [remoteURL]          - Add new remote url"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "User: [options] [userName]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "user [userName]                 - Clone/Pull all repos owned by you"
  __printf_line "user list [userName]            - List all repos owned by you"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Organization: [all,push,pull,clone] [userName]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "orgs all [userName]             - Clone/Pull all orgs owned by you"
  __printf_line "orgs push [userName]            - Push all your local repos to remote"
  __printf_line "orgs pull [userName]            - Update all your local repos from remote"
  __printf_line "orgs clone [userName]           - Clone a repo"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Github Gist: [clone,create,delete,edit,list,search] [userName]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "gist clone [id] [directory]     - Clone a gist repo"
  __printf_line "gist create [userName]          - Create a new github gist"
  __printf_line "gist delete [userName]          - Delete a github gist"
  __printf_line "gist edit [userName]            - Edit github gist"
  __printf_line "gist list [userName]            - List github gists"
  __printf_line "gist search [userName]          - Search for github gist"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Single Actions: [all,init,clone,push,pull] [arguments]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "single all                      - Push all repos in ~/Projects/*/[userName]/*"
  __printf_line "single init [directory]         - single init"
  __printf_line "single clone [RemoteURL]        - Clone a repo"
  __printf_line "single push [directory]         - Push your local repo to remote"
  __printf_line "single pull [directory]         - Run git pull on repo"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Github Repo Actions: [init,clone,push,pull,remote] [userName/repo]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "github init [directory]                     - single init"
  __printf_line "github clone [directory]                    - Clone a repo [RemoteURL]"
  __printf_line "github push [directory]                     - Push your local repo to remote"
  __printf_line "github pull [directory]                     - Run git pull on repo"
  __printf_line "github remote [directory]                   - Add new remote url [userName/repoName]"
  __printf_line "github orgs visibility [show|public|private] - Change membership visibility"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Gitlab Repo Actions: [init,clone,push,pull,remote] [userName/repo]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "gitlab init [directory]         - single init"
  __printf_line "gitlab clone [directory]        - Clone a repo [RemoteURL]"
  __printf_line "gitlab push [directory]         - Push your local repo to remote"
  __printf_line "gitlab pull [directory]         - Run git pull on repo"
  __printf_line "gitlab remote [directory]       - Add new remote url [userName/repoName]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Private Repo Actions: [init,clone,push,pull,remote,migrate] [userName/repo]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "private init [directory]        - single init"
  __printf_line "private clone [directory]       - Clone a repo [RemoteURL]"
  __printf_line "private push [directory]        - Push your local repo to remote"
  __printf_line "private pull [directory]        - Run git pull on repo"
  __printf_line "private remote [directory]      - Add new remote url [userName/repoName]"
  __printf_line "private migrate [directory]     - Migrate from github to gitea [github_user] [github_org] [gitea_user] [gitea_org]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Github Issue: [list,count,create,edit] [userName] [repoName]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "issues count                    - Show how many issues exist"
  __printf_line "issues list [repo]              - Show current github issues for current project"
  __printf_line "issues create [repo]            - Create a new issue"
  __printf_line "issues edit [id]                - Edit a current issue"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Repo options: [--user,--org,--dir,--cd] [arguments]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "--user [userName]               - List user repos"
  __printf_line "--org [orgNAME]                 - List organization repos "
  __printf_line "--single [repoURL]              - clone a single repo "
  __printf_line "--dir [directory]               - Sets the working directory"
  __printf_line "--cd                            - cd into repo upon update/clone"
  __printf_line "--platform [github|gitlab|gitea] - Set the platform to use"
  __printf_line "--github|--gitlab|--gitea       - Quick platform selection"
  __printf_line "--private|--public              - Set repository visibility"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Other Options"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "--help                          - Shows this message"
  __printf_line "--config                        - Generate user config file"
  __printf_line "--version                       - Show script version"
  __printf_line "--options                       - Shows all available options"
  __printf_line "--debug                         - Enables script debugging"
  __printf_line "--raw                           - Removes all formatting on output"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "This is a work in progress"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "cron                            - Autoupdate all repos using cron"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# check if arg is a builtin option
__is_an_option() { if echo "$ARRAY" | grep -q "${1:-^}"; then return 1; else return 0; fi; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Is current user root
__user_is_root() {
  if [ $(id -u) -eq 0 ] || [ $EUID -eq 0 ] || [ "$WHOAMI" = "root" ]; then
    return 0
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Is current user not root
__user_is_not_root() {
  if { [ $(id -u) -eq 0 ] || [ $EUID -eq 0 ] || [ "$WHOAMI" = "root" ]; }; then return 1; else return 0; fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check if user is a member of sudo
__sudo_group() {
  grep -sh "${1:-$USER}" "/etc/group" | grep -Eq 'wheel|adm|sudo' || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# # Get sudo password
__sudoask() {
  if ask_for_password sudo true; then
    return 0
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run sudo
__sudorun() {
  if __sudoif && __cmd_exists sudo; then
    sudo -HE "$@"
  elif __sudoif; then
    eval "$@"
  fi
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Test if user has access to sudo
__can_i_sudo() {
  if (sudo -vn && sudo -ln) 2>&1 | grep -vq 'may not' >/dev/null; then
    return 0
  fi
  if __sudo_group "${1:-$USER}" || __sudoif || __sudo true &>/dev/null; then
    return 0
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User can run sudo
__sudoif() {
  if __user_is_root; then
    return 0
  fi
  if __can_i_sudo "${RUN_USER:-$USER}"; then
    return 0
  fi
  if __user_is_not_root && __sudoask; then
    return 0
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run command as root
__requiresudo() {
  if [ "$REQUIRE_SUDO" = "yes" ] && [ -z "$REQUIRE_SUDO_RUN" ]; then
    export REQUIRE_SUDO="no"
    export REQUIRE_SUDO_RUN="true"
    __sudo "$@"
    exit $?
  else
    return 0
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute sudo
__sudo() {
  CMD="${1:-echo}" && shift 1
  CMD_ARGS="${*:--e "${RUN_USER:-$USER}"}"
  SUDO="$(builtin command -v sudo 2>/dev/null || echo 'eval')"
  [ "$(basename -- "$SUDO" 2>/dev/null)" = "sudo" ] && OPTS="--preserve-env=PATH -HE"
  if __sudoif; then
    export PATH="$PATH"
    if $SUDO ${OPTS:-} $CMD $CMD_ARGS; then
      exitCode=0
    else
      exitCode=1
    fi
  else
    printf '%s\n' "This requires root to run"
    exitCode=1
  fi
  return ${exitCode:-1}
}
# End of sudo functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__trap_exit() {
  exitCode=${exitCode:-0}
  [ -f "$GITADMIN_TEMP_FILE" ] && rm -Rf "$GITADMIN_TEMP_FILE" &>/dev/null
  #unset CASJAYSDEV_TITLE_SET && printf '\033]2‚îÇ;%s\033\\' "${USER}@${HOSTNAME}:${PWD//$HOME/\~} - ${CASJAYSDEV_TITLE_PREV:-$SHELL}"
  if builtin type -t __trap_exit_local | grep -q 'function'; then __trap_exit_local; fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined functions
__jq() { jq "$@" 2>/dev/null | grep -v '^$' | grep '^' || return 1; }
__test_if_number() { test -n "$1" && test -z "${1//[0-9]/}" || return 1; }
__test_if_url() { grep -E $1 'http://|https://|git://|ssh://' || return 1; }
__if_is_url() { echo "$1" | grep -Eq 'http://|https://|git://|ssh://' || return 1; }
__file_exists_and_not_empty() { [ -f "$1" ] && [ -s "$1" ] && return 0 || return 2; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__printf_space() {
  local color padlength width
  test -n "$1" && test -z "${1//[0-9]/}" && color="$1" && shift 1 || color="7"
  test -n "$1" && test -z "${1//[0-9]/}" && padlength="$1" && shift 1 || padlength="50"
  width=$((${#1} - $padlength))
  printf '%b' "$(tput setaf "$color" 2>/dev/null)"
  printf "%s%-${width}s%s" "$1" " " "$2"
  printf '%b' "$(tput sgr0 2>/dev/null)"
  printf '\n'
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# create directory structures
__create_dirs() {
  local d=""
  local dir=""
  local directories="${*:-github gitlab private local}"
  local project_dir="${GITADMIN_DEFAULT_PROJECT_DIR:-$HOME/Projects}"
  for d in $directories; do
    dir="${d//$project_dir/}"
    if [ ! -d "$project_dir/$dir" ]; then
      mkdir -p "$project_dir/$dir" || printf_exit "Failed to create $dir in $project_dir: Ensure $project_dir is mounted and writable"
    fi
  done
  return
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__update_usage() {
  printf_cyan "Usage: var=value var2=myvalue"
  exit
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Generate JSON template for repo creation based on visibility
__generate_repo_json() {
  local repo_name="$1"
  local description="${2:-Repository for $1}"
  local homepage="${3:-}"
  local visibility="${4:-public}" # public or private
  local platform="${5:-github}"   # github, gitlab, gitea

  # Set homepage if not provided
  if [ -z "$homepage" ]; then
    case "$platform" in
    github) homepage="https://github.com/${GITADMIN_DEFAULT_USERNAME}/$repo_name" ;;
    gitlab) homepage="https://gitlab.com/${GITADMIN_DEFAULT_USERNAME}/$repo_name" ;;
    gitea) homepage="${GITADMIN_PERSONAL_GIT_HOST}/${GITADMIN_DEFAULT_USERNAME}/$repo_name" ;;
    *) homepage="${GITADMIN_DEFAULT_USER_DOMAIN:-}" ;;
    esac
  fi

  # Generate JSON based on platform and visibility
  case "$platform" in
  github | gitlab)
    if [ "$visibility" = "private" ]; then
      cat <<EOF
{
  "name": "$repo_name",
  "description": "$description",
  "homepage": "$homepage",
  "visibility": "private",
  "private": true,
  "has_issues": false,
  "has_downloads": false,
  "has_wiki": false,
  "has_projects": false
}
EOF
    else
      cat <<EOF
{
  "name": "$repo_name",
  "description": "$description",
  "homepage": "$homepage",
  "visibility": "public",
  "private": false,
  "has_issues": true,
  "has_downloads": true,
  "has_wiki": true,
  "has_projects": true
}
EOF
    fi
    ;;
  gitea)
    local is_private="false"
    [ "$visibility" = "private" ] && is_private="true"
    cat <<EOF
{
  "auto_init": false,
  "default_branch": "main",
  "name": "$repo_name",
  "description": "$description",
  "private": $is_private
}
EOF
    ;;
  *)
    printf_red "Unknown platform: $platform"
    return 1
    ;;
  esac
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Legacy function for backward compatibility - creates private repo JSON
__create_new_private_repo_template() {
  REPO_NAME="${1:-$REPO_NAME}"
  DESCRIPTION="${2:-$DESCRIPTION}"
  HOMEPAGE="${3:-$GITADMIN_DEFAULT_USER_DOMAIN}"
  JSON_OUTPUT="$(__generate_repo_json "$REPO_NAME" "$DESCRIPTION" "$HOMEPAGE" "private" "github")"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Legacy function for backward compatibility - creates public repo JSON
__create_new_repo_template() {
  REPO_NAME="${1:-$REPO_NAME}"
  DESCRIPTION="${2:-$DESCRIPTION}"
  HOMEPAGE="${3:-$GITADMIN_DEFAULT_USER_DOMAIN}"
  JSON_OUTPUT="$(__generate_repo_json "$REPO_NAME" "$DESCRIPTION" "$HOMEPAGE" "public" "github")"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Detect which git platform a repo belongs to
__detect_git_platform() {
  local check_url="${1:-}"
  local check_dir="${2:-$GITADMIN_CWD}"

  # Check from URL first
  if [ -n "$check_url" ]; then
    case "$check_url" in
    *github.com*)
      echo "github"
      return 0
      ;;
    *gitlab.com*)
      echo "gitlab"
      return 0
      ;;
    *"$GITADMIN_PERSONAL_GIT_HOST"*)
      echo "gitea"
      return 0
      ;;
    *)
      # Try to determine from URL pattern
      if echo "$check_url" | grep -q "gitlab"; then
        echo "gitlab"
      elif echo "$check_url" | grep -q "gitea\|gogs"; then
        echo "gitea"
      else
        echo "github" # Default
      fi
      return 0
      ;;
    esac
  fi

  # Check from git remote if in a repo
  if [ -d "$check_dir/.git" ]; then
    local remote_url="$(git -C "$check_dir" remote get-url origin 2>/dev/null)"
    if [ -n "$remote_url" ]; then
      __detect_git_platform "$remote_url"
      return 0
    fi
  fi

  # Check from directory structure
  case "$check_dir" in
  *gitlab*)
    echo "gitlab"
    return 0
    ;;
  *github*)
    echo "github"
    return 0
    ;;
  *private* | *gitea*)
    echo "gitea"
    return 0
    ;;
  *)
    echo "github"
    return 0
    ;; # Default to github
  esac
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Universal repo modify function
__universal_repo_modify() {
  local platform="${1:-}"
  local user="${2:-}"
  local repo="${3:-}"

  case "$platform" in
  github)
    __github_repo_modify "$user" "$repo"
    ;;
  gitlab)
    __gitlab_repo_modify "$user" "$repo"
    ;;
  gitea | private)
    __gitea_repo_modify "$user" "$repo"
    ;;
  *)
    printf_red "Unknown platform: $platform"
    return 1
    ;;
  esac
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Modify GitHub repo
__github_repo_modify() {
  local user="$1"
  local repo="$2"

  local url="https://api.github.com/repos/$user/$repo"
  local json_data=""
  local updates=""

  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1

  # Build updates from getopt-parsed variables
  [ -n "$GITADMIN_REPO_DESCRIPTION" ] && updates="${updates:+$updates,}\"description\":\"$GITADMIN_REPO_DESCRIPTION\""
  [ -n "$GITADMIN_REPO_HOMEPAGE" ] && updates="${updates:+$updates,}\"homepage\":\"$GITADMIN_REPO_HOMEPAGE\""
  [ "$GITADMIN_REPO_VISIBILITY" = "private" ] && updates="${updates:+$updates,}\"private\":true"
  [ "$GITADMIN_REPO_VISIBILITY" = "public" ] && updates="${updates:+$updates,}\"private\":false"
  [ -n "$GITADMIN_REPO_ISSUES" ] && updates="${updates:+$updates,}\"has_issues\":$GITADMIN_REPO_ISSUES"
  [ -n "$GITADMIN_REPO_WIKI" ] && updates="${updates:+$updates,}\"has_wiki\":$GITADMIN_REPO_WIKI"
  [ -n "$GITADMIN_REPO_PROJECTS" ] && updates="${updates:+$updates,}\"has_projects\":$GITADMIN_REPO_PROJECTS"
  [ "$GITADMIN_DEFAULT_BRANCH_SET" = "yes" ] && updates="${updates:+$updates,}\"default_branch\":\"$GITADMIN_DEFAULT_BRANCH\""

  if [ -z "$updates" ]; then
    printf_red "No modifications specified"
    return 1
  fi

  json_data="{$updates}"
  [ -n "$_DEBUG" ] && printf_yellow "DEBUG: Sending JSON: $json_data"

  local response
  # Use curl directly for PATCH requests since __curl_gh_api isn't handling them properly
  response="$(curl -q -LSs -H "Authorization: token $GITADMIN_GITHUB_AUTH_TOKEN" -H "Accept: application/vnd.github.v3+json" -H "X-GitHub-Api-Version: $GITADMIN_GITHUB_API_VERSION" -X PATCH "$url" --data "$json_data" 2>/dev/null)"

  # Check if we got a valid response with the expected field
  if echo "$response" | grep -q "\"full_name\""; then
    printf_green "üò∫ Successfully updated https://github.com/$user/$repo üò∫"
    return 0
  elif echo "$response" | grep -q "\"id\""; then
    # Also check for id field as alternate success indicator
    printf_green "üò∫ Successfully updated https://github.com/$user/$repo üò∫"
    return 0
  else
    # Always show response for debugging
    printf_yellow "DEBUG: Response length: ${#response} chars"
    if [ -n "$response" ]; then
      printf_yellow "DEBUG: First 100 chars: ${response:0:100}"
    else
      printf_yellow "DEBUG: Empty response!"
    fi
    printf_red "üëø Failed to update $user/$repo üëø"
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Modify GitLab repo
__gitlab_repo_modify() {
  local user="$1"
  local repo="$2"

  # GitLab uses project IDs, need to get it first
  local project_id="$(echo "$user/$repo" | sed 's/\//%2F/g')"
  local url="https://gitlab.com/api/v4/projects/$project_id"
  local updates=""

  [ -z "$GITADMIN_GITLAB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITLAB_AUTH_TOKEN is not set" && return 1

  # Build updates from getopt-parsed variables
  [ -n "$GITADMIN_REPO_DESCRIPTION" ] && updates="${updates:+$updates,}\"description\":\"$GITADMIN_REPO_DESCRIPTION\""
  [ -n "$GITADMIN_REPO_HOMEPAGE" ] && updates="${updates:+$updates,}\"homepage\":\"$GITADMIN_REPO_HOMEPAGE\""
  [ "$GITADMIN_REPO_VISIBILITY" = "private" ] && updates="${updates:+$updates,}\"visibility\":\"private\""
  [ "$GITADMIN_REPO_VISIBILITY" = "public" ] && updates="${updates:+$updates,}\"visibility\":\"public\""
  [ -n "$GITADMIN_REPO_ISSUES" ] && updates="${updates:+$updates,}\"issues_enabled\":$GITADMIN_REPO_ISSUES"
  [ -n "$GITADMIN_REPO_WIKI" ] && updates="${updates:+$updates,}\"wiki_enabled\":$GITADMIN_REPO_WIKI"
  [ -n "$GITADMIN_REPO_PROJECTS" ] && updates="${updates:+$updates,}\"jobs_enabled\":$GITADMIN_REPO_PROJECTS"
  [ "$GITADMIN_DEFAULT_BRANCH_SET" = "yes" ] && updates="${updates:+$updates,}\"default_branch\":\"$GITADMIN_DEFAULT_BRANCH\""

  if [ -z "$updates" ]; then
    printf_red "No modifications specified"
    return 1
  fi

  local json_data="{$updates}"

  if curl -q -LSsf -X PUT -H "PRIVATE-TOKEN: $GITADMIN_GITLAB_AUTH_TOKEN" \
    -H "Content-Type: application/json" \
    --data "$json_data" "$url" 2>/dev/null | grep -q "\"name\""; then
    printf_green "üò∫ Successfully updated https://gitlab.com/$user/$repo üò∫"
    return 0
  else
    printf_red "üëø Failed to update https://gitlab.com/$user/$repo üëø"
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Modify Gitea repo
__gitea_repo_modify() {
  local user="$1"
  local repo="$2"

  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/repos/$user/$repo"
  local token="$GITADMIN_PRIVATE_AUTH_TOKEN"
  local updates=""

  [ -z "$token" ] && printf_red "üö´ ERROR: GITADMIN_PRIVATE_AUTH_TOKEN is not set" && return 1

  # Build updates from getopt-parsed variables
  [ -n "$GITADMIN_REPO_DESCRIPTION" ] && updates="${updates:+$updates,}\"description\":\"$GITADMIN_REPO_DESCRIPTION\""
  [ -n "$GITADMIN_REPO_HOMEPAGE" ] && updates="${updates:+$updates,}\"website\":\"$GITADMIN_REPO_HOMEPAGE\""
  [ "$GITADMIN_REPO_VISIBILITY" = "private" ] && updates="${updates:+$updates,}\"private\":true"
  [ "$GITADMIN_REPO_VISIBILITY" = "public" ] && updates="${updates:+$updates,}\"private\":false"
  [ -n "$GITADMIN_REPO_ISSUES" ] && updates="${updates:+$updates,}\"has_issues\":$GITADMIN_REPO_ISSUES"
  [ -n "$GITADMIN_REPO_WIKI" ] && updates="${updates:+$updates,}\"has_wiki\":$GITADMIN_REPO_WIKI"
  [ -n "$GITADMIN_REPO_PROJECTS" ] && updates="${updates:+$updates,}\"has_projects\":$GITADMIN_REPO_PROJECTS"
  [ "$GITADMIN_DEFAULT_BRANCH_SET" = "yes" ] && updates="${updates:+$updates,}\"default_branch\":\"$GITADMIN_DEFAULT_BRANCH\""

  if [ -z "$updates" ]; then
    printf_red "No modifications specified"
    return 1
  fi

  local json_data="{$updates}"

  if curl -q -LSsf -X PATCH -H "Authorization: token $token" \
    -H "Content-Type: application/json" \
    --data "$json_data" "$url" 2>/dev/null | grep -q "\"name\""; then
    printf_green "üò∫ Successfully updated $GITADMIN_PERSONAL_GIT_HOST/$user/$repo üò∫"
    return 0
  else
    printf_red "üëø Failed to update $GITADMIN_PERSONAL_GIT_HOST/$user/$repo üëø"
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Universal create function
__universal_repo_create() {
  local platform="${1:-}"
  local user="${2:-}"
  local repo="${3:-}"
  local description="${4:-}"
  local visibility="${5:-public}"
  local homepage="${6:-}"

  # Build full URL for display
  local display_url=""
  case "$platform" in
  github)
    display_url="https://github.com"
    ;;
  gitlab)
    display_url="https://gitlab.com"
    ;;
  gitea | private)
    display_url="$GITADMIN_PERSONAL_GIT_HOST"
    ;;
  *)
    display_url="$platform"
    ;;
  esac

  printf_purple "üî® Creating $visibility repo: $repo for $user on $display_url"

  local result=0
  case "$platform" in
  github)
    __github_create_repo "$user/$repo" "$description" "$visibility" "$homepage"
    result=$?
    ;;
  gitlab)
    __gitlab_create_repo "$user" "$repo" "$description" "$homepage" "$visibility"
    result=$?
    ;;
  gitea | private)
    __gitea_create_repo "$repo" "$description" "$visibility"
    result=$?
    ;;
  *)
    printf_red "‚ùå Unknown platform: $platform"
    result=1
    ;;
  esac

  return $result
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Universal delete function
__universal_repo_delete() {
  local platform="${1:-}"
  local user="${2:-}"
  local repo="${3:-}"

  # Build full URL for display
  local display_url=""
  case "$platform" in
  github)
    display_url="https://github.com"
    ;;
  gitlab)
    display_url="https://gitlab.com"
    ;;
  gitea | private)
    display_url="$GITADMIN_PERSONAL_GIT_HOST"
    ;;
  *)
    display_url="$platform"
    ;;
  esac

  printf_cyan "üóëÔ∏è  Deleting repo $repo for $user on $display_url"

  local result=0
  case "$platform" in
  github)
    __github_delete_repo_user "$user" "$repo"
    result=$?
    ;;
  gitlab)
    __gitlab_delete_repo "$user" "$repo"
    result=$?
    ;;
  gitea | private)
    __gitea_delete_repo "$user/$repo"
    result=$?
    ;;
  *)
    printf_red "‚ùå Unknown platform: $platform"
    result=1
    ;;
  esac

  return $result
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__backup_repos() {
  local dirs="${*:-$GITADMIN_DEFAULT_GIT_DIR_GITHUB/*/*}"
  [ -d "$GITADMIN_DEFAULT_GIT_DIR_GITHUB" ] || return
  for d in $dirs; do
    if [ -n "$GITADMIN_BACKUP_ORG" ]; then
      local mktemp="$(mktemp 'XXXXXXXXXXXXXXXX')"
      local org_name="$(echo "$d" | awk -F '/' '{print $(NF-1)}')"
      local repo_name="$(echo "$d" | awk -F '/' '{print $NF}')"
      printf_cyan "üíæ Backing up ${d//$HOME/~} to $GITADMIN_BACKUP_URL/$GITADMIN_BACKUP_ORG/$org_name-$repo_name"
      mkdir -p ""$GITADMIN_TEMP_DIR/$mktemp""
      git clone -q "$d" "$GITADMIN_TEMP_DIR/$mktemp"
      $0 setup --automated --dir "$GITADMIN_TEMP_DIR/$mktemp" "$GITADMIN_BACKUP_URL/$GITADMIN_BACKUP_ORG/$org_name-$repo_name" 2>/dev/null >/dev/null
      rm -Rf "${GITADMIN_TEMP_DIR:?}/$mktemp"
      printf_green "‚úÖ Backup completed"
    else
      printf_cyan "üíæ Backing up ${d//$HOME/~} to $GITADMIN_BACKUP_URL/$GITADMIN_BACKUP_ORG/$org_name/$repo_name"
      rm -Rf "${GITADMIN_BACKUP_DIR:?}/$org_name/$repo_name"
      mkdir -p "$GITADMIN_BACKUP_DIR/$org_name/$repo_name"
      [ -d "$d/.git" ] && git clone -q "$d" "$GITADMIN_BACKUP_DIR/$org_name/$repo_name"
      printf_green "‚úÖ Backup completed"
    fi
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_custom() {
  local set_git_dir="$1" && shift 1 || set_git_dir="${GITADMIN_CWD:-$PWD}"
  git -C "$set_git_dir" "$@" -q 2>/dev/null
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_update_all() {
  local token="$GITADMIN_PRIVATE_AUTH_TOKEN"
  if [ "$1" = "all" ]; then
    org="$2"
    repos="$(curl -q -LSsf -X GET -H 'Content-Type: application/json' -H "Authorization: token $token" "$GITADMIN_PERSONAL_GIT_HOST/api/v1/users/$org/repos" 2>/dev/null | __jq -r '.[].full_name' | sort -u | grep '^' || false)"
    shift 2
    [ -n "$repos" ] || printf_exit "Failed to get repos for user: $org"
    [ -n "$1" ] && [ -n "$org" ] || __update_usage
    printf_yellow "üîç Getting repos for user $org"
    for repo in $repos; do
      __gitea_update_repo "$repo" "$@"
    done
  else
    __gitea_update_repo "$@"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_update_repo() {
  local repo=""
  local data=""
  local json=""
  local exitCode=0
  local json_message=""
  local token="$GITADMIN_PRIVATE_AUTH_TOKEN"
  local host="$GITADMIN_PERSONAL_GIT_HOST"
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __update_usage
  echo "$1" | grep -q '.*./.*.' || echo "$1" | grep -q '.*.=.*.' || __update_usage
  repo="$1" && shift 1
  name="$(echo "$repo" | sed 's|/|_|g')"
  while :; do
    case "$1" in
    *=*)
      data="$(echo "$1" | awk -F '=' '{print $1}')"
      value="$(echo "$1" | awk -F '=' '{print $2}')"
      if [ "$value" = "true" ] || [ "$value" = "false" ]; then
        json='"'$data'":'$value''
      else
        json='"'$data'": "'$value'"'
      fi
      shift 1
      update="$(printf '%s' "{${json//\"\"/\",\"}}")"
      curl -q -LSsf -X PATCH -H "Content-Type: application/json" -H "Authorization: token $token" --data "$update" "$host/api/v1/repos/$repo" >"$GITADMIN_LOG_DIR/$name.log" 2>&1
      if cat "$GITADMIN_LOG_DIR/$name.log" | grep "$data" | grep -q "$value"; then
        json_message="$json"
        exitCode=$((exitCode + 0))
        message="$(printf '%s' "$(printf_green "success:")")"
      else
        json_message="$json"
        exitCode=$((exitCode + 1))
        message="$(printf '%s' "$(printf_red "failed:")")"
      fi
      json_message="$(printf '%s' "$json_message" | sed 's| $||g;s| |, |g')"
      json_message="$(printf '%s' "{${json_message//\"\"/\",\"}}")"
      printf '%s %s ' "$message" "$json_message"
      ;;
    *)
      break
      ;;
    esac
  done
  printf '%s\n' "- exitCode: $exitCode"
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_orgs() {
  local resp=""
  local token="$GITADMIN_PRIVATE_AUTH_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/orgs/$1/repos"
  resp="$(curl -q -LSsf -X 'GET' -H "Authorization: token $token" -H 'accept: application/json' "$url" 2>/dev/null | __jq -r '.[]' || false)"
  if [ -n "$resp" ]; then
    echo "$resp" | __jq
    exitCode=0
  else
    printf_red "‚ùå Failed to retrieve the list of repos for $1"
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_users() {
  local resp=""
  local token="$GITADMIN_PRIVATE_AUTH_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/users/$1/repos"
  resp="$(curl -q -LSsf -X 'GET' -H "Content-Type: application/json" -H "Authorization: token $token" -H 'accept: application/json' "$url" 2>/dev/null | __jq -r '.[]' || __gitea_orgs "$1" "silent" || false)"
  if [ -n "$resp" ]; then
    [ -n "$2" ] || echo "$resp" | __jq
    exitCode=0
  else
    [ -n "$2" ] || printf_red "‚ùå Failed to retrieve the list of repos for $1"
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_users_orgs() {
  local resp=""
  local token="$GITADMIN_PRIVATE_AUTH_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/users/$1/orgs"
  resp="$(curl -q -LSsf -X 'GET' -H "Authorization: token $token" -H "Content-Type: application/json" -H 'accept: application/json' "$url" 2>/dev/null | __jq -r '.' || false)"
  if [ -n "$resp" ]; then
    [ -n "$2" ] || echo "$resp" | __jq
    exitCode=0
  else
    [ -n "$2" ] || printf_red "‚ùå Failed to retrieve the list of orgs for $1"
    exitCode=1
  fi
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_delete_repo() {
  local repo_path="$1"
  local token="$GITADMIN_PRIVATE_AUTH_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/repos/$repo_path"

  # Use proper DELETE method for Gitea API
  resp="$(curl -q -LSsf -X DELETE -H "Authorization: token $token" "$url" 2>&1)"

  if [ $? -eq 0 ]; then
    printf_green "üå± Deletion of $GITADMIN_PERSONAL_GIT_HOST/$repo_path successful üå±"
    return 0
  elif echo "$resp" | grep -q '404'; then
    # 404 means repo doesn't exist - treat as success
    printf_green "üå± Repository $repo_path already removed üå±"
    return 0
  else
    printf_red "üí¢ Deletion of $GITADMIN_PERSONAL_GIT_HOST/$repo_path failed üí¢"
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_create_repo() {
  local repo_name="$1"
  local description="${2:-}"
  local visibility="${3:-public}"
  local resp=""
  local token="$GITADMIN_PRIVATE_AUTH_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/user/repos"
  local json_data=""

  [ -f "$GITADMIN_CWD/DESCRIPTION" ] && description="$(<"$GITADMIN_CWD/DESCRIPTION")" || description="${description:-Repository for $repo_name}"

  # Determine visibility
  if [ "$GITADMIN_REPO_VISIBLE" = "no" ] || [ "$visibility" = "private" ]; then
    visibility="private"
  else
    visibility="public"
  fi

  # Generate JSON using the template function
  json_data="$(__generate_repo_json "$repo_name" "$description" "" "$visibility" "gitea")"

  # Make the API call and capture the full response
  resp="$(curl -q -LSs -X 'POST' -H "Authorization: token $token" -H "Content-Type: application/json" -H 'accept: application/json' --data "$json_data" "$url" 2>/dev/null)"

  # Check if response contains an ID (successful creation) or if repo already exists
  if echo "$resp" | __jq -r '.id' 2>/dev/null | grep -q '^[0-9]'; then
    printf_cyan "üòª Success: $GITADMIN_PERSONAL_GIT_HOST/$GITADMIN_DEFAULT_USERNAME/$repo_name üòª"
    return 0
  elif echo "$resp" | grep -qi 'already exist\|name is reserved'; then
    printf_yellow "‚ö†Ô∏è Repository $repo_name already exists ‚ö†Ô∏è"
    return 0
  else
    printf_yellow "üëø Creation of $GITADMIN_PERSONAL_GIT_HOST/$GITADMIN_DEFAULT_USERNAME/$repo_name failed üëø"
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_create_org() {
  local token="$GITADMIN_PRIVATE_AUTH_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/admin/users/$1/orgs" \
    [ -f "$GITADMIN_CWD/DESCRIPTION" ] && description="$(<"$GITADMIN_CWD/DESCRIPTION")" || description="${2:-}"
  private="${5:-false}"
  [ "$GITADMIN_REPO_VISIBLE" = "no" ] && private="true" || private="${private:-false}"
  curl -q -LSsf -X 'POST' -H "Authorization: token $token" -H 'Content-Type: application/json' -H 'accept: application/json' --data "{ \"username\":\"$2\",\"description\":\"$3\",\"website\":\"$4\",\"visibility\":$private }" "$url" 2>/dev/null | __jq -r '.'
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_branch() {
  local token="$GITADMIN_PRIVATE_AUTH_TOKEN"
  local url="$GITADMIN_PERSONAL_GIT_HOST/api/v1/repos/$1/branches"
  curl -q -LSsf -X 'POST' -H "Authorization: token $token" -H 'accept: application/json' -H 'Content-Type: application/json' --data "{ \"new_branch_name\":\"$3\",\"old_branch_name\":\"$2\" }" "$url" 2>/dev/null | __jq -r '.'
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# https://dev.to/nicolasboyer/migrate-all-of-your-repos-from-github-to-gitea-3fk
__github_to_gitea() {
  local GITHUB_USERNAME="$1"
  local GITHUB_ORG_NAME="$2"
  local GITEA_USERNAME="$3"
  local GITEA_ORG_NAME="$(echo "${4:-$2}" | tr '[:upper:]' '[:lower:]')"
  local GITEA_DOMAIN="$GITADMIN_PERSONAL_GIT_HOST"
  local GITHUB_TOKEN="$GITADMIN_GITHUB_AUTH_TOKEN"
  local GITEA_TOKEN="$GITADMIN_PRIVATE_AUTH_TOKEN"
  local eCode=0 REPO_NAME="" GET_REPOS=""
  [ $# -ge 3 ] || __printf_help "Usage: [github_user] [github_org] [gitea_user] [gitea_org]"
  [ -n "$GITHUB_USERNAME" ] || printf_exit "Please provide the the username of the org owner on github"
  [ -n "$GITHUB_ORG_NAME" ] || printf_exit "Please provide the github org/username"
  [ -n "$GITEA_USERNAME" ] || printf_exit "Please provide the the username of the org owner on gitea"
  [ -n "$GITEA_ORG_NAME" ] || printf_exit "Please provide the gitea org/username"
  [ -n "$GITEA_DOMAIN" ] || printf_exit "Please provide the gitea url: GITADMIN_PERSONAL_GIT_HOST"
  [ -n "$GITHUB_TOKEN" ] || printf_exit "Please provide the github API Token: GITADMIN_GITHUB_AUTH_TOKEN"
  [ -n "$GITEA_TOKEN" ] || printf_exit "Please provide the gitea API Token: GITADMIN_PRIVATE_AUTH_TOKEN"
  if curl -q --retry 2 --retry-max-time 3 --retry-delay 3 -LSsf "$GITEA_DOMAIN/api/v1/orgs/$GITEA_ORG_NAME" 2>/dev/null | __jq -rc '.name' | grep -q "$GITEA_ORG_NAME"; then
    printf_green "üÜóüÜó $GITEA_ORG_NAME already exists üÜóüÜó"
  else
    GET_ORG="$(__curl_gh_api -f "https://api.github.com/orgs/$GITHUB_ORG_NAME" | __jq -r '.' || grep '^' || echo "")"
    ORG_LOC="$(echo "$GET_ORG" | __jq -rc '.location' | grep -v 'null' | grep '^' || echo "USA")"
    ORG_NAME="$(echo "$GET_ORG" | __jq -rc '.name' | grep -v 'null' | grep '^' || echo "$GITEA_ORG_NAME")"
    ORG_SITE="$(echo "$GET_ORG" | __jq -rc '.blog' | grep -v 'null' | grep '^' || echo "$GITEA_DOMAIN/$GITEA_ORG_NAME")"
    ORG_DESC="$(echo "$GET_ORG" | __jq -rc '.description' | sed 's|"|\"|g' | grep -v 'null' | grep '^' || echo "$GITEA_ORG_NAME")"
    echo "$ORG_SITE" | grep -q 'http.*://' || ORG_SITE="https://$ORG_SITE"
    curl -q -LSsf -X 'POST' ''$GITEA_DOMAIN'/api/v1/orgs?token='$GITEA_TOKEN'' -H 'accept: application/json' -H 'Content-Type: application/json' --data "{ \"username\": \"$GITEA_ORG_NAME\", \"description\": \"$ORG_DESC\", \"full_name\": \"$ORG_NAME\", \"location\": \"$ORG_LOC\", \"repo_admin_change_team_access\": true, \"visibility\": \"public\", \"website\": \"$ORG_SITE\" }" >"$GITADMIN_TEMP_FILE" 2>&1 || false
    [ $? -eq 0 ] && printf_blue "üòπüòπ Created the organization: $GITEA_ORG_NAME which is owned by $GITEA_USERNAME üòπüòπ" || printf_exit 5 1 "üòøüòø Failed to create $GITEA_ORG_NAME: $(cat "$GITADMIN_TEMP_FILE" | grep 'curl: ' | sed 's|curl:.*) ||g' | head -n1) üòøüòø \n"
  fi
  GET_REPOS="$(__curl_gh_api "https://api.github.com/orgs/$GITHUB_ORG_NAME/repos?per_page=2000" | __jq -r '.[].html_url')"
  [ -n "$GET_REPOS" ] || printf_exit 1 2 "üíîüíî No repos exist for $GITHUB_ORG_NAME üíîüíî"
  for URL in $GET_REPOS; do
    REPO_NAME=$(echo "$URL" | sed 's|https://github.com/'$GITHUB_ORG_NAME'/||g' | tr '[:upper:]' '[:lower:]' | grep '^' || return)
    REPO_INFO="$(__curl_gh_api -f "https://api.github.com/repos/$GITHUB_ORG_NAME/$REPO_NAME")"
    gitea_url="$GITEA_DOMAIN/$GITEA_ORG_NAME/$REPO_NAME"
    private="$(echo "$REPO_INFO" | __jq -r '.private' | grep -v 'null' | grep '^' || echo "false")"
    website="$(echo "$REPO_INFO" | __jq -r '.homepage' | grep -v 'null' | grep '^' || echo "$gitea_url")"
    avatar="$(echo "$REPO_INFO" | __jq -r '.owner.avatar_url' | grep -v 'null' | grep '^' || echo "")"
    description="$(echo "$REPO_INFO" | __jq -r '.description' | grep -v 'null' | grep '^' || echo "$REPO_NAME")"
    [ -f "$GITADMIN_CWD/DESCRIPTION" ] && description="$(<"$GITADMIN_CWD/DESCRIPTION")" || description="${description:-}"
    [ "$GITADMIN_REPO_VISIBLE" = "no" ] && private="true" || private="${private:-false}"
    if curl -q -LSsf -X 'GET' "$GITEA_DOMAIN/api/v1/repos/$GITEA_ORG_NAME/$REPO_NAME" -H 'accept: application/json' 2>/dev/null | __jq -r '.full_name' | grep -q "$REPO_NAME"; then
      printf_yellow "üîÄüîÄ The repo: $GITEA_ORG_NAME/$REPO_NAME already exists üîÄüîÄ"
      curl -q -LfSs -X PATCH -u "$GITEA_USERNAME:$GITEA_TOKEN" "$GITEA_DOMAIN/api/v1/repos/$GITEA_ORG_NAME/$REPO_NAME" -H 'accept: application/json' -H 'Content-Type: application/json' -d "{ \"repo_name\": \"$REPO_NAME\", \"repo_owner\": \"$GITEA_ORG_NAME\", \"auth_username\": \"$GITHUB_USERNAME\", \"auth_token\": \"$GITHUB_TOKEN\", \"clone_addr\": \"$URL\", \"description\": \"$description\", \"website\": \"$website\", \"avatar_url\": \"$avatar\", \"issues\": true, \"labels\": true, \"lfs\": true, \"milestones\": true, \"mirror\": true, \"mirror_interval\": \"3600s\", \"private\": $private, \"pull_requests\": true, \"releases\": true, \"uid\": 0, \"wiki\": true , \"service\": \"git\" }" >"$GITADMIN_TEMP_FILE" 2>&1
      grep -qs 'updated_at' "$GITADMIN_TEMP_FILE" && printf_blue "üöÄüöÄ Successfully updated: $GITEA_ORG_NAME/$REPO_NAME üöÄüöÄ" || { printf_yellow "üò†üò†  $(cat "$GITADMIN_TEMP_FILE" | grep 'curl: ' | sed 's|curl:.*) ||g' | head -n1) üò†üò†" && eCode=$((eCode + 1)); }
    else
      printf_cyan "üöÄüöÄ Found $GITHUB_ORG_NAME/$REPO_NAME, importing... üöÄüöÄ"
      curl -q -LfSs --retry 2 --retry-max-time 3 --retry-delay 3 -X POST -u "$GITEA_USERNAME:$GITEA_TOKEN" "$GITEA_DOMAIN/api/v1/repos/migrate" -H 'accept: application/json' -H 'Content-Type: application/json' -d "{ \"repo_name\": \"$REPO_NAME\", \"repo_owner\": \"$GITEA_ORG_NAME\", \"auth_username\": \"$GITHUB_USERNAME\", \"auth_token\": \"$GITHUB_TOKEN\", \"clone_addr\": \"$URL\", \"description\": \"$description\", \"website\": \"$website\", \"avatar_url\": \"$avatar\", \"issues\": true, \"labels\": true, \"lfs\": true, \"milestones\": true, \"mirror\": true, \"mirror_interval\": \"3600s\", \"private\": $private, \"pull_requests\": true, \"releases\": true, \"uid\": 0, \"wiki\": true , \"service\": \"git\" }" >"$GITADMIN_TEMP_FILE" 2>&1
      grep -qs 'created_at' "$GITADMIN_TEMP_FILE" && printf_blue "üîΩ‚è´ Successfully imported to: $gitea_url ‚è´üîΩ" || { printf_yellow "‚ö†Ô∏è ‚ö†Ô∏è  $(cat "$GITADMIN_TEMP_FILE" | grep 'curl: ' | sed 's|curl:.*) ||g' | head -n1) ‚ö†Ô∏è ‚ö†Ô∏è" && eCode=$((eCode + 1)); }
      sleep 5
    fi
  done
  printf '\n'
  return $eCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitea_migrate_delete() {
  GITHUB_USERNAME="$1"
  GITHUB_ORG_NAME="$2"
  GITEA_USERNAME="$3"
  GITEA_ORG_NAME="${4:-$2}"
  GITEA_DOMAIN="$GITADMIN_PERSONAL_GIT_HOST"
  GITHUB_TOKEN="$GITADMIN_GITHUB_AUTH_TOKEN"
  GITEA_TOKEN="$GITADMIN_PRIVATE_AUTH_TOKEN"
  [ $# -le 3 ] || __printf_help "Usage: [github_user] [github_org] [gitea_user] [gitea_org]"
  [ -n "$GITHUB_USERNAME" ] || printf_exit "Please provide the the username of the org owner on github"
  [ -n "$GITHUB_ORG_NAME" ] || printf_exit "Please provide the github org/username"
  [ -n "$GITEA_USERNAME" ] || printf_exit "Please provide the the username of the org owner on gitea"
  [ -n "$GITEA_ORG_NAME" ] || printf_exit "Please provide the gitea org/username"
  [ -n "$GITEA_DOMAIN" ] || printf_exit "Please provide the gitea url: GITADMIN_PERSONAL_GIT_HOST"
  [ -n "$GITHUB_TOKEN" ] || printf_exit "Please provide the github API Token: GITADMIN_GITHUB_AUTH_TOKEN"
  [ -n "$GITEA_TOKEN" ] || printf_exit "Please provide the gitea API Token: GITADMIN_PRIVATE_AUTH_TOKEN"
  GET_REPOS=$(curl -H 'Accept: application/vnd.github.v3+json' -u $GITHUB_USERNAME:$GITHUB_TOKEN -s "https://api.github.com/orgs/$GITHUB_ORG_NAME/repos?per_page=1000" | __jq -r '.[].html_url')
  for URL in $GET_REPOS; do
    REPO_NAME="${URL//*\/$GITHUB_ORG_NAME/}"
    echo "Deleting $REPO_NAME if it exists on Gitea ..."
    curl -q -LSsf -X DELETE -u $GITEA_USERNAME:$GITEA_TOKEN "$GITEA_DOMAIN/api/v1/repos/$GITEA_ORG_NAME/$name" -H "accept: application/json"
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitlab_orgs() {
  printf_exit "Not implemented yet"
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__gitlab_branch() {
  curl -q -LSsf -X POST -H "PRIVATE-TOKEN: $GITADMIN_GITLAB_AUTH_TOKEN" --url "https://gitlab.com/api/v4/projects/$1" --data "default_branch=${GITADMIN_DEFAULT_BRANCH:-$2}" 2>/dev/null | __jq -r '.'
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Create a GitLab repository
__gitlab_create_repo() {
  local user="$1"
  local repo="$2"
  local description="${3:-Repository for $repo}"
  local homepage="${4:-}"
  local visibility="${5:-public}"
  local url="https://gitlab.com/api/v4/projects"
  local namespace_id=""
  local json_data=""
  local resp=""

  [ -z "$GITADMIN_GITLAB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITLAB_AUTH_TOKEN is not set" && return 1

  # Get namespace ID for the user/organization
  namespace_id="$(curl -q -LSsf -H "PRIVATE-TOKEN: $GITADMIN_GITLAB_AUTH_TOKEN" \
    "https://gitlab.com/api/v4/namespaces?search=$user" 2>/dev/null |
    __jq -r ".[] | select(.path==\"$user\") | .id" 2>/dev/null)"

  # If no namespace found, try to use user's namespace
  if [ -z "$namespace_id" ]; then
    namespace_id="$(curl -q -LSsf -H "PRIVATE-TOKEN: $GITADMIN_GITLAB_AUTH_TOKEN" \
      "https://gitlab.com/api/v4/user" 2>/dev/null |
      __jq -r '.namespace_id' 2>/dev/null)"
  fi

  [ -z "$namespace_id" ] && printf_red "‚ùå Could not find namespace for $user" && return 1

  # Generate JSON for GitLab
  json_data="$(__generate_repo_json "$repo" "$description" "$homepage" "$visibility" "gitlab")"

  # Add namespace_id to the JSON
  json_data="$(echo "$json_data" | __jq ". + {namespace_id: $namespace_id}")"

  # Create the repository
  resp="$(curl -q -LSsf -X POST \
    -H "PRIVATE-TOKEN: $GITADMIN_GITLAB_AUTH_TOKEN" \
    -H "Content-Type: application/json" \
    --data "$json_data" \
    "$url" 2>/dev/null)"

  if echo "$resp" | __jq -r '.id' &>/dev/null; then
    printf_cyan "üòª Success: https://gitlab.com/$user/$repo üòª"
    return 0
  elif echo "$resp" | grep -q 'has already been taken'; then
    printf_yellow "‚ö†Ô∏è Repository $user/$repo already exists ‚ö†Ô∏è"
    return 0
  else
    printf_yellow "üëø Creation of https://gitlab.com/$user/$repo failed üëø"
    if [ -n "$resp" ]; then
      echo "$resp" | __jq -r '.message // .error' 2>/dev/null | printf_readline
    fi
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Delete a GitLab repository
__gitlab_delete_repo() {
  local user="$1"
  local repo="$2"
  local project_id=""
  local resp=""

  [ -z "$GITADMIN_GITLAB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITLAB_AUTH_TOKEN is not set" && return 1

  # URL encode the project path
  project_id="$(echo "$user/$repo" | sed 's/\//%2F/g')"

  # Delete the repository
  resp="$(curl -q -LSsf -X DELETE \
    -H "PRIVATE-TOKEN: $GITADMIN_GITLAB_AUTH_TOKEN" \
    "https://gitlab.com/api/v4/projects/$project_id" 2>&1)"

  if [ $? -eq 0 ]; then
    printf_green "üå± Deletion of https://gitlab.com/$user/$repo successful üå±"
    return 0
  elif echo "$resp" | grep -q '404'; then
    # 404 means repo doesn't exist - treat as success
    printf_green "üå± Repository $user/$repo already removed üå±"
    return 0
  else
    printf_red "üí¢ Deletion of https://gitlab.com/$user/$repo failed üí¢"
    if [ -n "$resp" ]; then
      echo "$resp" | __jq -r '.message // .error' 2>/dev/null | printf_readline
    fi
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__update_repo_usage() {
  __printf_help 'Usage: '$APPNAME' github update repo "[description,homepage,visibility]=value"'
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__update_github_repo() {
  local org=""
  local repo=""
  local data=""
  local json=""
  local exitCode=0
  local exitStatus=0
  local message_bad=""
  local message_good=""
  local json_message=""
  local show_message=""
  local token="$GITADMIN_GITHUB_AUTH_TOKEN"
  local host="https://api.github.com"
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __update_usage
  echo "$1" | grep -q '.*./.*.' || echo "$1" | grep -q '.*.=.*.' || __update_usage
  [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD is not a valid repo"
  org="$(echo "$GITADMIN_CWD" | awk -F'/' '{print $(NF-1)}')"
  repo="$(echo "$GITADMIN_CWD" | awk -F'/' '{print $NF}')"
  name="$(echo "$repo" | sed 's|/|_|g')"
  while :; do
    case "$1" in
    *=*)
      data="$(echo "$1" | awk -F '=' '{print $1}')"
      value="$(echo "$1" | awk -F '=' '{print $2}')"
      if [ "$value" = "true" ] || [ "$value" = "false" ]; then
        json='"'$data'":'$value''
      else
        json='"'$data'":"'$value'"'
      fi
      shift 1
      update="$(printf '%s' "$json")"
      curl -q -LSsf -X PATCH -H "Content-Type: application/json" -H "Authorization: token $token" --data "{$update}" "$host/repos/$org/$repo" >"$GITADMIN_LOG_DIR/$name.log" 2>&1
      if cat "$GITADMIN_LOG_DIR/$name.log" | grep "$data" | grep -q "$value"; then
        exitStatus=0
        json_message="$update"
        message_good="$(printf '%s' "$(printf_red "failed: $json_message")")"
        exitCode=$((exitCode + 0))
      else
        exitStatus=1
        json_message="$update"
        message_bad="$(printf '%s' "$(printf_red "failed: $json_message")")"
        exitCode=$((exitCode + 1))
      fi
      if [ "$exitStatus" -ne 0 ]; then
        printf '%s\n' "$message_bad"
      else
        message="$(printf '%s' "$(printf_green "Success:")")"
        show_message+="$(printf '%s' "$json_message," | sed 's| $||g;s| ,$| |g')"
      fi
      ;;
    *)
      break
      ;;
    esac
  done
  printf '%s %s' "$message" "{$show_message}" | sed 's|,}$|}|g'
  [ $exitCode -eq 0 ] || printf '\n%s' "Errors Observed - exitCode: $exitCode"
  printf '\n'
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#set folder name based on githost
__git_hostname() { echo "$@" | sed -e "s/[^/]*\/\/\([^@]*@\)\?\([^:/]*\).*/\2/" | awk -F. '{print $(NF-1) "." $NF}' | sed 's#\..*##g'; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#setup directory structure
__git_username_repo() {
  local re=""
  protocol="" separator="" hostname="" username="" userrepo="" githostname=""
  url="$1"
  re="^(http|https|git|ssh)(:\/\/|@)([^\/:]+)[\/:]([^\/:]+)\/(.+)$"
  githostname="$(__git_hostname $url 2>/dev/null)"
  if [ -d "$url" ]; then
    protocol=
    separator=
    folder="local"
    hostname=localhost
    userrepo="$(__basename "$url")"
    username="$(__basename "$(dirname "$url")")"
    echo "$username" | grep -q '^.$' && username="$USER"
    GITADMIN_NEW_PROJECT_DIR="${GITADMIN_DEFAULT_PROJECT_DIR:-$HOME/Projects}/$folder/$username-$userrepo"
  elif [[ $url =~ $re ]]; then
    protocol=${BASH_REMATCH[1]}
    separator=${BASH_REMATCH[2]}
    hostname=${BASH_REMATCH[3]}
    username=${BASH_REMATCH[4]}
    userrepo=${BASH_REMATCH[5]}
    folder=$githostname
    GITADMIN_NEW_PROJECT_DIR="${GITADMIN_DEFAULT_PROJECT_DIR:-$HOME/Projects}/$folder/$username/$userrepo"
  else
    return 1
  fi
  export url protocol separator hostname username userrepo GITADMIN_NEW_PROJECT_DIR
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# issues API
__api_issues_token() {
  local git_repo
  { [ $# = 2 ] && git_repo="$1/$2"; } || { [ $# = 1 ] && git_repo="$1"; }
  ISSUE_HTML="https://github.com/$git_repo/issues"
  ISSUE_API="https://api.github.com/repos/$git_repo/issues"
  export ISSUE_HTML ISSUE_API
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# call the issues api
__api_issues() {
  local resp=""
  resp="$(__curl_gh_api -X ${1:-GET} "${2:-$ISSUE_API}" 2>/dev/null)"
  [ -n "$resp" ] && printf "%s" "$resp" || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Gist API
__api_gist() {
  local user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  __curl_gh_api "https://api.github.com/users/$user/gists"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set Message for token - user
__api_user_token() {
  local user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  export GITHUBAPIPAGES="$(__github_api_user_page_count "$user")"
  export MESSAGE="Getting the repos for user: $user"
  export GITHUBAPIREPO="https://api.github.com/user/repos?per_page=1000&sort=full_name&type=owner"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User api
__api_user() {
  local user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  __api_user_token "$user"
  __urlverify "https://api.github.com/users/$user" || return 1
  __curl_gh_api "$GITHUBAPIREPO"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set Message for token - org
__api_org_token() {
  local user="${1:-}" org=""
  export GITHUBAPIPAGES="$(__github_api_org_page_count "$user")"
  export GITHUBAPIREPO="https://api.github.com/orgs/$user/repos?per_page=1000&sort=full_name"
  export MESSAGE="Getting the repos for org: $user"
  org="$(__curl_gh_api "$GITHUBAPIREPO" | __jq -r '.[]|.name' | grep -v '^$' | grep '^' || __api_user "$user" | __jq -r '.[]|.name' | grep -v '^$' | grep '^')"
  COUNT="$(printf '%s' "$org" | grep -v '^$' | wc -l | grep '^')"
  if [ -n "$org" ]; then
    [ "$COUNT" != 0 ] && printf '%s\n' "$org" | sort -u >"$GITADMIN_TEMP_FILE" || return 1
  else
    printf_yellow "‚õî No repos found for $user ‚õî"
    echo ""
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Organization API
__api_org() {
  local user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  __api_org_token "$user" || return 1
  __urlverify "$GITHUBAPIREPO" || return 1
  __curl_gh_api "$GITHUBAPIREPO"
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# pull function
__git_pull() {
  local git_dir="" args="" regex=""
  [ -n "$1" ] && [ -d "$1/.git" ] && git_dir="$1" && shift 1 || git_dir="$GITADMIN_CWD"
  args="$*"
  regex="(https?|ftp|file|git|ssh)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]"
  if [[ "$(__git_remote_origin "$git_dir")" =~ $regex ]]; then
    if __am_i_online; then
      git -C "$git_dir" pull $args -f -q &>/dev/null && return 0 || return 1
    else return 1; fi
  else
    git -C "$git_dir" pull $args -f -q &>/dev/null && return 0 || return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Push function
__git_push() {
  local git_dir="" args="" regex=""
  [ -n "$1" ] && [ -d "$1/.git" ] && git_dir="$1" && shift 1 || git_dir="$GITADMIN_CWD"
  args="$*"
  regex="(https?|ftp|file|git|ssh)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]"
  [ -f "$git_dir/.no_push" ] || return 0
  if [[ "$(__git_remote_origin "$git_dir")" =~ $regex ]]; then
    if __am_i_online; then
      git -C "$git_dir" push $args -q &>/dev/null && return 0 || return 1
    else
      return 1
    fi
  else
    git -C "$git_dir" push $args -q &>/dev/null && return 0 || return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Clone function
__git_clone() {
  local git_url="" git_dir="" args="" regex="" exitCode=0
  git_url="$1" && shift 1
  git_dir="$1" && shift 1
  [ -n "$git_dir" ] || git_dir="$GITADMIN_CWD"
  args="$*" && shift $#
  regex="(http|https|ftp|file|git|ssh)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]"
  if [[ "$git_url" =~ $regex ]]; then
    if __am_i_online; then
      [ -d "$git_dir" ] &&
        git -C "$git_dir" pull -q &>/dev/null ||
        git clone "$git_url" "$git_dir" -q $args &>/dev/null
      exitCode=$?
    else
      return 1
    fi
  else
    [ -d "$git_dir" ] &&
      git -C "$git_dir" pull -q &>/dev/null ||
      git clone "$git_url" "$git_dir" -q $args &>/dev/null
    exitCode=$?
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__clone_success() {
  exitCode=${1:-$?}
  git_dir="${2:-$1}"
  [ -n "$git_dir" ] || git_dir="$GITADMIN_CWD"
  if [ -d "$git_dir/.git" ] && [ $exitCode = 0 ]; then
    printf_cyan "Successfully cloned to $git_dir"
  else
    printf_red "Failed to clone $git_url"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Creates a README.md file if one doesn't exist
__create_new_readme_template() {
  local git_dir="" author="" GitBaseDir="" BaseDir=""
  [ "$NOREADME" = "yes" ] && return 0
  git_dir="${1:-$GITADMIN_CWD}"
  if [ -f "$(command -v gen-readme)" ] && [ ! -f "$git_dir/README.md" ]; then
    gen-readme "$git_dir" "$(basename -- "${GITADMIN_DEFAULT_README:-default}")" "README.md" &>/dev/null
  else
    author="$(__git_globaluser)"
    GitBaseDir="$(__git_top_dir "$git_dir")"
    BaseDir="${GitBaseDir##*/}"
    [ -f "$CASJAYSDEVDIR/templates/readmes/projects/default.md" ] &&
      cat "$CASJAYSDEVDIR/templates/readmes/projects/default.md" >"$git_dir/README.md"
    [ -f "$git_dir/README.md" ] && __sed -i "s#ProjectName#${BaseDir}#g" "$git_dir/README.md"
    [ -f "$git_dir/README.md" ] && __sed -i "s#AuthorName#${author}#g" "$git_dir/README.md"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Creates a license if a LICENSE.md file doesn't exist
__create_new_license() {
  local git_dir="" author="" year=""
  [ "$NOLICENSE" = "yes" ] && return 0
  git_dir="${1:-$GITADMIN_CWD}"
  if [ -f "$(command -v gen-license)" ] && [ ! -f "$git_dir/LICENSE.md" ]; then
    gen-license "$git_dir" "$(basename -- "$GITADMIN_DEFAULT_LICENSE")" &>/dev/null
  else
    author="$(__git_globaluser)"
    year="$(date +'%Y')"
    [ -f "$GITADMIN_DEFAULT_LICENSE" ] && cat "$GITADMIN_DEFAULT_LICENSE" >"$git_dir/LICENSE.md"
    [ -f "$git_dir/LICENSE.md" ] && __sed -i "s#CURYEAR#${year}#g" "$git_dir/LICENSE.md"
    [ -f "$git_dir/LICENSE.md" ] && __sed -i "s#AuthorName#${author}#g" "$git_dir/LICENSE.md"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check if input is a url
__do_not_add_a_url() {
  local string="" regex=""
  string="$1"
  regex="(http|https|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]"
  if [[ "$string" =~ $regex ]]; then
    printf_red "Do not provide the full url"
    printf_red "only provide the username/repo"
    exit 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# The initialize git function
__run_git_init() {
  local GITADMIN_EXITCODE=0 git_dir="" git_push="" git_confirm="" git_confirm_repo=""
  git_dir="${1:-$GITADMIN_CWD}"
  git_remote_repo="${2:-$git_remote_repo}"
  git_repo="${git_remote_repo:-$git_repo}"
  git_push=""
  git_confirm=""
  git_confirm_repo=""
  [ "$GITADMIN_SETUP_PUSH" = "no" ] && git_push="no"
  if [ -n "$git_repo" ]; then
    if git -C "$git_dir" remote add origin "$git_repo" &>/dev/null; then
      printf_cyan "$(__strip_git_url "$git_repo") has been added"
    else
      printf_exit "Failed to add $git_repo"
    fi
    [ "$git_push" = "no" ] && return 0
    printf_read_question "3" "Should I push to the remote repo? [y/n]" "1" "git_push"
    if printf_answer_yes "$git_push"; then
      printf_read_question "3" "This will overwrite the repo if it exists. Continue? [y/n]" "1" "git_confirm_repo"
      if printf_answer_yes "$git_confirm_repo"; then
        if [ -f "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" ] && [ ! -L "$git_dir/.git/config" ]; then
          cp -Rf "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" "$git_dir/.git/config"
        fi
        [ -f "$git_dir/.no_push" ] || git -C "$git_dir" push -q -f --set-upstream origin "$GITADMIN_DEFAULT_BRANCH" &>/dev/null
        git -C "$git_dir" remote show origin 2>&1 | grep -q 'Repository not found' && git_push="n"
        [ "$git_push" = "n" ] || __git_push "$git_dir"
        GITADMIN_EXITCODE=$?
        if [ -d "$git_dir/.git" ] && [ "$GITADMIN_EXITCODE" = 0 ]; then
          [ "$git_push" = "n" ] && printf_yellow "The remote repository wasn't found: not pushing" || __git_push "$git_dir"
          GITADMIN_EXITCODE=0
        else
          printf_red "Push to $git_repo has failed"
          GITADMIN_EXITCODE=1
        fi
      else
        printf_yellow "Not pushing due to user canceling"
        GITADMIN_EXITCODE=1
      fi
    else
      printf_yellow "Not pushing due to user canceling"
      GITADMIN_EXITCODE=1
    fi
  else
    printf_red "No remote repo specified"
    GITADMIN_EXITCODE=1
  fi
  return ${GITADMIN_EXITCODE:-$?}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__split_create_repo() {
  local repo="$1"
  local platform=""
  local username=""
  local reponame=""
  local visibility="${GITADMIN_REPO_VISIBILITY:-private}"

  # Detect platform from URL
  if echo "$repo" | grep -q 'github.com'; then
    platform="github"
  elif echo "$repo" | grep -q 'gitlab.com'; then
    platform="gitlab"
  elif echo "$repo" | grep -q "$GITADMIN_PERSONAL_GIT_HOST"; then
    platform="gitea"
  else
    platform="${GITADMIN_DEFAULT_PLATFORM:-github}"
  fi

  # Parse username and repo name
  if check_uri "$repo" || echo "$repo" | grep -q '\..*/.*/.*/*' || echo "$repo" | __test_if_url -q; then
    username="$(echo "$repo" | sed 's|.*//||g' | awk -F'/' '{print $(NF-1)}' | grep '^')"
    reponame="$(__strip_git_url "$(echo "$repo" | sed 's|.*//||g' | awk -F'/' '{print $NF}' | grep '^')")"
  elif echo "$repo" | grep -q '/'; then
    username="$(echo "$repo" | awk -F'/' '{print $1}' | grep '^')"
    reponame="$(__strip_git_url "$(echo "$repo" | awk -F'/' '{print $2}' | grep '^')")"
  else
    username="$1"
    reponame="$2"
  fi

  if [ -n "$username" ] && [ -n "$reponame" ]; then
    __universal_repo_create "$platform" "$username" "$reponame" "Repo for $reponame" "$visibility" "" &>/dev/null
    return $?
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup a new git repo
__run_git_setup() {
  local GITADMIN_EXITCODE=0 git_dir="" git_continue="" git_reuse="" git_version_file=""
  git_dir="$(__basedir "$GITADMIN_CWD/.git" | grep -v '^$' | grep '^')"
  git_continue="${continue:-}"
  git_reuse="${reuse:-}"
  git_version_file="$GITADMIN_DEFAULT_VERSION_FILE"
  git_version_fmt="$GITADMIN_DEFAULT_VERSION_FORMAT"
  remote_repo="${2:-$1}"
  git_prev="${remote_repo:-$(__git_remote_push "$GITADMIN_CWD")}"
  GITADMIN_SETUP_MESSAGE="${GITADMIN_SETUP_MESSAGE:-$GITCOMMIT_MESSAGE}"
  GITCOMMIT_MESSAGE="${GITADMIN_SETUP_MESSAGE:- ü¶àüè†üêú‚ùó Initial Commit ‚ùóüêúü¶àüè† }"
  show_git_repo="$(__git_repobase "$git_dir")"
  printf_green "üå± Initializing the repo in $git_dir"
  # Determine default repo based on platform preference
  if [ -z "$git_prev" ]; then
    local default_user="$(basename -- "$(dirname $GITADMIN_CWD)")"
    local default_repo="$(basename -- "$GITADMIN_CWD")"
    local default_platform="${GITADMIN_DEFAULT_PLATFORM:-github}"

    # Keep git_prev as simple user/repo format
    git_prev="$default_user/$default_repo"
  fi
  [ -f "$git_dir/.gitattributes" ] || gen-gitattr $git_dir save default lfs &>/dev/null
  [ -f "$git_dir/.gitignore" ] || gitignore "$git_dir" default --automated &>/dev/null
  if [ -d "$git_dir/.git" ]; then
    printf_error "This project already has git setup"
    if [ -n "$git_prev" ]; then
      printf_green "üîó Remote repo is: $(__strip_git_url "$git_prev")"
    fi
    printf_read_question "3" "Should I continue to reset this repo? [y/n]" "1" "git_continue"
    if printf_answer_yes "$git_continue"; then
      __rm_rf "$git_dir/.git"
    else
      printf_red "Initialization has failed due to user"
      exit 1
    fi
  fi
  [ -f "$git_version_file" ] && date +"$git_version_fmt" >"$git_version_file"
  ls "$git_dir/README"* >/dev/null 2>&1 || __create_new_readme_template "$git_dir"
  ls "$git_dir/LICENSE"* >/dev/null 2>&1 || __create_new_license "$git_dir"
  if git -C "$git_dir" init . |& __devnull && git -C "$git_dir" add . |& __devnull && git -C "$git_dir" commit -q -m "$GITCOMMIT_MESSAGE"; then
    printf_green "‚úÖ Success: $show_git_repo has been initialized"
  else
    printf_exit "Failed to initialize $show_git_repo"
  fi
  if [ -n "$git_prev" ]; then
    printf_read_question "3" "Should I reuse the remote repo ($git_prev)? [y/n] " "1" "git_reuse"
  else
    git_prev=""
    git_repo=""
    git_remote_repo=""
  fi
  echo "$git_prev" | __test_if_url -q || git_prev="https://$git_prev"
  if printf_answer_yes "$git_reuse"; then
    git_remote="y"
    git_remote_repo="$git_prev"
    __split_create_repo "$git_prev" || printf_exit "$git_prev repo does not exist"
    __run_git_init "$git_dir"
  else
    printf_read_question "3" "Should I add a remote repo? [y/n] " "1" "git_remote"
    if printf_answer_yes "$git_remote"; then
      if printf_read_question "3" "Should I use ${GREEN}($remote_repo_init) " "1" "reply"; then
        git_remote_repo="https://$remote_repo_init"
        reply=$git_remote_repo
      else
        printf_read_input "3" "Enter remote repo: " "120" "git_remote_repo"
      fi
      export git_remote_repo
      if __run_git_init "$git_dir" $git_remote_repo; then
        GITADMIN_EXITCODE=0
      else
        GITADMIN_EXITCODE=1
      fi
    else
      printf_yellow "You have decided not to add a remote repository"
    fi
  fi
  if [ $GITADMIN_EXITCODE -ne 0 ]; then
    printf_red "Initialization has failed"
  fi
  echo ""
  exit $GITADMIN_EXITCODE
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run git setup with no interactions
__run_git_setup_automated() {
  remote_repo="$1"
  git_dir="$(__basedir "$GITADMIN_CWD/.git" | grep -v '^$' | grep '^')"
  git_version_file="$GITADMIN_DEFAULT_VERSION_FILE"
  git_version_fmt="$GITADMIN_DEFAULT_VERSION_FORMAT"
  git_prev="${remote_repo:-$(__git_remote_push "$GITADMIN_CWD")}"
  GITADMIN_SETUP_MESSAGE="${GITADMIN_SETUP_MESSAGE:-$GITCOMMIT_MESSAGE}"
  GITCOMMIT_MESSAGE="${GITADMIN_SETUP_MESSAGE:- ü¶àüè†üêú‚ùó Initial Commit ‚ùóüêúü¶àüè† }"
  GITADMIN_EXITCODE=0
  printf_green "üå± Initializing the repo in $git_dir"
  # Determine default repo based on platform preference
  if [ -z "$git_prev" ]; then
    local default_user="$(basename -- "$(dirname $GITADMIN_CWD)")"
    local default_repo="$(basename -- "$GITADMIN_CWD")"
    local default_platform="${GITADMIN_DEFAULT_PLATFORM:-github}"

    # Keep git_prev as simple user/repo format
    git_prev="$default_user/$default_repo"
  fi
  [ -f "$git_dir/.gitattributes" ] || gen-gitattr $git_dir save default lfs &>/dev/null
  [ -f "$git_dir/.gitignore" ] || gitignore "$git_dir" default --automated &>/dev/null
  if [ -d "$git_dir/.git" ]; then
    printf_yellow "This project already has git setup"
    if [ -n "$git_prev" ]; then
      printf_green "üîó Remote repo is: $(__strip_git_url "$git_prev")"
    fi
    __rm_rf "$git_dir/.git"
  fi
  [ -f "$git_version_file" ] && date +"$git_version_fmt" >"$git_version_file"
  ls "$git_dir/README"* >/dev/null 2>&1 || __create_new_readme_template "$git_dir"
  ls "$git_dir/LICENSE"* >/dev/null 2>&1 || __create_new_license "$git_dir"
  if git -C "$git_dir" init . |& __devnull && git -C "$git_dir" add . |& __devnull && git -C "$git_dir" commit -q -m "$GITCOMMIT_MESSAGE"; then
    printf_green "‚úÖ Success: $(__git_repobase "$git_dir") has been initialized"
  else
    printf_exit "Failed to initialize $(__git_repobase "$git_dir")"
  fi
  # Build proper URLs for repo creation and git operations
  if echo "$git_prev" | __test_if_url -q; then
    repo_url="$git_prev"
    git_url="$git_prev"
  else
    # Build platform-specific URLs
    local default_platform="${GITADMIN_DEFAULT_PLATFORM:-github}"
    # Get display URL for the platform
    local display_url=""
    case "$default_platform" in
    github)
      display_url="https://github.com"
      ;;
    gitlab)
      display_url="https://gitlab.com"
      ;;
    gitea | private)
      display_url="https://${GITADMIN_PERSONAL_GIT_HOST#*://}"
      ;;
    *)
      display_url="https://github.com"
      ;;
    esac

    # Build URLs using display_url and git_prev (which should be user/repo format)
    if echo "$git_prev" | grep -q '/'; then
      repo_url="$display_url/$git_prev"
      git_url="$display_url/$git_prev.git"
    else
      printf_exit "Invalid repository format: $git_prev"
    fi
  fi
  __split_create_repo "$repo_url" || printf_exit "$git_prev repo does not exist"
  __run_git_init_automated "$git_dir" "$git_url"
  GITADMIN_EXITCODE=$?
  if [ $GITADMIN_EXITCODE -ne 0 ]; then
    printf_red "Initialization has failed"
  fi
  echo ""
  exit $GITADMIN_EXITCODE
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__run_git_init_automated() {
  git_dir="${1:-$GITADMIN_CWD}"
  git_repo="${2:-$git_prev}"
  if [ -n "$git_repo" ]; then
    if git -C "$git_dir" remote add origin "$git_repo" &>/dev/null; then
      printf_cyan "üå± $(__strip_git_url "$git_repo") has been added"
    else
      printf_exit "üî¥ Failed to add $git_repo"
    fi
    if [ -f "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" ] && [ ! -L "$git_dir/.git/config" ]; then
      cp -Rf "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" "$git_dir/.git/config"
    fi
    [ ! -f "$git_dir/.no_push" ] && git -C "$git_dir" push -q -f --set-upstream origin "$GITADMIN_DEFAULT_BRANCH" &>/dev/null || return
    git -C "$git_dir" remote show origin 2>&1 | grep -q 'Repository not found' && git_push="n"
    [ "$git_push" = "n" ] && printf_yellow "The remote repository wasn't found: not pushing" || __git_push "$git_dir"
    GITADMIN_EXITCODE=$?
    if [ -d "$git_dir/.git" ] && [ "$GITADMIN_EXITCODE" = 0 ]; then
      [ "$git_push" = "n" ] || printf_green "‚úÖ Successfully pushed to $(__strip_git_url "$git_repo")"
      GITADMIN_EXITCODE=0
    else
      printf_red "Push to $git_repo has failed"
      GITADMIN_EXITCODE=1
    fi
  else
    printf_red "No remote repo specified"
    GITADMIN_EXITCODE=1
  fi
  return ${GITADMIN_EXITCODE:-$?}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Makes a new jeckyll site
__make_newsite() {
  local site_dir="" site_folder="" site_repo=""
  site_dir="$HOME/Public/sites"
  site_folder="${1:-newsite}"
  site_repo="${2:-$GITADMIN_DOMAIN_TEMPLATE}"
  printf_green "Setting up site in: $site_dir/$site_folder"
  printf_blue "Using $site_repo as template"
  if __git_clone "$site_repo" "$site_dir/$site_folder"; then
    cd "$site_dir/$site_folder" || return 1
    __rm_rf "$site_dir/$site_folder/.git"
    [[ "$EDITOR" =~ code ]] && code . || "$EDITOR" _config.yml
    printf_pause "Prease any key when you are done."
    gitadmin --dir "$site_dir/$site_folder" setup
  else
    printf_error "Failed to clone $GITADMIN_DOMAIN_TEMPLATE"
    false
  fi
  exit $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Gets the organizations from the user
__git_retrieve_orgs() {
  git_user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  api_url="https://api.github.com"
  if [ -n "$GITADMIN_GITHUB_AUTH_TOKEN" ]; then
    git_user="$(__curl_gh_api "$api_url/user/orgs?per_page=1000" | __jq -rc '.[].login' | sort -u | grep '^')"
  else
    git_user="$(__curl_gh_api "$api_url/users/$git_user/orgs?per_page=1000" | __jq -rc '.[].login' 2>/dev/null | sort -u | grep '^')"
  fi
  export GIT_ALL_REPOS="${git_user}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_all_orgs_clone() {
  __git_retrieve_orgs "${1:-$GITADMIN_DEFAULT_USERNAME}"
  total="$(printf '%s\n' "$GIT_ALL_REPOS" | tr ' ' '\n ' | grep -v '^$' | grep '^' | wc -l)"
  [ -n "$total" ] && printf_blue "$GITADMIN_DEFAULT_USERNAME has $total organizations"
  for org in $GIT_ALL_REPOS; do
    $0 org clone "$org"
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Initializes a repo with default options
__repos_init() {
  local git_dir="" git_version_file="" git_version_fmt=""
  git_dir="$(__basedir "${1:-$GITADMIN_CWD}/.git")"
  git_version_file="$GITADMIN_DEFAULT_VERSION_FILE"
  git_version_fmt="$GITADMIN_DEFAULT_VERSION_FORMAT"
  [ -f "$git_version_file" ] && date +"$git_version_fmt" >"$git_version_file"
  git -C "$git_dir" add .
  if [ -f "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" ] && [ ! -L "$git_dir/.git/config" ]; then
    cp -Rf "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" "$git_dir/.git/config"
  fi
  __devnull2 git -C "$git_dir" commit -m ' ü¶àüè†üêú Initial Commit üêúü¶àüè† '
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Initializes a repo for github
__git_init() {
  local git_dir="" git_version_file="" git_version_fmt="" git_remote=""
  username="$(echo "$*" | grep -q '/' && echo "$*" | awk '{print $1}' || echo "$1")"
  reponame="$(echo "$*" | grep -q '/' && echo "$*" | awk '{print $2}' || echo "$2")"
  git_dir="$(__basedir "${username:-$GITADMIN_CWD}/.git")"
  git_version_file="$GITADMIN_DEFAULT_VERSION_FILE"
  git_version_fmt="$GITADMIN_DEFAULT_VERSION_FORMAT"
  git_remote=""
  [ "${1:-$username}" = "" ] && printf_red "Usage: userName repoName\n" && return 1
  [ "${2:-$reponame}" = "" ] && printf_red "Usage: userName repoName\n" && return 1
  #git_setup "$git_dir"
  [ -f "$git_version_file" ] && date +"$git_version_fmt" >"$git_version_file"
  __devnull2 git -C "$git_dir" add .
  if [ -f "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" ] && [ ! -L "$git_dir/.git/config" ]; then
    cp -Rf "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" "$git_dir/.git/config"
  fi
  __devnull2 git -C "$git_dir" commit -m ' ü¶àüè†üêú Initial Commit üêúü¶àüè† '
  __devnull2 git -C "$git_dir" remote add origin "${remote:-https://github.com/$username/$reponame}"
  __git_push "$git_dir" -u origin "$GITADMIN_DEFAULT_BRANCH"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# List gists
__ghgist_list() {
  local user=""
  user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  shift 1
  __api_gist "$user" | __jq ".[] | .description, .id" 2>/dev/null | awk 'NR%2{printf "%s ",$0;next;}1' | sed 's|""|"No Description"|g;s/" "/ | ID: /g;s|^"|Gist Title: |g;s|"||g' && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# search gists
__search_list() {
  local user=""
  user="${1:-$GITADMIN_DEFAULT_USERNAME}"
  shift 1
  __api_gist "$1" | __jq ".[] | .description, .id" 2>/dev/null | awk 'NR%2{printf "%s ",$0;next;}1' | sed 's|""|"No Description"|g;s/" "/ | ID: /g;s|^"|Gist Title: |g;s|"||g' | grep -is "$2"
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Delete gist
__ghgist_delete() {
  local gist_id="" gist_exit="" gist_succes="" gist_failed=""
  gist_exit="0"
  gist_id="$(basename -- "$1")" && shift 1
  gist_succes="Deleted gist: $gist_id"
  gist_failed="failed to delete gist: $gist_id"
  [ -n "$gist_id" ] || printf_exit "Please provide the gist ID"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1
  __curl_gh_api -X DELETE "https://api.github.com/gists/$gist_id" >"$GITADMIN_TEMP_FILE" && gist_exit=0 || gist_exit=1
  if grep -viqs "Not Found" "$GITADMIN_TEMP_FILE"; then
    gist_succes="[ ‚úñ ] gist: $gist_id was not found"
    gist_exit=0
  fi
  __getexitcode $gist_exit "$gist_succes" "$gist_failed"
  return $gist_exit
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__format_file_as_JSON_string() {
  sed -e 's/\\/\\\\/g' \
    -e 's/$/\\n/g' \
    -e 's/"/\\"/g' \
    -e 's/\t/\\t/g' |
    tr -d "\n"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Creates a new gist from - https://github.com/kathawala/gist/blob/master/gist.sh
__ghgist_create() {
  local gist_exit="0" gist_describe="" gist_filename="" gist_content="" gist_succes="" gist_failed="" save_dir=""
  gist_describe="$(echo "$1" | awk '{gsub(/"/, "\\\"")} 1' | grep '' || echo '')"
  gist_filename="$2"
  gist_get_content="${3:-}"
  format_gist="$(echo "$gist_get_content" | __format_file_as_JSON_string)"
  save_dir="${GISTADMIN_GIST_SAVE_DIR:-$HOME/Documents/myscripts/gists}"
  gist_content="$(printf "%s\r" "{ \"description\": \"$gist_describe\", \"public\": true, \"files\": {\"$gist_filename\": { \"content\": \"$format_gist\" }}}" | tee ${GITADMIN_TEMP_FILE}-data.txt)"
  [ $# -eq 3 ] || __printf_help "Usage: $APPNAME gist create description filename contents"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1
  printf_green "Creating gist with Description $gist_describe and filename: $gist_filename"
  mkdir -p "$save_dir"
  [ -f "$save_dir/all.txt" ] || printf '%s\n' "# My saved gists" >"$save_dir/all.txt"
  __curl_gh_api -X POST -if "https://api.github.com/gists" --data @"${GITADMIN_TEMP_FILE}-data.txt" | grep -w "html_url" | grep "gist" | awk '{print $2}' | __sed 's/\,//;s|"||g' >"${GITADMIN_TEMP_FILE}"
  results="$(grep -qs '^' "${GITADMIN_TEMP_FILE}" && echo Success || echo '')"
  if [ "$results" = "Success" ]; then
    gist_exit=0
    gist_id="Gist ID: $(basename $(head -n1 "$GITADMIN_TEMP_FILE") 2>/dev/null)"
    gist_succes="Gist Url: $(cat "$GITADMIN_TEMP_FILE" 2>/dev/null)"
    printf '%s: %s\n' "$gist_filename" "${gist_id// *:/}" >>"$save_dir/all.txt"
    printf_cyan "$gist_id"
    __rm_rf "${GITADMIN_TEMP_FILE}-data.txt"
  else
    gist_exit=1
    gist_failed="Failed to create the gist"
    [ -f "${GITADMIN_TEMP_FILE}.err" ] && cat "${GITADMIN_TEMP_FILE}.err" | printf_readline '1'
    [ -f "${GITADMIN_TEMP_FILE}-data.txt" ] && cp -Rf "${GITADMIN_TEMP_FILE}-data.txt" "${GITADMIN_TEMP_FILE}-data.failed.txt"
  fi
  __getexitcode $gist_exit "$gist_succes" "$gist_failed"
  return $gist_exit
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Edits a gist
__ghgist_edit() {
  local gist_exit="" gist_id="" gist_describe="" gist_filename="" gist_content="" gist_succes="" gist_failed=""
  gist_exit=0
  gist_id="$1"
  gist_describe="$2"
  gist_filename="$3"
  gist_content="$4"
  gist_describe="${gist_describe:-$(basename -- "$gist_filename")}"
  gist_content="$(printf "%s\r" "{ \"description\": \"$gist_describe\", \"public\": true, \"files\": { \"$gist_filename\": {\"content\": \"$gist_content\" }}}" | tee $GITADMIN_TEMP_FILE-data.txt)"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1
  printf_green "Editing $gist_id with Description $gist_describe and filename: $gist_filename"
  if __curl_gh_api -X PATCH -i --data @$GITADMIN_TEMP_FILE-data.txt https://api.github.com/gists/$gist_id | grep -w "html_url" | grep "gist" | awk '{print $2}' | __sed 's/\,//;s|"||g' >"$GITADMIN_TEMP_FILE"; then
    gist_exit=0
    gist_id="Gist ID: $(basename $(head -n1 "$GITADMIN_TEMP_FILE"))"
    gist_succes="üöÑ Gist Url: $(cat "$GITADMIN_TEMP_FILE" | grep -v '^$') üöÑ"
    __rm_rf "$GITADMIN_TEMP_FILE-data.txt"
  else
    gist_exit=1
    gist_failed="ü§™ Failed to create the gist ü§™"
  fi
  printf_cyan "$gist_id"
  __getexitcode $gist_exit "$gist_succes" "$gist_failed"
  return $gist_exit
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Reusable function for delete
__github_delete_repo_user() {
  local git_user=""
  local git_repo=""
  local url="https://api.github.com/repos"
  local response=""
  local http_code=""

  if echo "$1" | grep -q '/'; then
    git_user="${1//\/*/}"
    git_repo="${1//*\//}"
  else
    git_user="${1:-$GITADMIN_DEFAULT_USERNAME}"
    git_repo="${2:-$REPONAME}"
  fi

  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1

  # Use curl without -f flag to capture all responses, suppress all errors
  response="$(curl -q -LSs -w '\n%{http_code}' -X DELETE \
    -H "Accept: application/vnd.github.v3+json" \
    -H "Authorization: token ${GITADMIN_GITHUB_AUTH_TOKEN}" \
    "${url}/${git_user}/${git_repo}" 2>/dev/null)"

  # Extract HTTP status code (last line)
  http_code="$(echo "$response" | tail -1)"

  # Check status codes
  case "$http_code" in
  204)
    # 204 No Content - successful deletion
    printf_green "üå± Deletion of https://github.com/$git_user/$git_repo successful üå±"
    return 0
    ;;
  404)
    # 404 Not Found - repo doesn't exist, treat as success
    printf_green "üå± Repository $git_user/$git_repo already removed üå±"
    return 0
    ;;
  403)
    # 403 Forbidden - permissions issue but if repo doesn't exist after, treat as success
    # Try to verify if repo still exists
    if ! curl -q -LSs -H "Authorization: token ${GITADMIN_GITHUB_AUTH_TOKEN}" \
      "${url}/${git_user}/${git_repo}" 2>/dev/null | grep -q '"id"'; then
      # Repo doesn't exist, consider it deleted
      printf_green "üå± Repository $git_user/$git_repo removed üå±"
      return 0
    else
      # Repo still exists, permission denied
      printf_red "üí¢ Deletion of https://github.com/$git_user/$git_repo failed - permission denied üí¢"
      return 1
    fi
    ;;
  401)
    # 401 Unauthorized - auth token issue
    printf_red "üö´ Authentication failed - check your token üö´"
    return 1
    ;;
  *)
    # Any other error
    printf_red "üí¢ Deletion of https://github.com/$git_user/$git_repo failed üí¢"
    return 1
    ;;
  esac
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Creates a new repo on github
__github_create_repo() {
  local git_user="" git_repo="" git_describe="" git_visibility="" git_homepage=""
  local git_failed="" git_succes="" GITADMIN_EXITCODE=0

  # Parse arguments - support: user/repo desc visibility homepage
  if echo "$1" | grep -q '/'; then
    git_user="${1//\/*/}"
    git_repo="${1//*\//}"
    git_describe="${2:-repo for $git_repo}"
    git_visibility="${3:-public}"
    git_homepage="${4:-}"
  else
    git_user="$1"
    git_repo="$2"
    git_describe="${3:-repo for $git_repo}"
    git_visibility="${4:-public}"
    git_homepage="${5:-}"
  fi

  # Use description from file if exists
  [ -f "$GITADMIN_CWD/DESCRIPTION" ] && git_describe="$(<"$GITADMIN_CWD/DESCRIPTION")" || git_describe="${git_describe:-}"

  api_url="https://api.github.com/repos"
  git_succes="üòª Success: https://github.com/$git_user/$git_repo üòª"
  git_failed="üëø Creation of https://github.com/$git_user/$git_repo failed üëø"

  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1

  if __api_repo_verify "$api_url" "$git_user" "$git_repo"; then
    # Repo already exists
    printf_cyan "$git_succes"
    GITADMIN_EXITCODE=0
  elif __curl_github_orgs_create "$git_user" "$git_repo" "$git_describe" "$git_homepage" "$git_visibility" || __curl_github_user_create "$git_user" "$git_repo" "$git_describe" "$git_homepage" "$git_visibility"; then
    sleep 5
    if __api_repo_verify "$api_url" "$git_user" "$git_repo" &>/dev/null; then
      printf_green "$git_succes"
      GITADMIN_EXITCODE=0
    else
      printf_yellow "$git_failed"
      GITADMIN_EXITCODE=1
    fi
  else
    printf_yellow "üò† An error occured while trying to create github.com/$git_user/$git_repo üò†"
    GITADMIN_EXITCODE=1
  fi
  return "$GITADMIN_EXITCODE"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Deletes a github repo
__github_delete_repo() {
  local git_user="" git_repo="" git_failed="" git_succes="" GITADMIN_EXITCODE=""
  local api_url="https://api.github.com/repos"
  if echo "$1" | grep -q '/'; then
    git_user="$(echo "$@" | awk -F '/' '{print $(NF-1)}')"
    git_repo="$(echo "$@" | awk -F '/' '{print $NF}')"
  else
    git_user="$1"
    git_repo="$2"
  fi
  if __api_repo_verify "$api_url" "$git_user" "$git_repo"; then
    git_failed="üí¢ Deletion of http://github.com/$git_user/$git_repo failed üí¢"
    git_succes="üå± Deletion of http://github.com/$git_user/$git_repo successful üå±"
    GITADMIN_EXITCODE=0
    printf_green "üóëÔ∏è Deleting repo $git_repo for user $git_user"
    __github_delete_repo_user "$git_user" "$git_repo"
    if __api_repo_verify "$api_url" "$git_user" "$git_repo"; then
      GITADMIN_EXITCODE=1
    fi
  else
    printf_yellow "‚ùî The repo http://github.com/$git_user/$git_repo does not exist ‚ùî"
    exit "1"
  fi
  __getexitcode $GITADMIN_EXITCODE "$git_succes" "$git_failed"
  return $GITADMIN_EXITCODE
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Reusable function for create repo
__curl_github_orgs_create() {
  local user="$1"
  local repo="$2"
  local DESCR="${3:-$DESCR}"
  local SITE="${4:-$HOMEPAGE}"
  local VISIBLE="${5:-$GITADMIN_REPO_VISIBLE}"
  local SITE="${SITE:-http://github.com/$user/$repo}"
  local url="https://api.github.com/orgs/$user/repos"
  local visibility="public"
  local json_data=""

  echo "$SITE" | grep -q '://.*\.[a-zA-Z0-9].*/.*' || SITE="https://github.com/$SITE"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1

  # Determine visibility
  if [ "$GITADMIN_REPO_VISIBLE" = "no" ] || [ "$VISIBLE" = "private" ]; then
    visibility="private"
  fi

  # Generate JSON using the template function
  json_data="$(__generate_repo_json "$repo" "$DESCR" "$SITE" "$visibility" "github")"

  __curl_gh_api "$url" --data "$json_data" >"$GITADMIN_TEMP_FILE"
  if grep -qis '"full_name".*"'$user'/'$repo'"' "$GITADMIN_TEMP_FILE"; then
    return 0
  elif grep -qis 'name already exists on this account' "$GITADMIN_TEMP_FILE"; then
    printf_green "‚ÑπÔ∏è https://github.com/$user/$repo already exists"
    return 0
  elif grep -qis 'Not Found' "$GITADMIN_TEMP_FILE"; then
    return 1
  else
    if [ -f "$GITADMIN_TEMP_FILE" ]; then
      cat "$GITADMIN_TEMP_FILE" | __jq -r '.errors | .[].message' 2>/dev/null | printf_readline
    fi
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__curl_github_user_create() {
  local user="$1"
  local repo="$2"
  local DESCR="${3:-$DESCR}"
  local SITE="${4:-$HOMEPAGE}"
  local VISIBLE="${5:-$GITADMIN_REPO_VISIBLE}"
  local url="https://api.github.com/user/repos"
  local SITE="${SITE:-http://github.com/$user/$repo}"
  local visibility="public"
  local json_data=""

  echo "$SITE" | grep -q '://.*\.[a-zA-Z0-9].*/.*' || SITE="https://github.com/$SITE"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1

  # Determine visibility
  if [ "$GITADMIN_REPO_VISIBLE" = "no" ] || [ "$VISIBLE" = "private" ]; then
    visibility="private"
  fi

  # Generate JSON using the template function
  json_data="$(__generate_repo_json "$repo" "$DESCR" "$SITE" "$visibility" "github")"

  __curl_gh_api -f "$url" --data "$json_data" >"$GITADMIN_TEMP_FILE"
  if grep -qis '"full_name".*"'$user'/'$repo'"' "$GITADMIN_TEMP_FILE"; then
    return 0
  elif grep -qis 'name already exists on this account' "$GITADMIN_TEMP_FILE"; then
    return 0
  elif grep -qis 'Not Found' "$GITADMIN_TEMP_FILE"; then
    return 1
  else
    if [ -f "$GITADMIN_TEMP_FILE" ]; then
      cat "$GITADMIN_TEMP_FILE" | __jq -r '.errors | .[].message' 2>/dev/null | printf_readline
    fi
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# clone a single repo from user
__ghsinglerepo() {
  username="$(echo "$*" | grep -q '/' && echo "$*" | awk '{print $1}' || echo "$1")"
  reponame="$(echo "$*" | grep -q '/' && echo "$*" | awk '{print $2}' || echo "$2")"
  [ "${1:-$username}" = "" ] && printf_red "Usage: --single userName repoName" && return 1
  [ "${2:-$reponame}" = "" ] && printf_red "Usage: --single userName repoName" && return 1
  __git_clone "https://github.com/$1/$2" "${3:-}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_push_mirror() {
  local workingDir="${1:-$workingDir:-GITADMIN_CWD}"
  if [ -f "$workingDir/.gitmirror" ]; then
    while read -r url; do
      printf '%b' "$(printf_blue "üëæ Pushing to $url: ")" && git -C "$workingDir" push $url -q 2>/dev/null
      retVal=$?
      if [ $retVal -eq 0 ]; then
        retVal=0
        printf_green "success üëæ"
      else
        printf_red "Failed ‚ö†Ô∏è"
        exitCode=$((exitCode + retVal))
      fi
    done <"$workingDir/.gitmirror"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# push local repo
__git_push_single() {
  local SET_BASE_REPO="" GITADMIN_EXITCODE="0" username="" user_repo=""
  SUCCESS_MSG() { echo "üëæ Push to $(__git_remote_origin "${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_CWD}") has completed üëæ"; }
  FAILED_MSG() { echo "üòø Push to $(__git_remote_origin "${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_CWD}") has failed üòø"; }
  SET_BASE_REPO="$1"
  GITADMIN_CWD_NAME="$(basename -- "${SET_BASE_REPO:-$GITADMIN_CWD}")"
  [ -d "$SET_BASE_REPO" ] && shift 1
  if [ -d "$SET_BASE_REPO/.git" ]; then
    printf_custom "4" "üêõ Pushing the repo in $SET_BASE_REPO üêõ"
    __git_push_mirror "$SET_BASE_REPO"
    __git_custom "$SET_BASE_REPO" push && GITADMIN_EXITCODE=0 || GITADMIN_EXITCODE=1
    __getexitcode $GITADMIN_EXITCODE "$(SUCCESS_MSG)" "$(FAILED_MSG)"
  else
    if [ -n "$1" ]; then
      GITADMIN_CWD_NAME="$(__git_hostname "$1")"
      GITADMIN_NEW_PROJECT_DIR="$1"
      __git_username_repo "$1"
      username="${username:-}"
      userrepo="${userrepo:-}"
    else
      GITADMIN_NEW_PROJECT_DIR="${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_CWD_NAME/$username/$userrepo}"
    fi
    if [ -d "$GITADMIN_NEW_PROJECT_DIR/.git" ]; then
      printf_custom "4" "üêõ Pushing the repo in $GITADMIN_NEW_PROJECT_DIR üêõ"
      __git_push_mirror "$GITADMIN_NEW_PROJECT_DIR"
      __git_push "$GITADMIN_NEW_PROJECT_DIR" && GITADMIN_EXITCODE=0 || GITADMIN_EXITCODE=1
      __getexitcode $GITADMIN_EXITCODE "$(SUCCESS_MSG)" "$(FAILED_MSG)"
    else
      GITADMIN_EXITCODE=1
    fi
  fi
  return $GITADMIN_EXITCODE
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# pull a single repo
__git_pull_single() {
  local SET_BASE_REPO="" GITADMIN_EXITCODE="0" username="" user_repo=""
  SUCCESS_MSG() { echo "Pull from $(__git_remote_origin "${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_CWD}") has completed"; }
  FAILED_MSG() { echo "Pull from $(__git_remote_origin "${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_CWD}") has failed"; }
  SET_BASE_REPO="$1"
  GITADMIN_CWD="$(realpath $SET_BASE_REPO)"
  GITADMIN_CWD_NAME="$(basename -- "${SET_BASE_REPO:-$GITADMIN_CWD}")"
  [ -d "$SET_BASE_REPO" ] && shift 1
  if [ -d "$GITADMIN_CWD/.git" ]; then
    printf_custom "4" "Updating the repo in $GITADMIN_CWD"
    __git_custom "$GITADMIN_CWD" pull && GITADMIN_EXITCODE=0 || GITADMIN_EXITCODE=1
    __getexitcode $GITADMIN_EXITCODE "$(SUCCESS_MSG)" "$(FAILED_MSG)"
  else
    if [ -n "$SET_BASE_REPO" ]; then
      __git_username_repo "$SET_BASE_REPO"
      GITADMIN_CWD_NAME="$(__git_hostname "$SET_BASE_REPO")"
      GITADMIN_NEW_PROJECT_DIR="$1"
    else
      GITADMIN_NEW_PROJECT_DIR="${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_CWD_NAME/$username/$userrepo}"
    fi
    if [ -d "$GITADMIN_NEW_PROJECT_DIR/.git" ]; then
      printf_custom "4" "Updating the repo in $GITADMIN_NEW_PROJECT_DIR"
      __git_pull "$GITADMIN_NEW_PROJECT_DIR" && GITADMIN_EXITCODE=0 || GITADMIN_EXITCODE=1
      __getexitcode $GITADMIN_NEW_PROJECT_DIR "$(SUCCESS_MSG)" "$(FAILED_MSG)"
    else
      return 1
    fi
  fi
  return "${GITADMIN_EXITCODE:-$?}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# clone a single repo
__git_clone_single() {
  local set_url="$1" git_url="" FAILED_MSG="" SUCCESS_MSG="" GITADMIN_EXITCODE=""
  git_url="$set_url"
  __git_username_repo "$git_url"
  GITADMIN_NEW_PROJECT_DIR="${2:-$GITADMIN_NEW_PROJECT_DIR}"
  GITADMIN_NEW_PROJECT_DIR="${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_CWD_NAME/$username/$userrepo}"
  FAILED_MSG="üòø Cloning from $git_url has failed üòø"
  SUCCESS_MSG="üòª Cloning from $git_url has completed üòª"
  GITADMIN_EXITCODE=0
  if [ -d "$GITADMIN_NEW_PROJECT_DIR/.git" ]; then
    printf_custom "4" "üëæ Updating the repo in $GITADMIN_NEW_PROJECT_DIR üëæ"
    __git_pull "$GITADMIN_NEW_PROJECT_DIR" && GITADMIN_EXITCODE=0 || GITADMIN_EXITCODE=1
    __getexitcode $GITADMIN_EXITCODE "$SUCCESS_MSG" "$FAILED_MSG"
  else
    printf_custom "4" "üëæ Cloning the repo to $GITADMIN_NEW_PROJECT_DIR üëæ "
    __git_clone "$git_url" "$GITADMIN_NEW_PROJECT_DIR" && GITADMIN_EXITCODE=0 || GITADMIN_EXITCODE=1
    __getexitcode $GITADMIN_EXITCODE "$SUCCESS_MSG" "$FAILED_MSG"
  fi
  return "$?"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#continue pulling
__git_update_loop() {
  if [[ "$*" =~ "--while" ]]; then
    while true; do
      for project in $(ls -d "$GITADMIN_DEFAULT_PROJECT_DIR"/*/*/*); do
        printf_green "Updating $project $(__git_pull "$project" |& __devnull) $(__getexitcode)"
      done && clear
      printf_custom "3" "Sleeping for a minute $(sleep 60)"
    done
  else
    for project in $(ls -d "$GITADMIN_DEFAULT_PROJECT_DIR"/*/*/*); do
      printf_green "Updating $project $(__git_pull "$project" |& __devnull) $(__getexitcode)"
    done
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# cron functions
__run_cron() {
  local frequency="0 4 * * 6"
  local croncmd="$APPNAME cron run"
  case $1 in
  run)
    logr -name gitadmin 'am_i_online --console && $(expr $RANDOM \% 300) && gitadmin org all && gitadmin --user'
    ;;
  remove)
    shift 1
    removecrontab "$frequency $croncmd"
    ;;
  add)
    addtocrontab "$frequency $croncmd"
    ;;
  *)
    addtocrontab "$frequency $croncmd"
    ;;
  esac
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Shorten URL
__git_io() {
  printf_exit "This has been disabled by github: Will create my own"
  local short_url="" short_name=""
  short_url="$1"
  short_name="$2"
  printf_blue "Attempting to create $short_url on git.io"
  if [ -n "$short_name" ]; then
    MESSAGE="$(curl -q -LSsi https://git.io -F "url=$short_url" -F "code=$short_name" 2>/dev/null | grep 'Location: ')"
  else
    MESSAGE="$(curl -q -LSsi https://git.io -F "url=$short_url" 2>/dev/null | grep 'Location: ')"
  fi
  if [ -n "$MESSAGE" ]; then
    printf_green "$MESSAGE"
  else
    printf_return "Failed to create the shortened URL"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# rename branch
__rename_branch_api() {
  local git_branch="" git_user="" git_repo=""
  git_branch="$1"
  git_user="${2:-$(basename -- "$(dirname "$GITADMIN_CWD")")}"
  git_repo="${3:-$(basename -- "$GITADMIN_CWD")}"
  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1
  if __curl_gh_api -X PATCH "https://api.github.com/repos/$git_user/$git_repo" -d '{"default_branch":"'$git_branch'"}' | grep -qs '"default_branch": "'$git_branch'"' >/dev/null; then
    git -C "$GITADMIN_CWD" push --delete origin ${git_old_branch:-master} -fq &>/dev/null || return 1
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_config_branch() {
  git config init.defaultBranch "${1:-main}" &>/dev/null
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# rename master to main
__rename_branch() {
  local git_branch="" git_user="" git_repo=""
  local exitCode=0
  git_branch="${1:-main}"
  git_user="${2:-$(basename -- "$(dirname "$GITADMIN_CWD")")}"
  git_repo="${3:-$(basename -- "$GITADMIN_CWD")}"
  git_config_branch="$(git config --get init.defaultBranch | grep '')"
  printf_blue "Changing git branch to $git_branch on $git_repo"
  if [ -f "$GITADMIN_CWD/.git/config" ]; then
    git -C "$GITADMIN_CWD" branch -m ${git_old_branch:-master} "$git_branch" &>/dev/null
    git -C "$GITADMIN_CWD" push -u origin "$git_branch" -fq &>/dev/null
    git -C "$GITADMIN_CWD" push --set-upstream origin $git_branch
  fi
  if __rename_branch_api "$git_branch" "$git_user" "$git_repo"; then
    printf_green "üåø Changed the default branch on github.com/$git_user/$git_repo"
  fi &&
    printf_green "‚úÖ Successfully renamed the default branch" ||
    { printf_red "Failed to rename the default branch" && exitCode=1; }
  if [ "$git_config_branch" != "$git_branch" ]; then
    __git_config_branch "$git_branch"
  fi
  #grep -rl --exclude-dir='.git' '/raw/'${git_old_branch:-master}'/' "$GITADMIN_CWD" | xargs sed -i 's|/raw/'${git_old_branch:-master}'/|/raw/'$branch'/|g'
  #gitcommit
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__clone_orgs() {
  GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
  GITADMIN_DEFAULT_REPO_BASE="${2:-$GITADMIN_DEFAULT_REPO_BASE}/$GITADMIN_DEFAULT_USERNAME"
  GITADMIN_NEW_PROJECT_DIR="$GITADMIN_DEFAULT_PROJECT_DIR/github"
  __api_org_token "$GITADMIN_DEFAULT_USERNAME" || return 1
  printf_green "$MESSAGE"
  printf_blue "There's currently $COUNT repos available"
  __main "$GITADMIN_DEFAULT_REPO_BASE"
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# __main cloning function
__main() {
  local i="" git_user="" git_repo="" git_base="" git_dir="" git_failed="" git_succes="" user_repo=""
  sleep 1
  git_user="$1"
  git_repo="${2:-$GITADMIN_DEFAULT_REPO_BASE}"
  git_base="${GITADMIN_NEW_PROJECT_DIR:-$GITADMIN_DEFAULT_PROJECT_DIR/github}"
  __git_username_repo "$1"
  printf_yellow "ProjectDir: ${git_base}"
  printf_yellow "BaseRepo URL: $git_repo"
  echo ""
  for i in $(<"$GITADMIN_TEMP_FILE"); do
    local_dir_name="$(basename -- "$i")"
    user_repo="$git_repo/$local_dir_name"
    local_user_name="$(basename -- "$git_repo")"
    git_dir="$git_base/$local_user_name/$local_dir_name"
    if [ -d "$git_dir/.git" ]; then
      git_failed="üëø Failed to update repo in $git_dir üëø"
      git_succes="üòº Updated git repo in $git_dir üòº "
      printf_purple "üíΩ Now running git pull $user_repo üíΩ"
      if [ -f "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" ] && [ ! -L "$git_dir/.git/config" ]; then
        cp -Rf "$git_dir/$GITADMIN_DEFAULT_MAINCONFIG" "$git_dir/.git/config"
      fi
      __git_pull "$git_dir"
      __getexitcode "$git_succes" "$git_failed"
    else
      git_failed="üëø Failed to clone to $git_dir üëø "
      git_succes="üòº Successfully cloned to $git_dir üòº "
      printf_purple "üåÄ Now running git clone $user_repo üåÄ"
      __git_clone "$user_repo" "$git_dir"
      __getexitcode "$git_succes" "$git_failed"
    fi
    echo ""
  done
  return "${EXIT:-$?}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__cd_into() {
  [ "$GITADMIN_AUTO_CD" = "true" ] || return 0
  if [ "$PWD" != "$1" ]; then
    if [ -d "$1" ] && builtin cd "$1"; then
      printf_green "Changing the directory to $1"
      printf_yellow "Type exit to return to your previous directory"
      exec bash || return 1
    else
      exit 1
    fi
  fi
}
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_remote_push() {
  local dir="${1:-${GITADMIN_CWD:-.}}"
  local gitconfig="${GITADMIN_DEFAULT_MAINCONFIG:-gitmainconfig}"
  local set_remote="" get_remote=""
  get_remote="$(grep -sh 'pushurl =' "$dir/$gitconfig" "$dir/.git/config" | awk -F '=' '{print $2}' | grep '^' || grep -sh 'push =' "$dir/$gitconfig" "$dir/.git/config" | awk -F '=' '{print $2}')"
  get_remote="$(echo "${get_remote// /}" | head -n1)"
  if [ -z "$get_remote" ]; then
    set_remote="$(git -C "$dir" remote -v 2>/dev/null | grep 'push' | __test_if_url | head -n 1 | awk '{print $2}' 2>/dev/null | grep '^' || echo "$git_prev")"
  fi
  printf '%s\n' "${get_remote:-$set_remote}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_status() { git -C "${1:-${GITADMIN_CWD:-.}}" status -b -s 2>/dev/null && return 0 || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_log() {
  local head="" args="${2:-$1}"
  if __test_if_number "$args"; then
    git -C "${1:-${GITADMIN_CWD:-.}}" log --pretty='%C(magenta)%h%C(red)%d %C(yellow)%ar %C(green)%s %C(yellow)(%an)' --max-count=$args 2>/dev/null
    return $?
  else
    git -C "${1:-${GITADMIN_CWD:-.}}" log --pretty='%C(magenta)%h%C(red)%d %C(yellow)%ar %C(green)%s %C(yellow)(%an)' 2>/dev/null
    return $?
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_user_clone_repos() {
  local exitCode=0
  GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
  GITADMIN_DEFAULT_REPO_BASE="$GITADMIN_DEFAULT_REPO_BASE/$GITADMIN_DEFAULT_USERNAME"
  __api_user "$GITADMIN_DEFAULT_USERNAME" | grep -w clone_url | awk -F / '{print $NF}' | __sed 's/\",//' | __sed 's/\.[^.]*$//' >"$GITADMIN_TEMP_FILE"
  COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
  if [ -n "$COUNT" ]; then
    printf_green "$MESSAGE"
    printf_blue "There's currently $COUNT repos available"
    printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
    __main "$GITADMIN_DEFAULT_USERNAME"
    exitCode=$?
  else
    exitCode=1
    printf_red "No repos found for $GITADMIN_DEFAULT_USERNAME"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_org_clone_repos() {
  local exitCode=0
  GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
  GITADMIN_DEFAULT_REPO_BASE="$GITADMIN_DEFAULT_REPO_BASE/$GITADMIN_DEFAULT_USERNAME"
  __api_org_token "$GITADMIN_DEFAULT_USERNAME" | grep -w clone_url | awk -F / '{print $NF}' | __sed 's/\",//' | __sed 's/\.[^.]*$//' >"$GITADMIN_TEMP_FILE"
  COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
  if [ -n "$COUNT" ]; then
    printf_green "$MESSAGE"
    printf_blue "There's currently $COUNT repos available"
    printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
    __main "$GITADMIN_DEFAULT_USERNAME"
    exitCode=$?
  else
    exitCode=1
    printf_red "No repos found for $GITADMIN_DEFAULT_USERNAME"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_org_list_repos() {
  local exitCode=0
  GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
  GITADMIN_DEFAULT_REPO_BASE="https://github.com/$GITADMIN_DEFAULT_USERNAME"
  __api_org_token "$GITADMIN_DEFAULT_USERNAME" | sort -u >"$GITADMIN_TEMP_FILE" || echo >>"$GITADMIN_TEMP_FILE"
  COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
  if [ -n "$COUNT" ]; then
    printf_green "$MESSAGE"
    printf_blue "There's currently $COUNT repos available"
    printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
    __file_exists_and_not_empty "$GITADMIN_TEMP_FILE" && cat "$GITADMIN_TEMP_FILE" | printf_column "5" || exitCode=2
  else
    exitCode=1
    printf_red "üòø No repos found for $GITADMIN_DEFAULT_USERNAME üòø"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_org_push_repos() {
  local exitCode=0
  local ERROR SUCCES
  local GIT_MAIN_FILE="${GITADMIN_MAIN_CONF_NAME:-gitmainconfig}"
  GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
  GITADMIN_DEFAULT_REPO_BASE="$GITADMIN_DEFAULT_REPO_BASE/$GITADMIN_DEFAULT_USERNAME"
  __api_user_token "$GITADMIN_DEFAULT_USERNAME"
  __curl_gh_api "$GITHUBAPIREPO" | grep -w clone_url | awk -F / '{print $NF}' | __sed 's/\",//' | __sed 's/\.[^.]*$//' >"$GITADMIN_TEMP_FILE"
  COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
  if [ -n "$COUNT" ]; then
    printf_green "$MESSAGE"
    printf_blue "There's currently $COUNT repos available"
    printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
    repo_list="$(<"$GITADMIN_TEMP_FILE")"
    for i in $repo_list; do
      if [ -d "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i" ]; then
        printf_purple "Now running git push $1/$i"
        ERROR="git push failed for $GITADMIN_DEFAULT_USERNAME/$i"
        SUCCES="git push completed for $GITADMIN_DEFAULT_USERNAME/$i"
        if [ -f "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i/$GIT_MAIN_FILE" ] && [ ! -L "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i/.git/config" ]; then
          cp -Rf "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i/$GIT_MAIN_FILE" "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i/.git/config"
        fi
        if (__devnull2 git -C "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i" status | grep -q "working tree clean"); then
          __getexitcode "$?" "$ERROR" "$SUCCES"
          exitCode=$((exitCode + $?))
        else
          [ -f "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i/version.txt" ] && date +"$GITADMIN_DEFAULT_VERSION_FORMAT" >"$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i/version.txt"
          git -C "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i" add . |& __devnull &&
            git -C "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i" commit -a -m " ‚ùáü¶àüè†‚ùó General Fixes ‚ùóüè†ü¶à‚ùá " |& __devnull &&
            __git_push "$GITADMIN_DEFAULT_PROJECT_DIR/$GITADMIN_DEFAULT_USERNAME/$i" |& __devnull
          __getexitcode "$?" "$ERROR" "$SUCCES"
          exitCode=$((exitCode + $?))
        fi
      fi
    done
  else
    exitCode=1
    printf_red "üòø No repos found for $GITADMIN_DEFAULT_USERNAME üòø"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Change organization membership visibility
__github_orgs_visibility() {
  local visibility="${1:-show}"
  local org_name="${2:-}"
  local username="${3:-$GITADMIN_DEFAULT_USERNAME}"
  local exitCode=0
  local status_code=""
  local orgs_list=""

  [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_red "üö´ ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set" && return 1

  # Get all orgs if not specified
  if [ -z "$org_name" ]; then
    printf_cyan "Fetching organizations for $username..."
    # Get all orgs with pagination (100 per page max)
    local page=1
    local temp_list=""
    while true; do
      temp_list="$(__curl_gh_api "https://api.github.com/user/orgs?per_page=100&page=$page" | __jq -r '.[].login' 2>/dev/null | grep '^' || echo '')"
      [ -z "$temp_list" ] && break
      orgs_list="$orgs_list $temp_list"
      page=$((page + 1))
    done

    orgs_list="$(echo $orgs_list | tr ' ' '\n' | sort -u | grep '^' || echo '')"

    if [ -z "$orgs_list" ]; then
      printf_yellow "No organizations found for $username"
      return 1
    fi
  else
    orgs_list="$org_name"
  fi

  case "$visibility" in
  show | status)
    if [ -n "$org_name" ]; then
      # Check single org
      status_code=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "Authorization: token $GITADMIN_GITHUB_AUTH_TOKEN" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/orgs/$org_name/public_members/$username")

      if [ "$status_code" = "204" ]; then
        printf_green "$org_name: $username public membership"
      elif [ "$status_code" = "404" ]; then
        printf_yellow "$org_name: $username private membership"
      else
        printf_red "$org_name: $username error checking status (HTTP $status_code)"
      fi
    else
      # Check all orgs
      local total=$(echo "$orgs_list" | wc -w)
      printf_cyan "Checking membership visibility for $total organizations..."
      echo ""

      for org in $orgs_list; do
        status_code=$(curl -s -o /dev/null -w "%{http_code}" \
          -H "Authorization: token $GITADMIN_GITHUB_AUTH_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/orgs/$org/public_members/$username")

        if [ "$status_code" = "204" ]; then
          printf_green "$org: $username public"
        elif [ "$status_code" = "404" ]; then
          printf_yellow "$org: $username private"
        else
          printf_red "$org: $username error (HTTP $status_code)"
        fi
      done
    fi
    ;;

  public)
    if [ -n "$org_name" ]; then
      # Make single org public
      printf_cyan "Making membership public in $org_name..."
      status_code=$(curl -s -o /dev/null -w "%{http_code}" -X PUT \
        -H "Authorization: token $GITADMIN_GITHUB_AUTH_TOKEN" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/orgs/$org_name/public_members/$username")

      if [ "$status_code" = "204" ]; then
        printf_green "$org_name: $username membership is now public"
      else
        printf_red "Failed to update $username: $org_name (HTTP $status_code)"
        exitCode=1
      fi
    else
      # Make all orgs public
      local total=$(echo "$orgs_list" | wc -w)
      local success=0
      local failed=0

      printf_cyan "Making membership public in $total organizations..."

      for org in $orgs_list; do
        status_code=$(curl -s -o /dev/null -w "%{http_code}" -X PUT \
          -H "Authorization: token $GITADMIN_GITHUB_AUTH_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/orgs/$org/public_members/$username")

        if [ "$status_code" = "204" ]; then
          success=$((success + 1))
          printf_green "$org: $username membership is now public"
        else
          failed=$((failed + 1))
          exitCode=$((exitCode + 1))
          printf_red "Failed $username: $org (HTTP $status_code)"
        fi
      done

      printf_green "Completed: $success succeeded"
      [ $failed -gt 0 ] && printf_red "Failed: $failed organizations"
    fi
    ;;

  private | hide)
    if [ -n "$org_name" ]; then
      # Make single org private
      printf_cyan "Making membership private in $org_name..."
      status_code=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
        -H "Authorization: token $GITADMIN_GITHUB_AUTH_TOKEN" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/orgs/$org_name/public_members/$username")

      if [ "$status_code" = "204" ] || [ "$status_code" = "404" ]; then
        printf_green "$org_name: $username membership is now private"
      else
        printf_red "Failed to update $username: $org_name (HTTP $status_code)"
        exitCode=1
      fi
    else
      # Make all orgs private
      local total=$(echo "$orgs_list" | wc -w)
      local success=0
      local failed=0

      printf_cyan "Making membership private in $total organizations..."

      for org in $orgs_list; do
        status_code=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
          -H "Authorization: token $GITADMIN_GITHUB_AUTH_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/orgs/$org/public_members/$username")

        if [ "$status_code" = "204" ] || [ "$status_code" = "404" ]; then
          success=$((success + 1))
          printf_green "$org: $username membership is now private"
        else
          failed=$((failed + 1))
          exitCode=$((exitCode + 1))
          printf_red "Failed $username: $org (HTTP $status_code)"
        fi
      done

      printf_green "Completed: $success succeeded"
      [ $failed -gt 0 ] && printf_red "Failed: $failed organizations"
    fi
    ;;

  *)
    printf_red "Invalid option: $visibility"
    printf_yellow "Usage: gitadmin github orgs visibility [show|public|private] [orgName]"
    return 1
    ;;
  esac

  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_org_options_set() {
  while :; do
    case "$@" in
    description=*)
      ORG_REPO_DESCR="${1//*=/}"
      shift 1
      ;;
    private=*)
      ORG_REPO_PRIVATE="${1//*=/}"
      shift 1
      ;;
    homepage=*)
      ORG_REPO_PRIVATE="${1//*=/}"
      shift 1
      ;;
    projects=*)
      ORG_REPO_PROJECTS="${1//*=/}"
      shift 1
      ;;
    issues=*)
      ORG_REPO_ISSUES="${1//*=/}"
      shift 1
      ;;
    wiki=*)
      ORG_REPO_WIKI="${1//*=/}"
      shift 1
      ;;
    *)
      echo "$1" | grep -q '=' || break
      ;;
    esac
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_org_options_repos() {
  local statusCode=0
  local repo="${1:-$ORG_REPO_NAME}"
  local private="${2:-$ORG_REPO_PRIVATE}"
  local description="${3:-$ORG_REPO_DESCR}"
  local homepage="${4:-$ORG_REPO_HOMEPAGE}"
  local issues="${5:-$ORG_REPO_HOMEPAGE}"
  local projects="${6:-$ORG_REPO_PROJECTS}"
  local wiki="${7:-$ORG_REPO_WIKI}"
  if ! echo "$repo" | grep -q '/'; then printf_red "Please format repo as username/reponame" && return 1; fi
  [ -n "$private" ] && is_private="\"private\":$private,"
  [ -n "$description" ] && is_description="\"description\":\"$description\"."
  [ -n "$homepage" ] && is_homepage="\"homepage\":\"$homepage\","
  [ -n "$issues" ] && has_issues="\"has_issues\":$issues,"
  [ -n "$projects" ] && has_projects="\"has_projects\":$projects,"
  [ -n "$wiki" ] && has_wiki="\"has_wiki\":$wiki,"
  json_data="$(echo "${is_homepage}${is_private}${has_issues}${has_projects}${has_wiki}" | sed 's|,$||g')"
  __github_api_update_repo "$1" -d '{'${json_data}'}'
  statusCode=$?
  if [ "$statusCode" = 0 ]; then
    __printf_space 2 50 "$repo has been updated:" "${json_data//\"/}"
  else
    printf_red "Failed to update the repo"
  fi
  return $statusCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_api_update_repo() {
  local repo="$1" && shift 1
  curl -q -LSsf -X 'PATCH' -H "Authorization: token $GITADMIN_GITHUB_AUTH_TOKEN" -H "Accept: application/vnd.github.v3+json" -H "X-GitHub-Api-Version: $GITADMIN_GITHUB_API_VERSION" "https://api.github.com/repos/$repo" "$@" >/dev/null 2>&1 || return 2
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__is_clean() { __git_status "$1" | grep -v '##' | grep -q '^' && return 1 || return 0; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__is_dirty() { __git_status "$1" | grep -v '##' | grep -q '^' && return 0 || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__strip_git_url() { echo "$1" | sed 's|\.git$||g' | sed -e "s/\r//g"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_all_clone() {
  local exitStatus=0
  __git_all_orgs_clone "${1:-$GITADMIN_DEFAULT_USERNAME}"
  exitStatus=$((exitStatus + exitTmp))
  return $exitStatus
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_all_commit() {
  local projectDir="$1"
  local exitTmp exitStatus=0
  local listing="$(ls -Ar "$projectDir")"
  for dir in $listing; do
    exitTmp=0
    if [ -d "$d/.git" ]; then
      gitcommit --dir "$d" "all"
      exitTmp=$?
    else
      printf_yellow "$d is not a valid git repo"
    fi
    exitStatus=$((exitStatus + exitTmp))
  done
  return $exitStatus
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_all_push() {
  local projectDir="$1"
  local exitTmp exitStatus=0
  local listing="$(ls -Ar "$projectDir")"
  for dir in $listing; do
    exitTmp=0
    if [ -d "$d/.git" ]; then
      gitcommit --dir "$d" "all"
      exitTmp=$?
    else
      printf_yellow "$d is not a valid git repo"
    fi
    exitStatus=$((exitStatus + exitTmp))
  done
  return $exitStatus
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_all_pull() {
  local projectDir="$1"
  local exitTmp exitStatus=0
  local listing="$(ls -Ar "$projectDir")"
  for dir in $listing; do
    exitTmp=0
    if [ -d "$d/.git" ]; then
      gitcommit --dir "$d" "all"
      exitTmp=$?
    else
      printf_yellow "$d is not a valid git repo"
    fi
    exitStatus=$((exitStatus + exitTmp))
  done
  return $exitStatus
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#shellcheck disable=SC2145
__curl_gh_api() {
  local exitCode=0
  local exitTemp=0
  local page_count=$GITHUBAPIPAGES
  local tmpFile="$(mktemp -q -p "$GITADMIN_TEMP_DIR" XXXXXXXX)"
  if [ -n "$GITHUBAPIPAGES" ] && [ "$GITHUBAPIPAGES" -gt 1 ]; then
    while [ $page_count -ne 0 ]; do
      if [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ]; then
        curl -q -LSs -H "Accept: application/vnd.github.v3+json" -H "X-GitHub-Api-Version: $GITADMIN_GITHUB_API_VERSION" "$@&page=$page_count" 2>${GITADMIN_TEMP_FILE}.err >>"$tmpFile"
        exitTemp=$?
      else
        curl -q -LSs -H "Authorization: token $GITADMIN_GITHUB_AUTH_TOKEN" -H "Accept: application/vnd.github.v3+json" -H "X-GitHub-Api-Version: $GITADMIN_GITHUB_API_VERSION" "$@&page=$page_count" 2>${GITADMIN_TEMP_FILE}.err >>"$tmpFile"
        exitTemp=$?
      fi
      page_count=$((page_count - 1))
    done
    exitCode=$((exitCode + exitTemp))
    [ -f "$tmpFile" ] && cat "$tmpFile" || exitCode=3
  else
    if [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ]; then
      curl -q -LSs -H "Accept: application/vnd.github.v3+json" -H "X-GitHub-Api-Version: $GITADMIN_GITHUB_API_VERSION" "$@"
      return $?
    else
      curl -q -LSs -H "Authorization: token $GITADMIN_GITHUB_AUTH_TOKEN" -H "Accept: application/vnd.github.v3+json" -H "X-GitHub-Api-Version: $GITADMIN_GITHUB_API_VERSION" "$@"
      return $?
    fi
  fi
  [ -f "$tmpFile" ] && rm -Rf "$tmpFile"
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__api_repo_verify() {
  curl -q -LSsf -X GET -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${GITADMIN_GITHUB_AUTH_TOKEN}" "${1}/${2}/${3}" 2>/dev/null | jq -r '.html_url' | grep -qF "${2}/${3}" &>/dev/null
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_tag_add() {
  local repo="$GITADMIN_REMOTE_REPO"
  if git -C "$GITADMIN_CWD" tag -a "$1" -m "${2:-üöÄüåü Added tag $1 üöÄüåü}" >/dev/null 2>/dev/null; then
    printf_green "Added tag $1"
    if git -C "$GITADMIN_CWD" push origin "$1" >/dev/null 2>/dev/null; then
      printf_cyan "üè∑Ô∏è Pushed tag to $repo"
    fi
    return $?
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_tag_del() {
  local repo="$GITADMIN_REMOTE_REPO"
  if git -C "$GITADMIN_CWD" tag -d "$1" >/dev/null 2>/dev/null; then
    printf_green "Deleted tag $1"
    if git -C "$GITADMIN_CWD" push origin --delete "$1" >/dev/null 2>/dev/null; then
      printf_cyan "Deleted $1 from $repo"
    fi
    return $?
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - -
__git_release() {
 local tag="$1"
 # Delete local tag
 printf_yellow "Deleting the tag $tag"
  git -C "$GITADMIN_CWD" tag -d $tag >/dev/null >&1
  # Delete remote tag
  git -C "$GITADMIN_CWD" push origin :refs/tags/$tag >/dev/null 2>&1
  # Create new tag and push
  printf_cyan "Adding the tag: $tag"
  git -C "$GITADMIN_CWD" tag $tag >/dev/null 2>&1
  ptintf_green "Pushing tag to remote"
  git -C "$GITADMIN_CWD" push origin $tag >/dev/null 2>&1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__github_api_org_page_count() { curl -q -LSsfI "https://api.github.com/orgs/$1/repos" | grep 'link:' | sed 's|.*, ||g;s|>;.*||g' | awk -F'=' '{print $2}'; }
__github_api_user_page_count() { curl -q -LSsfI "https://api.github.com/users/$1/repos" | grep 'link:' | sed 's|.*, ||g;s|>;.*||g' | awk -F'=' '{print $2}'; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined variables/import external variables
GITADMIN_REPO_URL="${GITADMIN_REPO_URL:-}"
GITADMIN_PROJECT_DIR="${GITADMIN_PROJECT_DIR:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Application Folders
GITADMIN_CONFIG_FILE="${GITADMIN_CONFIG_FILE:-settings.conf}"
GITADMIN_CONFIG_DIR="${GITADMIN_CONFIG_DIR:-$HOME/.config/myscripts/gitadmin}"
GITADMIN_CONFIG_BACKUP_DIR="${GITADMIN_CONFIG_BACKUP_DIR:-$HOME/.local/share/myscripts/gitadmin/backups}"
GITADMIN_LOG_DIR="${GITADMIN_LOG_DIR:-$HOME/.local/log/gitadmin}"
GITADMIN_TEMP_DIR="${GITADMIN_TEMP_DIR:-$HOME/.local/tmp/system_scripts/gitadmin}"
GITADMIN_CACHE_DIR="${GITADMIN_CACHE_DIR:-$HOME/.cache/gitadmin}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
GITADMIN_OUTPUT_COLOR_1="${GITADMIN_OUTPUT_COLOR_1:-33}"
GITADMIN_OUTPUT_COLOR_2="${GITADMIN_OUTPUT_COLOR_2:-5}"
GITADMIN_OUTPUT_COLOR_GOOD="${GITADMIN_OUTPUT_COLOR_GOOD:-2}"
GITADMIN_OUTPUT_COLOR_ERROR="${GITADMIN_OUTPUT_COLOR_ERROR:-1}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
GITADMIN_NOTIFY_ENABLED="${GITADMIN_NOTIFY_ENABLED:-yes}"
GITADMIN_GOOD_NAME="${GITADMIN_GOOD_NAME:-Great:}"
GITADMIN_ERROR_NAME="${GITADMIN_ERROR_NAME:-Error:}"
GITADMIN_GOOD_MESSAGE="${GITADMIN_GOOD_MESSAGE:-No errors reported}"
GITADMIN_ERROR_MESSAGE="${GITADMIN_ERROR_MESSAGE:-Errors were reported}"
GITADMIN_NOTIFY_CLIENT_NAME="${GITADMIN_NOTIFY_CLIENT_NAME:-$APPNAME}"
GITADMIN_NOTIFY_CLIENT_ICON="${GITADMIN_NOTIFY_CLIENT_ICON:-notification-new}"
GITADMIN_NOTIFY_CLIENT_URGENCY="${GITADMIN_NOTIFY_CLIENT_URGENCY:-normal}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional Variables
GITADMIN_DEFAULT_USERNAME="${GITADMIN_DEFAULT_USERNAME:-$GITHUB_USERNAME}"
GITADMIN_DEFAULT_PLATFORM="${GITADMIN_DEFAULT_PLATFORM:-github}"
GITADMIN_DEFAULT_BRANCH="${GITADMIN_DEFAULT_BRANCH:-main}"
GITADMIN_DEFAULT_REPO_BASE="${GITADMIN_REPO_URL:-https://github.com}"
GITADMIN_DEFAULT_README="${GITADMIN_DEFAULT_README:-default}"
GITADMIN_DEFAULT_LICENSE="${MY_LICENSE_FILE:-$CASJAYSDEVDIR/templates/wtfpl.md}"
GITADMIN_DEFAULT_PROJECT_DIR="${GITADMIN_DEFAULT_PROJECT_DIR:-$HOME/Projects}"
GITADMIN_DEFAULT_GIT_DIR_GITHUB="${GITADMIN_DEFAULT_GIT_DIR_GITHUB:-$GITADMIN_DEFAULT_PROJECT_DIR/github}"
GITADMIN_DEFAULT_GIT_DIR_GITLAB="${GITADMIN_DEFAULT_GIT_DIR_GITLAB:-$GITADMIN_DEFAULT_PROJECT_DIR/gitlab}"
GITADMIN_DEFAULT_GIT_DIR_PRIVATE="${GITADMIN_DEFAULT_GIT_DIR_PRIVATE:-$GITADMIN_DEFAULT_PROJECT_DIR/Private}"
GITADMIN_DEFAULT_USER_DOMAIN="${GITADMIN_DEFAULT_USER_DOMAIN:-}"
GITADMIN_PERSONAL_GIT_HOST="${GITADMIN_PERSONAL_GIT_HOST:-$GIT_PRIVATE_URL}"
GITADMIN_GITHUB_AUTH_TOKEN="${GITADMIN_GITHUB_AUTH_TOKEN:-$GITHUB_ACCESS_TOKEN}"
GITADMIN_DEFAULT_VERSION_FILE="${GITADMIN_DEFAULT_VERSION_FILE:-version.txt}"
GITADMIN_DEFAULT_VERSION_FORMAT="${VERSION_DATE_FORMAT:-%Y%m%d%H%M-git}"
GITADMIN_GITLAB_AUTH_TOKEN="${GITADMIN_GITLAB_AUTH_TOKEN:-$GITLAB_ACCESS_TOKEN}"
GITADMIN_PRIVATE_AUTH_TOKEN="${GITADMIN_PRIVATE_AUTH_TOKEN:-$GIT_PRIVATE_ACCESS_TOKEN}"
GITADMIN_DOMAIN_TEMPLATE="${GITADMIN_DOMAIN_TEMPLATE:-https://github.com/casjay-templates/domain-template}"
GITADMIN_REPO_TYPE="${GITADMIN_REPO_TYPE:-owner}"
GITADMIN_GITHUB_API_VERSION="${GITADMIN_GITHUB_API_VERSION:-2022-11-28}"
GITADMIN_LFS_FILE_TYPES="${GITADMIN_LFS_FILE_TYPES:-*.tar *.gz *.bzip2 *.zip *.rpm *.xz *.7zip *.7z}"
GITADMIN_BACKUP_ORG="${GITADMIN_BACKUP_ORG:-}"
GITADMIN_BACKUP_URL="${GITADMIN_BACKUP_URL:-https://github.com}"
GITADMIN_BACKUP_DIR="${GITADMIN_BACKUP_DIR:-$GITADMIN_CONFIG_DIR/repos}"
GITADMIN_PRIVATE_GIST_SERVER="${GITADMIN_PRIVATE_GIST_SERVER:-https://gist.casjay.work}"
GITADMIN_PRIVATE_GIST_DIR="${GITADMIN_PRIVATE_GIST_DIR:-$GITADMIN_DEFAULT_PROJECT_DIR/gists/${GITADMIN_PRIVATE_GIST_SERVER//*\/\//}}"
GITADMIN_MAIN_CONF_NAME="${GITADMIN_MAIN_CONF_NAME:-gitmainconfig}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Generate config files
[ -f "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE" ] || [ "$*" = "--config" ] || INIT_CONFIG="${INIT_CONFIG:-TRUE}" __gen_config ${SETARGS:-$@}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Import config
[ -f "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE" ] && . "$GITADMIN_CONFIG_DIR/$GITADMIN_CONFIG_FILE"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Ensure Directories exist
[ -d "$GITADMIN_LOG_DIR" ] || mkdir -p "$GITADMIN_LOG_DIR" |& __devnull
[ -d "$GITADMIN_TEMP_DIR" ] || mkdir -p "$GITADMIN_TEMP_DIR" |& __devnull
[ -d "$GITADMIN_CACHE_DIR" ] || mkdir -p "$GITADMIN_CACHE_DIR" |& __devnull
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
GITADMIN_TEMP_FILE="${GITADMIN_TEMP_FILE:-$(mktemp $GITADMIN_TEMP_DIR/XXXXXX 2>/dev/null)}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup trap to remove temp file
trap '__trap_exit' EXIT
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup notification function
__notifications() {
  __cmd_exists notifications || return
  [ "$GITADMIN_NOTIFY_ENABLED" = "yes" ] || return
  [ "$SEND_NOTIFICATION" = "no" ] && return
  (
    export SCRIPT_OPTS="" _DEBUG=""
    export NOTIFY_GOOD_MESSAGE="${NOTIFY_GOOD_MESSAGE:-$GITADMIN_GOOD_MESSAGE}"
    export NOTIFY_ERROR_MESSAGE="${NOTIFY_ERROR_MESSAGE:-$GITADMIN_ERROR_MESSAGE}"
    export NOTIFY_CLIENT_ICON="${NOTIFY_CLIENT_ICON:-$GITADMIN_NOTIFY_CLIENT_ICON}"
    export NOTIFY_CLIENT_NAME="${NOTIFY_CLIENT_NAME:-$GITADMIN_NOTIFY_CLIENT_NAME}"
    export NOTIFY_CLIENT_URGENCY="${NOTIFY_CLIENT_URGENCY:-$GITADMIN_NOTIFY_CLIENT_URGENCY}"
    notifications "$@"
  ) |& __devnull &
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set custom actions
GITADMIN_DEFAULT_USERNAME="${GITADMIN_DEFAULT_USERNAME:-$GITHUB_USERNAME}"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Argument/Option settings
SETARGS=("$@")
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
SHORTOPTS="u:,o:,s:"
SHORTOPTS+=""
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
LONGOPTS="completions:,config,debug,dir:,help,options,raw,version,silent"
LONGOPTS+=",user:,org:,single:,nolicense,noreadme,automated,cd,desc:,site:,delete,nopush,message:,type:,all,visible:"
LONGOPTS+=",github,gitlab,gitea,platform:,private,public,homepage:,description:,issues:,wiki:,projects:,default-branch:"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
ARRAY="project is shorten web latest newsite stow s status l log init setup reset lfs diff branch commit update modify create "
ARRAY+="delete push pull clone merge rebase switch squash remote list gist single user org github gitlab private issues cron "
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
LIST=""
LIST+=""
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup application options
setopts=$(getopt -o "$SHORTOPTS" --long "$LONGOPTS" -n "$APPNAME" -- "$@" 2>/dev/null)
eval set -- "${setopts[@]}" 2>/dev/null
while :; do
  case "$1" in
  --raw)
    shift 1
    export SHOW_RAW="true"
    NC=""
    RESET=""
    BLACK=""
    RED=""
    GREEN=""
    YELLOW=""
    BLUE=""
    PURPLE=""
    CYAN=""
    WHITE=""
    ORANGE=""
    LIGHTRED=""
    BG_GREEN=""
    BG_RED=""
    ICON_INFO="[ info ]"
    ICON_GOOD="[ ok ]"
    ICON_WARN="[ warn ]"
    ICON_ERROR="[ error ]"
    ICON_QUESTION="[ ? ]"
    printf_column() { tee | grep '^'; }
    printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
    ;;
  --debug)
    shift 1
    set -xo pipefail
    export SCRIPT_OPTS="--debug"
    export _DEBUG="on"
    __devnull() { tee || return 1; }
    __devnull2() { eval "$@" |& tee -p || return 1; }
    ;;
  --completions)
    if [ "$2" = "short" ]; then
      printf '%s\n' "-$SHORTOPTS" | sed 's|"||g;s|:||g;s|,|,-|g' | tr ',' '\n'
    elif [ "$2" = "long" ]; then
      printf '%s\n' "--$LONGOPTS" | sed 's|"||g;s|:||g;s|,|,--|g' | tr ',' '\n'
    elif [ "$2" = "array" ]; then
      printf '%s\n' "$ARRAY" | sed 's|"||g;s|:||g' | tr ',' '\n'
    elif [ "$2" = "list" ]; then
      printf '%s\n' "$LIST" | sed 's|"||g;s|:||g' | tr ',' '\n'
    else
      exit 1
    fi
    shift 2
    exit $?
    ;;
  --options)
    shift 1
    printf_blue "Current options for ${PROG:-$APPNAME}"
    [ -z "$SHORTOPTS" ] || __list_options "Short Options" "-${SHORTOPTS}" ',' '-' 4
    [ -z "$LONGOPTS" ] || __list_options "Long Options" "--${LONGOPTS}" ',' '--' 4
    [ -z "$ARRAY" ] || __list_options "Base Options" "${ARRAY}" ',' '' 4
    [ -z "$LIST" ] || __list_options "LIST Options" "${LIST}" ',' '' 4
    exit $?
    ;;
  --version)
    shift 1
    __version
    exit $?
    ;;
  --help)
    shift 1
    __help
    exit $?
    ;;
  --config)
    shift 1
    __gen_config
    exit $?
    ;;
  --silent)
    shift 1
    GITADMIN_SILENT="true"
    ;;
  --dir)
    CWD_IS_SET="TRUE"
    GITADMIN_CWD="$2"
    [ -d "$GITADMIN_CWD" ] || mkdir -p "$GITADMIN_CWD" |& __devnull
    shift 2
    ;;
  --all)
    shift 1
    GITADMIN_RUN_ALL="true"
    ;;
  -s | --single)
    shift 1
    [ "$2" == "help" ] && __printf_help "Usage: $APPNAME --single | clone a single repo"
    __ghsinglerepo "$@"
    exit $?
    ;;
  -u | --user)
    [ "$2" == "help" ] && __printf_help "Usage: $APPNAME --user | List user repos"
    __api_user "${2:-$GITADMIN_DEFAULT_USERNAME}" | __jq -r '.[] | .name' 2>/dev/null | printf_column '4'
    shift 2
    exit $?
    ;;
  -o | --org)
    [ "$2" == "help" ] && __printf_help "Usage: $APPNAME --org | List organization repos"
    __api_org "${2:-$GITADMIN_DEFAULT_USERNAME}" | __jq -r '.[] | .name' 2>/dev/null | printf_column '4'
    shift 2
    exit $?
    ;;
  --nolicense)
    shift 1
    NOLICENSE="yes"
    ;;
  --noreadme)
    shift 1
    NOREADME="yes"
    ;;
  --automated)
    shift 1
    AUTOMATED="true"
    ;;
  --cd)
    shift 1
    GITADMIN_AUTO_CD="true"
    ;;
  --visible)
    GITADMIN_REPO_VISIBLE="$2"
    shift 2
    ;;
  --desc)
    DESCR="$2"
    shift 2
    ;;
  --site)
    SITE="$2"
    shift 2
    ;;
  --delete)
    shift 1
    GITADMIN_MIGRATE_DELETE="true"
    ;;
  --nopush)
    shift 1
    GITADMIN_SETUP_PUSH="no"
    ;;
  --message)
    GITADMIN_SETUP_MESSAGE="$2"
    shift 2
    ;;
  --type)
    GITADMIN_REPO_TYPE="$2"
    shift 2
    ;;
  --github)
    GITADMIN_PLATFORM="github"
    shift 1
    ;;
  --gitlab)
    GITADMIN_PLATFORM="gitlab"
    shift 1
    ;;
  --gitea)
    GITADMIN_PLATFORM="gitea"
    shift 1
    ;;
  --platform)
    GITADMIN_PLATFORM="$2"
    shift 2
    ;;
  --private)
    GITADMIN_REPO_VISIBILITY="private"
    shift 1
    ;;
  --public)
    GITADMIN_REPO_VISIBILITY="public"
    shift 1
    ;;
  --homepage)
    GITADMIN_REPO_HOMEPAGE="$2"
    shift 2
    ;;
  --description)
    GITADMIN_REPO_DESCRIPTION="$2"
    shift 2
    ;;
  --issues)
    GITADMIN_REPO_ISSUES="$2"
    shift 2
    ;;
  --wiki)
    GITADMIN_REPO_WIKI="$2"
    shift 2
    ;;
  --projects)
    GITADMIN_REPO_PROJECTS="$2"
    shift 2
    ;;
  --default-branch)
    GITADMIN_DEFAULT_BRANCH="$2"
    GITADMIN_DEFAULT_BRANCH_SET="yes"
    shift 2
    ;;
  --)
    shift 1
    break
    ;;
  esac
done
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Get directory from args
# set -- "$@"
# for arg in "$@"; do
# if [ -d "$arg" ]; then
# GITADMIN_CWD="$arg" && shift 1 && SET_NEW_ARGS=("$@") && break
# elif [ -f "$arg" ]; then
# GITADMIN_CWD="$(dirname "$arg" 2>/dev/null)" && shift 1 && SET_NEW_ARGS=("$@") && break
# else
# SET_NEW_ARGS+=("$arg")
# fi
# done
# set -- "${SET_NEW_ARGS[@]}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set directory to first argument
[ -d "$1" ] && __is_an_option "$1" && GITADMIN_CWD="$1" && shift 1 || GITADMIN_CWD="${GITADMIN_CWD:-$PWD}"
GITADMIN_CWD="$(realpath "${GITADMIN_CWD:-$PWD}" 2>/dev/null)"
# if [ -d "$GITADMIN_CWD" ] && cd "$GITADMIN_CWD"; then
# if [ "$GITADMIN_SILENT" != "true" ] && [ "$CWD_SILENCE" != "true" ]; then
# printf_cyan "Setting working dir to $GITADMIN_CWD"
# fi
# else
# printf_exit "üíî $GITADMIN_CWD does not exist üíî"
# fi
export GITADMIN_CWD
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set actions based on variables

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for required applications/Network check
#__requiresudo "$0" "$@" || exit 2     # exit 2 if errors
#cmd_exists --error --ask bash || exit 3 # exit 3 if not found
#am_i_online --error || exit 4           # exit 4 if no internet
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# APP Variables overrides
PREVREPO=""
GITADMIN_REMOTE_REPO="$(__git_remote_fetch "$GITADMIN_CWD")"
echo "$GITADMIN_PERSONAL_GIT_HOST" | grep -q '://' || GITADMIN_PERSONAL_GIT_HOST="https://$GITADMIN_PERSONAL_GIT_HOST"
[ -d "$GITADMIN_CWD/.git" ] && GITADMIN_CWD="$(__git_top_dir "$GITADMIN_CWD" 2>/dev/null)"
[ -f "$GITADMIN_CWD/$GITADMIN_DEFAULT_VERSION_FILE" ] && GITADMIN_DEFAULT_VERSION_FILE="$GITADMIN_CWD/$GITADMIN_DEFAULT_VERSION_FILE"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions based on env
[ -n "$GITADMIN_DEFAULT_USERNAME" ] || printf_yellow "Please set GITADMIN_DEFAULT_USERNAME or GITHUB_USERNAME variable in settings" >&2
[ -n "$GITADMIN_GITHUB_AUTH_TOKEN" ] || [ -n "$GITADMIN_GITHUB_AUTH_MESSAGE_SHOWN" ] || printf_exit "Please set GITADMIN_GITHUB_AUTH_TOKEN or GITHUB_ACCESS_TOKEN variable in settings" >&2
export GITADMIN_GITHUB_AUTH_MESSAGE_SHOWN="true"
if [ "$(git config --get user.name | wc -m)" -lt 2 ]; then
  printf_read_input "What is you Name" "120" "GIT_NAME"
  git config --global user.name "$GIT_NAME" 2>/dev/null
  unset GIT_NAME
fi
if [ "$(git config --get user.email | wc -m)" -lt 2 ]; then
  printf_read_input "What is you Email" "120" "GIT_EMAIL"
  git config --global user.email "$GIT_EMAIL" 2>/dev/null
  unset GIT_EMAIL
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute functions

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute commands

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# begin __main app
case "$1" in
#
project)
  shift 1
  if [ "$1" = "" ] || [ $# -eq 0 ]; then
    dirs="$(find "$GITADMIN_DEFAULT_PROJECT_DIR"/*/* -maxdepth 1 -type d -not -path '*/.git*' 2>/dev/null | grep -Ev '.*/.Trash-*|.*/local/*')"
    [ -n "$dirs" ] && printf '%s\n' "${dirs//$GITADMIN_DEFAULT_PROJECT_DIR\//}" | printf_readline
    exit
  fi
  if [ -d "$GITADMIN_DEFAULT_PROJECT_DIR/$1" ]; then
    printf_cyan "Setting working directory to $GITADMIN_DEFAULT_PROJECT_DIR/$1"
    cd "$GITADMIN_DEFAULT_PROJECT_DIR/$1" && $SHELL
  elif [ -d "$1" ]; then
    printf_cyan "Setting working directory to $1"
    cd "$1" && $SHELL
  else
    printf_exit "$1 is not a valid directory"
  fi
  ;;
  # repo status is? clean,dirty
is)
  shift 1
  case "$1" in
  # returns 1 if repo changed
  clean)
    shift 1
    __is_clean "${1:-$GITADMIN_CWD}"
    exit $?
    ;;
  # returns 0 if repo changed
  dirty)
    shift 1
    __is_dirty "${1:-$GITADMIN_CWD}"
    exit $?
    ;;
  # same as clean
  *)
    __is_clean "${1:-$GITADMIN_CWD}"
    exit $?
    ;;
  esac
  ;;

tag)
  shift 1
  case "$1" in
  add)
    shift 1
    [ $# -ne 0 ] || printf_exit "$APPNAME tag add [tag] [message]"
    if __git_tag_add "$@"; then
      printf_blue "Tag has been added to your project"
    else
      printf_return "Failed to add the to your project"
    fi
    exit
    ;;
  remove)
    shift 1
    [ $# -ne 0 ] || printf_exit "$APPNAME tag remove [tag]"
    if __git_tag_del "$@"; then
      printf_green "The tag has been deleted from your project"
    else
      printf_return "Failed to delete the tag from your project"
    fi
    exit
    ;;
  *)
    [ $# -ne 0 ] || printf_exit "$APPNAME tag [add,remove] [tag]"
    __git_release "$@"
    exit $?
    ;;
  esac
  ;;

# show git info
show)
  shift 1
  case $1 in
  dir | root)
    git -C "$GITADMIN_CWD" rev-parse --show-toplevel 2>/dev/null
    exit $?
    ;;
  url | remote)
    shift 1
    git -C "$GITADMIN_CWD" remote show origin | grep 'Push' | awk -F 'URL: ' '{print $2}' 2>/dev/null
    exit $?
    ;;
  *) exit 1 ;;
  esac
  ;;

# github url shortner
shorten)
  shift 1
  { [ "$1" = "help" ] || [ -z "$1" ]; } && __printf_help "Usage: gitadmin shorten [url] [name]"
  git_io "$@"
  ;;

web)
  shift 1
  REMOTE_REPO="$(__git_remote_push "$GITADMIN_CWD")"
  if [ -n "$REMOTE_REPO" ]; then mybrowser "$REMOTE_REPO"; else printf_return "ERROR: Can not get remote "; fi
  exit $?
  ;;

# get the latest release
latest)
  shift 1
  { [ "$1" = "help" ] || [ -z "$1" ]; } && __printf_help "Usage: gitadmin latest [userName] [repoName] [arch]"
  printf_red "This has been moved to install-latest"
  install-latest install "$@"
  ;;
  # create a new site
newsite)
  shift 1
  { [ "$1" = "help" ] || [ -z "$1" ]; } && __printf_help "Usage: gitadmin newsite [sitename] [template:default]"
  __make_newsite "$@"
  ;;

  # backup dotfiles
stow)
  shift 1
  { [ "$1" = "help" ] || [ -z "$1" ]; } && __printf_help "Usage: gitadmin stow [files]"
  config "$@"
  ;;

# repo status
s | status)
  shift 1
  [ "$1" = "help" ] && __printf_help "Usage: gitadmin status"
  [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
  [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD doesn't seem to be a git repo"
  __git_status "$GITADMIN_CWD"
  exit $?
  ;;

# git log
l | log)
  shift 1
  [ "$1" = "help" ] && __printf_help "Usage: gitadmin log"
  [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
  [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD doesn't seem to be a git repo"
  __test_if_number $1 && count=$1 && shift 1
  __git_log "$GITADMIN_CWD" $count
  exit $?
  ;;

# initialize repo
init)
  shift 1
  [ "$1" = "help" ] && __printf_help "Usage: gitadmin init"
  [ -d "$1" ] && GITADMIN_CWD="$1" && shift 1
  git_init "$@"
  ;;

# initialize repo
setup)
  shift 1
  [ "$1" = "help" ] && __printf_help "Usage: gitadmin setup [--automated]"
  [ -d "$1" ] && GITADMIN_CWD="$1" && shift 1
  if [ "$AUTOMATED" = "true" ]; then
    __run_git_setup_automated "$@"
  else
    __run_git_setup "$@"
  fi
  ;;

# Reset the repo
reset)
  shift 1
  [ "$1" = "yes" ] && reset_repo=y && shift 1
  set_number="$1"
  [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD is not valid repo"
  { __test_if_number $set_number || [ "$set_number" != "help" ] || [ $# -ne 0 ]; } || __printf_help "Usage: $APPNAME reset 2"
  [ "$reset_repo" = "y" ] || printf_read_question "3" "Are you sure you want to reset? " "1" "reset_repo"
  [ "$set_number" = "1" ] && set_number=2
  current_id="$(__git_log "$GITADMIN_CWD" | head -n1 | awk '{print $1}')"
  if printf_answer_yes "$reset_repo"; then
    #if git -C "$GITADMIN_CWD" log | grep -wF "$set_number"; then
    #  go_back="$set_number"
    #else
    go_back="$(__git_log "$GITADMIN_CWD" | head -n$set_number | tail -n1 | awk '{print $1}')"
    #fi
    if [ -n "$go_back" ]; then
      [ "$go_back" = "$current_id" ] && printf_exit "You seem to be at the first commit: $current_id"
      printf_purple "reverting back to commit $go_back from $current_id"
      git -C "$GITADMIN_CWD" reset --hard $go_back | printf_readline
      exit $?
    else
      printf_exit "Can not determine the git id"
    fi
  else
    printf_exit 1 1 "Guess you decided against the reset"
  fi
  ;;

# lfs
lfs)
  shift 1
  exitCode=0
  [ "$1" = "help" ] && __printf_help "gitadmin lfs [fetch,checkout,add]"
  [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD is not a git repo"
  git lfs --help 2>&1 | grep -vq 'is not a git command' || pkmgr silent install git-lfs || printf_exit "git lfs is not installed"
  [ -f "$GITADMIN_CONFIG_DIR/lfs_init" ] || { git lfs install &>/dev/null && touch "$GITADMIN_CONFIG_DIR/lfs_init"; }
  case "$1" in
  init)
    shift 1
    if [ ! -f "$GITADMIN_CWD/.gitattributes" ]; then
      if [ ! -f "$GITADMIN_CWD/.gitignore" ]; then
        printf_cyan "Creating .gitignore in $GITADMIN_CWD"
        gitignore $d default &>/dev/null
      fi
      if [ ! -f "$GITADMIN_CWD/.gitattributes" ]; then
        printf_cyan "Creating .gitattributes in $GITADMIN_CWD"
        gen-gitattr $d save default lfs &>/dev/null
      fi
      for repo_file in $GITADMIN_LFS_FILE_TYPES; do
        printf_cyan "Adding $repo_file to LFS"
        git -C "$GITADMIN_CWD" lfs track "$repo_file" &>/dev/null
        git -C "$GITADMIN_CWD" commit -m "üîµ Added LFS object: $repo_file üîµ" --quiet
      done
      git -C "$GITADMIN_CWD" add .gitattributes &>/dev/null && git -C "$GITADMIN_CWD" commit -m "üîµ Added .gitattributes üîµ" --quiet
      exitCode=$?
      [ $exitCode -eq 0 ] && { [ "$GITADMIN_SETUP_PUSH" != "no" ] && git -C "$GITADMIN_CWD" push --quiet && exitCode=0 || exitCode=1; }
    fi
    [ "$exitCode" -eq 0 ] && printf_cyan "$GITADMIN_CWD has been initialized for LFS support" || printf_red "Failed to setup $GITADMIN_CWD for LFS support"
    exit $exitCode
    ;;
  fetch)
    shift 1
    git -C "$GITADMIN_CWD" fetch --all && exitCode=0 || exitCode=1
    printf '\n'
    exit $exitCode
    ;;
  checkout)
    shift 1
    git -C "$GITADMIN_CWD" lfs checkout && exitCode=0 || exitCode=1
    printf '\n'
    exit $exitCode
    ;;
  add)
    shift 1
    exitCode=0
    add_files="${*:-$GITADMIN_LFS_FILE_TYPES}"
    touch "$GITADMIN_CWD/.gitattributes"
    for file in $add_files; do
      repo_file="${file//$GITADMIN_CWD\//}"
      printf_cyan "Adding $repo_file to LFS"
      git -C "$GITADMIN_CWD" lfs track "$repo_file" &>/dev/null
      git -C "$GITADMIN_CWD" commit -m "üîµ Added LFS object: $repo_file üîµ" --quiet
      git -C "$GITADMIN_CWD" lfs migrate import --no-rewrite --yes --include="$repo_file"
    done
    if [ "$GITADMIN_SETUP_PUSH" != "no" ]; then
      git -C "$GITADMIN_CWD" push && exitCode=0 || exitCode=1
    fi
    printf '\n'
    exit $exitCode
    ;;
  pull | clone)
    printf_green "Running git lfs fetch in $GITADMIN_CWD"
    git -C "$GITADMIN_CWD" fetch --all && git -C "$GITADMIN_CWD" lfs checkout && exitCode=0 || exitCode=1
    exit $exitCode
    ;;
  *)
    printf_green "Running git lfs fetch in $GITADMIN_CWD"
    git -C "$GITADMIN_CWD" fetch --all && git -C "$GITADMIN_CWD" lfs checkout && exitCode=0 || exitCode=1
    exit $exitCode
    ;;
  esac
  exit $?
  ;;

diff)
  shift 1
  __test_if_number $1 && count=$1 || count=6
  git -C "$GITADMIN_CWD" diff HEAD^ HEAD -- file | grep '@@' -B10 | head -n$count
  exit $?
  ;;

# branch options
branch)
  shift 1
  case $1 in
  rename)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin rename branch newname userName repoName"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD doesn't seem to be a git repo"
    __rename_branch "${1:-main}" $2 $3
    exit $?
    ;;
  *)
    { [ $# = 0 ] || [ "$1" = "help" ] && printf_exit 1 2 "Usage: $APPNAME branch fromBranch toBranch - $APPNAME branch rename master main"; }
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    fromBranch="${1:-master}"
    toBranch="${2:-main}"
    git -C "$GITADMIN_CWD" branch -m $fromBranch $toBranch
    git -C "$GITADMIN_CWD" fetch origin
    git -C "$GITADMIN_CWD" branch -u origin/$fromBranch $toBranch
    git -C "$GITADMIN_CWD" remote set-head origin -a
    git -C "$GITADMIN_CWD" push --set-upstream origin $toBranch
    git -C "$GITADMIN_CWD" branch -d $fromBranch
    exit $?
    ;;
  esac
  ;;

backup)
  shift 1
  __backup_repos "$@"
  exit $?
  ;;

# commit changes
commit)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin commit [message]"
  [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
  gitcommit --dir "$GITADMIN_CWD" "${@:-all}"
  ;;

# update local repos
update)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin update [--while]"
  __git_update_loop "$@"
  ;;

# modify repo settings
modify)
  shift 1
  { [ $# -lt 1 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin --platform github modify userName/repoName --description 'desc' --private"

  user="" repo="" platform="${GITADMIN_PLATFORM:-}"
  modify_args=""

  # Check if we're in a git directory and use current repo
  if [ "$1" = "." ] || { [ $# -eq 0 ] && [ -d "$GITADMIN_CWD/.git" ]; }; then
    shift
    # Get repo info from current directory
    remote_url="$(git -C "$GITADMIN_CWD" remote get-url origin 2>/dev/null)"
    [ -z "$remote_url" ] && printf_exit "Not in a git repository or no remote origin set"

    # Detect platform if not set via flag
    [ -z "$platform" ] && platform="$(__detect_git_platform "$remote_url")"

    # Extract user and repo from URL
    case "$remote_url" in
    *github.com* | *gitlab.com* | *gitea* | *git.*)
      user="$(echo "$remote_url" | sed -E 's|.*[:/]([^/]+)/[^/]+(\.git)?$|\1|')"
      repo="$(echo "$remote_url" | sed -E 's|.*[:/][^/]+/([^/]+)(\.git)?$|\1|' | sed 's|\.git$||')"
      ;;
    *)
      printf_exit "Could not parse repository URL: $remote_url"
      ;;
    esac
  elif echo "$1" | grep -q '/'; then
    # Parse user/repo format
    user="${1%%/*}"
    repo="${1##*/}"
    shift

    # Use platform from flag or detect
    if [ -z "$platform" ]; then
      if [ -d "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$user/$repo/.git" ]; then
        platform="gitlab"
      elif [ -d "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$user/$repo/.git" ]; then
        platform="gitea"
      else
        platform="github" # Default
      fi
    fi
  else
    printf_exit "Please specify userName/repoName or use . for current repo"
  fi

  # Build full URL for display
  display_url=""
  case "$platform" in
  github)
    display_url="https://github.com"
    ;;
  gitlab)
    display_url="htts://gitlab.com"
    ;;
  gitea | private)
    display_url="$GITADMIN_PERSONAL_GIT_HOST"
    ;;
  *)
    display_url="$platform"
    ;;
  esac

  # Variables are already set by getopt, no need to rebuild arguments
  printf_cyan "üîÑ Modifying $user/$repo on $display_url"
  __universal_repo_modify "$platform" "$user" "$repo"
  exit $?
  ;;

# create repo (intelligent platform detection)
create)
  shift 1
  { [ $# -lt 1 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin --platform github create userName/repoName 'Description' --private"

  platform="${GITADMIN_PLATFORM:-}"
  user="" repo="" description=""
  visibility="${GITADMIN_REPO_VISIBILITY:-public}"
  homepage="${GITADMIN_REPO_HOMEPAGE:-}"

  # Parse user/repo
  if echo "$1" | grep -q '/'; then
    user="${1%%/*}"
    repo="${1##*/}"
  else
    user="$1"
    repo="$2"
    shift
  fi
  shift

  # Get description from argument or getopt variable
  if [ -n "$1" ] && [ "${1:0:1}" != "-" ]; then
    description="$1"
    shift
  else
    description="${GITADMIN_REPO_DESCRIPTION:-Repository for $repo}"
  fi

  # Auto-detect platform if not specified
  if [ -z "$platform" ]; then
    # Use GITADMIN_DEFAULT_PLATFORM if set, otherwise default to github
    platform="${GITADMIN_DEFAULT_PLATFORM:-github}"
  fi

  __universal_repo_create "$platform" "$user" "$repo" "$description" "$visibility" "$homepage"
  exit $?
  ;;

# delete repo (intelligent platform detection)
delete)
  shift 1
  { [ $# -lt 1 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin --platform github delete userName/repoName"

  platform="${GITADMIN_PLATFORM:-}" user="" repo=""

  # Check if we're in a git directory and use current repo
  if [ "$1" = "." ] || { [ $# -eq 0 ] && [ -d "$GITADMIN_CWD/.git" ]; }; then
    # Get repo info from current directory
    remote_url="$(git -C "$GITADMIN_CWD" remote get-url origin 2>/dev/null)"
    [ -z "$remote_url" ] && printf_exit "Not in a git repository or no remote origin set"

    # Detect platform if not specified
    [ -z "$platform" ] && platform="$(__detect_git_platform "$remote_url")"

    # Extract user and repo from URL
    case "$remote_url" in
    *github.com* | *gitlab.com* | *gitea* | *git.*)
      user="$(echo "$remote_url" | sed -E 's|.*[:/]([^/]+)/[^/]+(\.git)?$|\1|')"
      repo="$(echo "$remote_url" | sed -E 's|.*[:/][^/]+/([^/]+)(\.git)?$|\1|' | sed 's|\.git$||')"
      ;;
    *)
      printf_exit "Could not parse repository URL: $remote_url"
      ;;
    esac
  elif echo "$1" | grep -q '/'; then
    # Parse user/repo format
    user="${1%%/*}"
    repo="${1##*/}"
  else
    user="$1"
    repo="$2"
  fi

  # Auto-detect platform if not specified
  if [ -z "$platform" ]; then
    if [ -n "$GITADMIN_PLATFORM" ]; then
      platform="$GITADMIN_PLATFORM"
    elif [ -d "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$user/$repo/.git" ]; then
      platform="gitlab"
    elif [ -d "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$user/$repo/.git" ]; then
      platform="gitea"
    else
      # Try to detect from any existing remote
      test_dir="$GITADMIN_DEFAULT_PROJECT_DIR/*/$user/$repo"
      if [ -d "$test_dir/.git" ]; then
        test_url="$(git -C $test_dir remote get-url origin 2>/dev/null)"
        [ -n "$test_url" ] && platform="$(__detect_git_platform "$test_url")"
      fi
      [ -z "$platform" ] && platform="github" # Default
    fi
  fi

  __universal_repo_delete "$platform" "$user" "$repo"
  exit $?
  ;;

  # push a repo
push)
  shift 1
  [ "$1" = "help" ] && __printf_help "Usage: gitadmin push [MyProjectDir,all]"
  if [ "$1" = "all" ] || [ "$GITADMIN_RUN_ALL" = "true" ]; then
    repo_dirs="$(ls -d "$GITADMIN_DEFAULT_PROJECT_DIR"/*/*/* 2>/dev/null | grep -v "$GITADMIN_DEFAULT_PROJECT_DIR/local/**" | grep '^' || false)"
    #repo_dirs="$(find "$GITADMIN_DEFAULT_PROJECT_DIR"/*/"$GITADMIN_DEFAULT_USERNAME"/* -maxdepth 0 -type d | grep '^' || echo '')"
    [ -n "$repo_dirs" ] || printf_exit "Could not find any directories for $GITADMIN_DEFAULT_USERNAME in $GITADMIN_DEFAULT_PROJECT_DIR"
    for dir in $repo_dirs; do
      [ -d "$dir/.git" ] && __git_push_single "$dir"
    done
  else
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    __git_push_single "${@:-$GITADMIN_CWD}"
  fi
  ;;

  # update repo
pull)
  shift 1
  [ "$1" = "help" ] && __printf_help "Usage: gitadmin pull [MyProjectDir]"
  GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
  if [ "$1" = "all" ] || [ "$GITADMIN_RUN_ALL" = "true" ]; then
    repo_dirs="$(ls -d "$GITADMIN_DEFAULT_PROJECT_DIR"/*/*/* 2>/dev/null | grep -v "$GITADMIN_DEFAULT_PROJECT_DIR/local/**" | grep '^' || false)"
    #repo_dirs="$(find "$GITADMIN_DEFAULT_PROJECT_DIR"/*/"$GITADMIN_DEFAULT_USERNAME"/* -maxdepth 0 -type d | grep '^' || echo '')"
    [ -n "$repo_dirs" ] || printf_exit "Could not find any directories for $GITADMIN_DEFAULT_USERNAME in $GITADMIN_DEFAULT_PROJECT_DIR"
    for dir in $repo_dirs; do
      [ -d "$dir/.git" ] && __git_pull_single "$dir"
    done
  else
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    __git_pull_single "${@:-$GITADMIN_CWD}"
  fi

  ;;

# Clone repo from url
clone)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin clone MyURL"
  GITADMIN_REPO_URL="$(__strip_git_url "$1")" && shift 1
  __if_is_url "$GITADMIN_REPO_URL" || GITADMIN_REPO_URL="https://github.com/$GITADMIN_REPO_URL"
  __create_dirs "${1:-}"
  __git_clone_single "$GITADMIN_REPO_URL" "${1:-}"
  ;;

  # merge options
merge)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin merge [toBranch] [fromBranch]"
  [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
  git -C "$GITADMIN_CWD" switch $1
  git -C "$GITADMIN_CWD" merge $2
  ;;

  # rebase options
rebase)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin rebase [fromBranch] [toBranch]"
  [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
  git -C "$GITADMIN_CWD" switch $1
  git -C "$GITADMIN_CWD" rebase $2
  ;;

# switch between branches
switch)
  shift 1
  case $1 in
  create)
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin switch create [branchName]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" switch -c $1
    exit $?
    ;;

  *)
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin switch [branchName]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" switch $1
    exit $?
    ;;
  esac
  ;;

# squash options
squash)
  shift 1
  case $1 in
  head)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin squash head [number]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" rebase -i HEAD~$1
    exit $?
    ;;
  merge)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin squash merge [hash]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" merge --squash $1
    exit $?
    ;;
  rebase)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin squash rebase [hash]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" rebase -i $1
    exit $?
    ;;
  *)
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin squash [hash]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" rebase -i $1
    exit $?
    ;;
  esac
  ;;

# Remote options
remote)
  shift 1
  [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
  case "$1" in
  show)
    shift 1
    [ "$1" = "help" ] && __printf_help "Usage: gitadmin remote show [name]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    git -C "$GITADMIN_CWD" remote show "${1:-origin}"
    exit $?
    ;;
  add)
    shift 1
    [ "$1" = "help" ] && __printf_help "Usage: gitadmin remote add [remoteURL] [name]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    GITADMIN_REPO_URL="$(__strip_git_url "$1")"
    printf_cyan "Adding remote: $GITADMIN_REPO_URL"
    git -C "$GITADMIN_CWD" remote add ${2:-origin} "$GITADMIN_REPO_URL" &>/dev/null &&
      git push --set-upstream origin __main -q
    exit $?
    ;;
  *)
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    [ "$1" = "help" ] && __printf_help "Usage: gitadmin remote [show,add]"
    git -C "$GITADMIN_CWD" remote show ${1:-origin}
    exit $?
    ;;
  esac
  ;;

# list user orgs
list)
  shift 1
  [ "$1" = "help" ] && __printf_help "Usage: gitadmin list [user]"
  if [ "$1" = "raw" ]; then
    shift 1
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    [ -n "$GITADMIN_DEFAULT_USERNAME" ] || __printf_help "Usage: $APPNAME list [raw] github_user"
    __git_retrieve_orgs "$GITADMIN_DEFAULT_USERNAME"
    echo "$GIT_ALL_REPOS" | tr ' ' '\n'
  else
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    [ -n "$GITADMIN_DEFAULT_USERNAME" ] || __printf_help "Usage: $APPNAME list [raw] github_user"
    __git_retrieve_orgs "$GITADMIN_DEFAULT_USERNAME"
    printf_green "I have found the following organizations"
    echo "$GIT_ALL_REPOS" | tr ' ' '\n' | printf_column "5"
    printf_newline
  fi
  ;;

# gist options
gist)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin gist [clone,create,delete,edit,list,search]"
  case "$1" in
  clone)
    shift 1
    [ $# -lt 1 ] && __printf_help "Usage: gitadmin gist clone id [directory]"
    SET_REPO="$(curl -q -LSsfI "https://gist.github.com/$1" | grep 'location: https://' | head -n1 | awk -F': ' '{print $2}' | grep "$1" || echo '')"
    GITADMIN_REPO_URL="$(__strip_git_url "$SET_REPO")"
    GIST_USER="$(basename -- "$(dirname "$SET_REPO")" | grep '^')"
    GISTNAME="$(basename -- "$GITADMIN_REPO_URL")"
    GISTDIR="${2:-$GITADMIN_DEFAULT_PROJECT_DIR/gists/$GIST_USER/$GISTNAME}"
    printf_cyan "Cloning $GITADMIN_REPO_URL > $GISTDIR"
    __git_clone "$GITADMIN_REPO_URL" "$GISTDIR"
    exit $?
    ;;

  create)
    shift 1
    [ "$1" = "help" ] && __printf_help "Usage: gitadmin gist create 'description' 'filename' [text/file]"
    if [ $# -eq 3 ]; then
      descript="$1" && shift 1
      filename="$1" && shift 1
      contents="$1" && shift 1
    elif [ $# -eq 2 ]; then
      filename="$1" && shift 1
      descript="$1" && shift 1
    elif [ $# -eq 1 ]; then
      filename="$1" && shift 1
    fi
    [ -f "$filename" ] && contents="$filename" || contents="${contents:-$filename}"
    [ $# -ne 0 ] && contents="${contents:-$(cat -)}"
    if [ $# -eq 0 ] && [ -p "/dev/stdin" ]; then
      cat - >"$GITADMIN_TEMP_FILE" 2>/dev/null
      descript="${descript:-$(grep -sh ' @@Description' "$GITADMIN_TEMP_FILE" | awk -F ':  ' '{print $2}' | sed 's|^  ||g' | head -n1 | grep '^' || echo 'new gist')}"
    elif [ -f "$contents" ]; then
      descript="${descript:-$(basename -- "$contents")}"
      cat "$contents" >"$GITADMIN_TEMP_FILE"
      filename="$contents"
    elif [ -n "$contents" ]; then
      descript="${descript:-}"
      printf '%s\n' "$contents" >"$GITADMIN_TEMP_FILE"
    else
      printf '' >"$GITADMIN_TEMP_FILE"
    fi
    descript="${DESCR:-${descript:-New Gist}}"
    filename="${filename:-$(basename -- "${filename:-gistfile1.txt}")}"
    [ -s "$GITADMIN_TEMP_FILE" ] && contents="$(<"$GITADMIN_TEMP_FILE")"
    [ -n "$contents" ] || printf_exit "Usage: gitadmin gist create 'description' 'filename' [text/file]"
    ghgist_create "$descript" "$filename" "$contents"
    exit $?
    ;;

  delete)
    shift 1
    { [ $# -lt 1 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin gist delete [GIT_URL or GIST_ID]"
    ghgist_delete "$@"
    exit $?
    ;;

  edit)
    shift 1
    { [ $# -lt 3 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin gist edit GIST_ID description filename text"
    ghgist_edit "$@"
    exit $?
    ;;

  list)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin gist list GIST_USER"
    ghgist_list "$@"
    exit $?
    ;;

  search)
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin gist search GIST_USER SearchTerm"
    search_list "$@"
    exit $?
    ;;
  esac
  ;;

  # Single repo options
single)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __help
  case $1 in
  # init a github repo
  init)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin single init RepoName"
    do_not_add_a_url "${1:-$GITADMIN_CWD}"
    if echo "${1:-$GITADMIN_CWD}" | grep -q '\.git$'; then
      homerepo="$(echo "${1:-$GITADMIN_CWD}" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(__strip_git_url "${1:-$GITADMIN_CWD}")"
    fi
    __mkd "$homerepo" && [ ! -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to initialize $homerepo"
    __repos_init "$homerepo"
    exit "$?"
    ;;

    # push a repo
  push)
    shift 1
    [ "$1" = "help" ] && __printf_help "Usage: $APPNAME push >$GISTDIR"
    __git_clone "$REPO_URL" "$GISTDIR"
    exit $?
    ;;

    # update repo
  pull)
    shift 1
    [ "$1" = "help" ] && __printf_help "Usage: $APPNAME update | pull the repos"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    __git_pull_single "${@:-$GITADMIN_CWD}"
    ;;

    # Clone repo from url
  clone)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: $APPNAME clone [URL] [directory] | clone the repos"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    [ $# -eq 0 ] && __printf_help "Usage: $APPNAME clone [URL] [directory] | clone the repos"
    GITADMIN_REPO_URL="$(__strip_git_url "$1")"
    __git_clone_single "$GITADMIN_REPO_URL" "${2:-$GITADMIN_CWD}"
    ;;
  esac
  ;;

# User repos
user)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin user [clone,orgs] [userName]"
  case "$1" in
  orgs)
    shift 1
    [ "$1" = "help" ] && __printf_help "Usage: gitadmin user orgs [userName]"
    GITADMIN_DEFAULT_USERNAME="$1"
    __git_retrieve_orgs "$GITADMIN_DEFAULT_USERNAME"
    printf_newline
    printf_green "I have found the following organizations"
    echo "$GIT_ALL_REPOS" | tr ' ' '\n' | grep -v '^$' | printf_column "5"
    ;;
  clone)
    shift 1
    __github_user_clone_repos "${GITADMIN_DEFAULT_USERNAME:-$1}"
    ;;
  *)
    __github_user_clone_repos "${GITADMIN_DEFAULT_USERNAME:-$1}"
    ;;
  esac
  ;;

# organization options
org)
  shift 1
  [ "$1" = "help" ] && __printf_help "Usage: gitadmin org [list,all,push,pull,clone] [userName]"
  case "$1" in
  # Show repos owned by org
  repos)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin org repos [userName]"
    __github_org_list_repos "$1"
    ;;

  all)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin org all [userName]"
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    __git_all_orgs_clone "$GITADMIN_DEFAULT_USERNAME"
    ;;

  push)
    shift 1
    [ "$1" = "help" ] && __printf_help "Usage: gitadmin org push [userName]"
    [ -z "$GITADMIN_GITHUB_AUTH_TOKEN" ] && printf_exit "ERROR: GITADMIN_GITHUB_AUTH_TOKEN is not set"
    __github_org_push_repos "$1"
    exit $?
    ;;

  pull)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin org pull [userName]"
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    GITADMIN_DEFAULT_REPO_BASE="$GITADMIN_DEFAULT_REPO_BASE/$GITADMIN_DEFAULT_USERNAME"
    __api_user_token "$GITADMIN_DEFAULT_USERNAME"
    __curl_gh_api "$GITHUBAPIREPO" | grep -w clone_url | awk -F / '{print $NF}' | __sed 's/\",//' | __sed 's/\.[^.]*$//' >"$GITADMIN_TEMP_FILE"
    COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
    [ -n "$COUNT" ] || printf_exit "No repos found for $GITADMIN_DEFAULT_USERNAME"
    printf_green "$MESSAGE"
    printf_blue "There's currently $COUNT repos available"
    printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
    __main "$GITADMIN_DEFAULT_USERNAME"
    ;;

  clone)
    shift 1
    { [ $# -eq 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin org clone [userName]"
    GITADMIN_DEFAULT_USERNAME="${1:-$GITADMIN_DEFAULT_USERNAME}"
    GITADMIN_DEFAULT_REPO_BASE="$GITADMIN_DEFAULT_REPO_BASE/$GITADMIN_DEFAULT_USERNAME"
    __create_dirs
    __api_org_token "$GITADMIN_DEFAULT_USERNAME" || exit 1
    __curl_gh_api $GITHUBAPIREPO | grep -w clone_url | awk -F / '{print $NF}' | __sed 's/\",//' | __sed 's/\.[^.]*$//' >"$GITADMIN_TEMP_FILE"
    COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
    [ -n "$COUNT" ] || printf_exit "No repos found for $GITADMIN_DEFAULT_USERNAME"
    printf_green "$MESSAGE"
    printf_blue "There's currently $COUNT repos available"
    printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
    __main "$GITADMIN_DEFAULT_REPO_BASE"
    ;;

  *)
    [ "$1" = "all" ] && shift
    { [ -z $1 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin org [userName]"
    __create_dirs
    GIT_ALL_REPOS="$*"
    repo_base="$GITADMIN_DEFAULT_REPO_BASE"
    for org in ${GIT_ALL_REPOS//,/ }; do
      GITADMIN_DEFAULT_USERNAME="$org"
      GITADMIN_DEFAULT_REPO_BASE="$repo_base"
      __git_retrieve_orgs "$org"
      __clone_orgs "$org"
    done
    ;;
  esac
  ;;

# github repo
github)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __help
  case $1 in
  # create github repo
  all)
    shift 1
    case $1 in
    clone)
      shift 1
      __git_all_clone "$1"
      exit $?
      ;;
    commit)
      shift 1
      __git_all_commit "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$(basename -- $1)"
      exit $?
      ;;
    pull)
      shift 1
      __git_all_pull "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$(basename -- $1)"
      exit $?
      ;;

    push)
      shift 1
      __git_all_push "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$(basename -- $1)"
      exit $?
      ;;
    esac
    ;;
  create)
    shift 1
    { [ $# -lt 1 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin github create userName repoName Description"
    __github_create_repo "$@"
    exit $?
    ;;

    # init a github repo
  init)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin github init RepoName"
    __create_dirs
    do_not_add_a_url "$1"
    if echo "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$1" | grep -q '\.git$'; then
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$1" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$1")"
    fi
    __mkd "$homerepo" && [ ! -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to initialize $homerepo"
    __repos_init "$homerepo"
    exit "$?"
    ;;

    # Clone repo from github
  clone)
    shift 1
    { [ $# -lt 1 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin github clone username/projectname"
    url="$(echo "$*" | tr ' ' '/')"
    __create_dirs
    do_not_add_a_url "$url"
    remote_repo="https://github.com/$(__strip_git_url "$url")"
    if echo "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$1" | grep -q '\.git$'; then
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$url" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITHUB/$url")"
    fi
    if [ -d "$homerepo/.git" ]; then
      printf_green "‚ÑπÔ∏è The repo already exists so attempting update"
      __git_pull_single "$homerepo"
      retVal=$?
    else
      printf_green "üîΩ Cloning the repo from $remote_repo"
      mkdir -p "$homerepo"
      __git_clone_single "$remote_repo" "$homerepo"
      retVal=$?
    fi
    [ -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to clone to $homerepo"
    exit "$retVal"
    ;;

    # Push
  push)
    shift 1
    [ $# -eq 0 ] && [ -d "$PWD/.git" ] && homerepo="$PWD" || { [ -n "$1" ] && [ -d "$1/.git" ] && homerepo="$1"; } || homerepo="$(ls -d "$GITADMIN_DEFAULT_GIT_DIR_GITHUB"/*/*)"
    for d in $homerepo; do
      __mkd "$d" && [ -d "$d/.git" ] && __cd_into "$d" || printf_exit 1 1 "failed to push from: $d"
      __git_push_single "$d"
    done
    ;;

    # update repo
  pull)
    shift 1
    [ "$1" = "help" ] && __printf_help "Usage: $APPNAME update | pull the repos"
    [ $# -eq 0 ] && [ -d "$PWD/.git" ] && homerepo="$PWD" || { [ -n "$1" ] && [ -d "$1/.git" ] && homerepo="$1"; } || homerepo="$(ls -d "$GITADMIN_DEFAULT_GIT_DIR_GITHUB"/*/*)"
    for d in $homerepo; do
      __mkd "$d" && [ -d "$d/.git" ] && __cd_into "$d" || printf_exit 1 1 "failed to pull to: $d"
      __git_pull_single "$d"
    done
    ;;

    # add github to remote
  remote)
    shift 1
    { [ $# -lt 2 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin github remote [username/projectname] [name]"
    [ -d "$1/.git" ] && GITADMIN_CWD="$1" && shift 1
    do_not_add_a_url "$1"
    git -C "$GITADMIN_CWD" remote add "${2:-orgin}" "https://github.com/$1.git"
    exit "$?"
    ;;

    # update repo info
  update)
    shift 1
    __update_github_repo "$@"
    exit $?
    ;;

  orgs)
    shift 1
    case "$1" in
    clone)
      shift 1
      exitStatus=0
      repo_base="$GITADMIN_DEFAULT_REPO_BASE"
      project_dir="$GITADMIN_DEFAULT_GIT_DIR_GITHUB"
      for org in "$@"; do
        GITADMIN_DEFAULT_REPO_BASE="$repo_base"
        GITADMIN_DEFAULT_GIT_DIR_GITHUB="$project_dir"
        __github_org_clone_repos "$org"
        exitStatus=$((exitStatus + $?))
      done
      exit $exitStatus
      ;;
    visibility)
      shift 1
      [ "$1" = "help" ] && __printf_help "Usage: gitadmin orgs visibility [show|public|private] [orgName]"
      __github_orgs_visibility "$@"
      exit $?
      ;;
    list)
      shift 1
      exitStatus=0
      repo_base="$GITADMIN_DEFAULT_REPO_BASE"
      project_dir="$GITADMIN_DEFAULT_GIT_DIR_GITHUB"
      for org in "$@"; do
        GITADMIN_DEFAULT_REPO_BASE="$repo_base"
        GITADMIN_DEFAULT_GIT_DIR_GITHUB="$project_dir"
        __github_org_list_repos "$org"
        exitStatus=$((exitStatus + $?))
      done
      exit $exitStatus
      ;;

    update)
      shift 1
      if [ "$1" = "all" ]; then
        shift 1
        ORG_REPO_NAME="${1//\/*/}" && shift 1
        __api_org_token "$ORG_REPO_NAME" | sort -u >"$GITADMIN_TEMP_FILE" || echo >"$GITADMIN_TEMP_FILE"
        COUNT="$(cat "$GITADMIN_TEMP_FILE" | wc -l | grep '^')"
        if [ -n "$COUNT" ]; then
          printf_green "$MESSAGE"
          printf_blue "There's currently $COUNT repos available"
          printf_green "Initializing $GITADMIN_DEFAULT_REPO_BASE"
          repo_list="$(<"$GITADMIN_TEMP_FILE")"
          __github_org_options_set "$@"
          for i in $repo_list; do
            __github_org_options_repos "$ORG_REPO_NAME/$i"
          done
        else
          exitCode=1
          printf_red "üòø No repos found for $ORG_REPO_NAME/$i üòø"
        fi
      else
        ORG_REPO_NAME="$1" && shift 1
        __github_org_options_set "$@"
        __github_org_options_repos "$ORG_REPO_NAME"
      fi
      exit $?
      ;;
    *) ;;
    esac
    ;;

    # github pages
  pages)
    shift 1
    case "$1" in
    # force a build
    build)
      shift 1
      [ $# -ne 0 ] && [ "$1" != "help" ] || printf_exit 1 3 "Usage: build [username/repo]"
      status="$(curl -q -LSsf -X "POST" -H 'Accept: application/vnd.github+json' -H 'Authorization: token '$GITADMIN_GITHUB_AUTH_TOKEN'' -H 'X-GitHub-Api-Version: 2022-11-28' 'https://api.github.com/repos/'$1'/pages/builds' | __jq -rc '.url')"
      [ -n "$status" ] && printf_cyan "Build info: $status" || printf_exit 33 1 "The server returned an error: $(cat "$GITADMIN_TEMP_FILE" | grep 'error' | sed 's|.*error: ||g' | head -n1)"
      exit $?
      ;;

      # create a page
    create)
      shift 1
      [ $# -ne 0 ] && [ "$1" != "help" ] || printf_exit 1 3 "Usage: create [username/repo [domain] [dir] [type] [branch]"
      status="$(curl -q -LSsf -X "POST" -H 'Accept: application/vnd.github+json' -H 'Authorization: Bearer '$GITADMIN_GITHUB_AUTH_TOKEN'' -H 'X-GitHub-Api-Version: 2022-11-28' "https://api.github.com/repos/$1/pages" --data "{ \"cname\":\"$2\",\"build_type\":\"${4:-legacy}\",\"source\":{\"branch\":\"${5:-main}\",\"path\":\"${3:-/}\" } }" 2>"$GITADMIN_TEMP_FILE" | __jq -rc '.cname')"
      [ -n "$status" ] && printf_cyan "Created: $status" || printf_exit 33 1 "The server returned an error: $(cat "$GITADMIN_TEMP_FILE" | grep 'error' | sed 's|.*error: ||g' | head -n1)"
      exit $?
      ;;

      # update a page
    update)
      shift 1
      [ $# -ne 0 ] && [ "$1" != "help" ] || printf_exit 1 3 "Usage: update [username/repo [domain] [dir] [type] [branch]"
      status="$(curl -q -LSsf -X "PUT" -H 'Accept: application/vnd.github+json' -H 'Authorization: token '$GITADMIN_GITHUB_AUTH_TOKEN'' -H 'X-GitHub-Api-Version: 2022-11-28' 'https://api.github.com/repos/'$1'/pages' --data "{ \"cname\":\"$2\",\"build_type\":\"${4:-legacy}\",\"custom_404\":\"/404.html\",\"source\":{\"branch\":\"${5:-main}\",\"path\":\"${3:-/}\" } }" 2>"$GITADMIN_TEMP_FILE" && echo "$1" || echo '')"
      [ -n "$status" ] && printf_cyan "Updated: $status" || printf_exit 33 1 "The server returned an error: $(cat "$GITADMIN_TEMP_FILE" | grep 'error' | sed 's|.*error: ||g' | head -n1)"
      exit $?
      ;;

      # delete a page
    delete)
      shift 1
      [ $# -ne 0 ] && [ "$1" != "help" ] || printf_exit 1 3 "Usage: delete [username/repo]"
      status="$(curl -q -LSsf -X "DELETE" -H 'Accept: application/vnd.github+json' -H 'Authorization: token '$GITADMIN_GITHUB_AUTH_TOKEN'' -H 'X-GitHub-Api-Version: 2022-11-28' 'https://api.github.com/repos/'$1'/pages' 2>"$GITADMIN_TEMP_FILE" && echo "$1" || echo '')"
      [ -n "$status" ] && printf_cyan "Deleted: $status" || printf_exit 33 1 "The server returned an error: $(cat "$GITADMIN_TEMP_FILE" | grep 'error' | sed 's|.*error: ||g' | head -n1)"
      exit $?
      ;;

      # get dns info
    health)
      shift 1
      [ $# -ne 0 ] && [ "$1" != "help" ] || printf_exit 1 3 "Usage: health [username/repo]"
      status="$(curl -q -LSsf --retry-all-errors --retry 3 --retry-delay 5 -X "GET" -H 'Accept: application/vnd.github+json' -H 'Authorization: token '$GITADMIN_GITHUB_AUTH_TOKEN'' -H 'X-GitHub-Api-Version: 2022-11-28' 'https://api.github.com/repos/'$1'/pages/health' 2>"$GITADMIN_TEMP_FILE" | __jq -r '.' || echo '')"
      [ -n "$status" ] && echo "$status" | __jq -r '.' || printf_exit 33 1 "The server returned an error: $(cat "$GITADMIN_TEMP_FILE" | grep 'error' | sed 's|.*error: ||g' | head -n1)"
      exit $?
      ;;

      # get info
    *)
      [ "$1" = "info" ] && shift 1
      [ $# -ne 0 ] && [ "$1" != "help" ] || printf_exit 1 3 "Usage: [build,create,update,delete,health] [username/repo]"
      status="$(curl -q -LSsf -X "GET" -H 'Accept: application/vnd.github+json' -H 'Authorization: token '$GITADMIN_GITHUB_AUTH_TOKEN'' -H 'X-GitHub-Api-Version: 2022-11-28' 'https://api.github.com/repos/'$1'/pages' 2>"$GITADMIN_TEMP_FILE" | __jq -r '{"status":.status,"url":.cname,"url":.html_url,"build":.build_type,"https":.https_enforced,"404":.custom_404}' || echo '')"
      [ -n "$status" ] && echo "$status" | __jq -r '.' || printf_exit 33 1 "The server returned an error: $(cat "$GITADMIN_TEMP_FILE" | grep 'error' | sed 's|.*error: ||g' | head -n1)"
      exit $?
      ;;
    esac
    ;;
  esac
  ;;

# gitlab repos commands
gitlab)
  shift 1
  [ "$1" = "help" ] && __help
  [ -z "$1" ] && __help
  case $1 in
  # init a gitlab repo
  init)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin gitlab init RepoName"
    __create_dirs
    do_not_add_a_url "$1"
    if echo "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$1" | grep -q '\.git$'; then
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$1" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$1")"
    fi
    __mkd "$homerepo" && [ ! -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to initialize $homerepo"
    __repos_init "$homerepo"
    exit "$?"
    ;;

    # Clone repo from gitlab
  clone)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin gitlab clone username/projectname"
    __create_dirs
    do_not_add_a_url "$1"
    remote_repo="https://gitlab.com/$(__strip_git_url "$1")"
    if echo "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$1" | grep -q '\.git$'; then
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$1" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_GITLAB/$1")"
    fi
    if [ -d "$homerepo/.git" ]; then
      printf_green "‚ÑπÔ∏è The repo already exists so attempting update"
      __git_pull "$homerepo"
      retVal=$?
    else
      printf_green "üîΩ Cloning the repo from $remote_repo"
      mkdir -p "$homerepo"
      __git_clone "$remote_repo" "$homerepo"
      retVal=$?
    fi
    __clone_success $retVal "$homerepo"
    [ -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to clone to: $homerepo"
    exit "$?"
    ;;

    # Push
  push)
    shift 1
    [ $# -eq 0 ] && [ -d "$PWD/.git" ] && homerepo="$PWD" || { [ -d "$1/.git" ] && homerepo="$1"; } || homerepo="$(ls -d "$GITADMIN_DEFAULT_GIT_DIR_GITLAB"/*/*)"
    for d in $homerepo; do
      __mkd "$d" && [ -d "$d/.git" ] && __cd_into "$d" || printf_exit 1 1 "failed to push from: $d"
      __git_push_single "$d"
    done
    ;;

    # update repo
  pull)
    shift 1
    [ "$1" = "help" ] && __printf_help "Usage: $APPNAME update | pull the repos"
    [ $# -eq 0 ] && [ -d "$PWD/.git" ] && homerepo="$PWD" || { [ -d "$1/.git" ] && homerepo="$1"; } || homerepo="$(ls -d "$GITADMIN_DEFAULT_GIT_DIR_GITLAB"/*/*)"
    for d in $homerepo; do
      __mkd "$d" && [ -d "$d/.git" ] && __cd_into "$d" || printf_exit 1 1 "failed to pull to: $d"
      __git_pull_single "$d"
    done
    ;;

    # add gitlab to remote
  remote)
    shift 1
    { [ $# -ne 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin gitlab remote [username/projectname] [name]"
    do_not_add_a_url "$1"
    remote_repo="https://gitlab.com/$(__strip_git_url "$1")"
    git -C "$GITADMIN_CWD" remote add "${2:-orgin}" "https://github.com/$1.git"
    exit "$?"
    ;;

  repos)
    shift 1
    __gitlab_orgs "$@"
    exit $?
    ;;

  branch)
    shift 1
    { [ $# -ne 2 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin gitlab branch projectID branch"
    __gitlab_branch "$@"
    exit $?
    ;;
  esac
  ;;

  # private repos commands
private)
  shift 1
  if [ $# = 0 ] || [ "$1" = "help" ] || [ -z "$GITADMIN_PERSONAL_GIT_HOST" ]; then
    [ -n "$GITADMIN_PERSONAL_GIT_HOST" ] || printf_red "You dont have the env variable GITADMIN_PERSONAL_GIT_HOST set in settings.conf"
    printf_green "Useful if you have a private server such as gitea"
    exit 0
  fi
  case $1 in
  # init a private repo
  init)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin private init RepoName"
    __create_dirs
    do_not_add_a_url "$1"
    if echo "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$1" | grep -q '\.git$'; then
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$1" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$1")"
    fi
    __mkd "$homerepo" && [ ! -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to initialize $homerepo"
    __repos_init "$homerepo"
    exit "$?"
    ;;

    # Clone repo from private
  clone)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin private clone username/projectname"
    __create_dirs
    do_not_add_a_url "$1"
    remote_repo="$GITADMIN_PERSONAL_GIT_HOST/$(__strip_git_url "$1")"
    if echo "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$1" | grep -q '\.git$'; then
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$1" | grep '\.git$' | __sed 's/\",//;s/\.[^.]*$//;s#"##g')"
    else
      homerepo="$(echo "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$1")"
    fi
    if [ -d "$homerepo" ]; then
      printf_green "‚ÑπÔ∏è The repo already exists so attempting update"
      __git_pull "$homerepo"
      retVal=$?
    else
      printf_green "üîΩ Cloning the repo from $remote_repo"
      mkdir -p "$homerepo"
      __git_clone "$remote_repo" "$homerepo"
      retVal=$?
    fi
    __clone_success $retVal "$homerepo"
    [ -d "$homerepo/.git" ] && __cd_into "$homerepo" || printf_exit 1 1 "failed to initialize $homerepo"
    exit "$?"
    ;;

    # Push
  push)
    shift 1
    [ $# -eq 0 ] && [ -d "$PWD/.git" ] && homerepo="$PWD" || { [ -d "$1/.git" ] && homerepo="$1"; } || homerepo="$(ls -d "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE"/*/*)"
    for d in $homerepo; do
      __mkd "$d" && [ -d "$d/.git" ] && __cd_into "$d" || printf_exit 1 1 "failed to push from: $d"
      __git_push_single "$d"
    done
    ;;

    # update repo
  pull)
    shift 1
    [ "$1" = "help" ] && __printf_help "Usage: $APPNAME update | pull the repos"
    [ $# -eq 0 ] && [ -d "$PWD/.git" ] && homerepo="$PWD" || { [ -d "$1/.git" ] && homerepo="$1"; } || homerepo="$(ls -d "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE"/*/*)"
    for d in $homerepo; do
      __mkd "$d" && [ -d "$d/.git" ] && __cd_into "$d" || printf_exit 1 1 "failed to pull to: $d"
      __git_pull_single "$d"
    done
    ;;

    # add private to remote
  remote)
    shift 1
    { [ $# -ne 2 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin private remote username/projectname [name]"
    do_not_add_a_url "$1"
    git -C "$GITADMIN_DEFAULT_GIT_DIR_PRIVATE/$2" remote add "${2:-orgin}" "https://github.com/$(__strip_git_url "$1").git"
    exit "$?"
    ;;

    # update repo
  update)
    shift 1
    __gitea_update_all "$@"
    exit "$?"
    ;;

  create)
    shift 1
    case "$1" in
    # create a private repo
    repo)
      shift 1
      { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin private create RepoName 'description'"
      __gitea_create_repo "$@"
      exit "$?"
      ;;

      # create a private org
    org)
      shift 1
      { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin private create orgname 'reponame' 'description'"
      __gitea_create_org "$@"
      exit "$?"
      ;;
    esac
    ;;

    # create a branch
  branch)
    shift 1
    [ "$1" = "help" ] && __printf_help "Usage: gitadmin private branch RepoName branch"
    __gitea_branch "$@"
    exit "$?"
    ;;

    # list private repos
  repos)
    shift 1
    if [ "$1" = "delete" ]; then
      shift 1
      { [ $# = 0 ] || [ "$1" = "help" ] && __printf_help "Usage: gitadmin private repos delete RepoName"; }
      __gitea_delete_repo "$@"
    else
      { [ $# = 0 ] || [ "$1" = "help" ] && __printf_help "Usage: gitadmin private repos"; }
      __gitea_users "$@"
    fi
    exit "$?"
    ;;

  migrate)
    shift 1
    printf_purple " üëÅÔ∏è‚Äçüó®Ô∏è  Initializing the migration utility  üëÅÔ∏è‚Äçüó®Ô∏è "
    if [ "$GITADMIN_MIGRATE_DELETE" = "true" ]; then
      __gitea_migrate_delete "$@"
    else
      __github_to_gitea "$@"
    fi
    exit $?
    ;;

  gist)
    shift 1
    [ -n "$GITADMIN_PRIVATE_GIST_SERVER" ] || printf_exit "Please set the variable $GITADMIN_PRIVATE_GIST_SERVER"
    case "$1" in
    init)
      shift 1
      exitCode=0
      if [ -d "$GITADMIN_CWD/.git" ]; then
        (git -C "$GITADMIN_CWD" remote add origin $GITADMIN_PRIVATE_GIST_SERVER/init && git -C "$GITADMIN_CWD" push -u origin __main >/dev/null) 2>&1
        exitCode=$?
      else
        (git -C "$GITADMIN_CWD" init && git -C "$GITADMIN_CWD" add . && git -C "$GITADMIN_CWD" commit -m "ü¶àüè†üêú‚ùó Initial Commit ‚ùóüêúü¶àüè†" && git -C "$GITADMIN_CWD" remote add origin $GITADMIN_PRIVATE_GIST_SERVER/init) >/dev/null 2>&1
        results="$(git -C "$GITADMIN_CWD" push -u origin __main 2>&1 | grep 'remote: Your new gist has been created here' | sed 's|.*been created here: ||g;s| ||g' | grep '://')"
        if [ -n "$results" ]; then
          if git remote set-url origin "$results" >/dev/null 2>&1; then
            printf_cyan "$GITADMIN_CWD has been initialized: $results"
          else
            exitCode=1
          fi
        else
          exitCode=1
        fi
      fi
      [ $exitCode -eq 0 ] || printf_exit "Failed to init $GITADMIN_CWD"
      ;;
    add)
      shift 1
      [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD is not a git repo"
      git -C "$GITADMIN_CWD" add . >/dev/null 2>&1 && printf_green "" || printf_return ""
      exit $?
      ;;
    commit)
      shift 1
      message="ü¶àüè†üêú‚ùó Updated Gist ‚ùóüêúü¶àüè†"
      [ -d "$GITADMIN_CWD/.git" ] || printf_exit "$GITADMIN_CWD is not a git repo"
      git -C "$GITADMIN_CWD" add . && git -C "$GITADMIN_CWD" commit -m "$message" 2>&1 && printf_green "Commited $GITADMIN_CWD: $message" || printf_return "Failed to commit $GITADMIN_CWD"
      exit $?
      ;;
    push)
      shift 1
      [ -d "$GITADMIN_CWD/.git" ] && git -C "$GITADMIN_CWD" push -q || printf_exit "$GITADMIN_CWD is not a git repo"
      [ $? -eq 0 ] || printf_exit "Failed to push"
      ;;
    pull)
      if [ -d "$GITADMIN_PRIVATE_GIST_DIR/$1/.git" ]; then
        git -C "$GITADMIN_PRIVATE_GIST_DIR/$1" pull -q && printf_green "Updated $GITADMIN_PRIVATE_GIST_DIR/$1" || printf_exit "Failed to update $GITADMIN_PRIVATE_GIST_DIR/$1"
      fi
      ;;
    clone)
      shift 1
      mkdir -p "$GITADMIN_PRIVATE_GIST_DIR/$1"
      if [ -d "$GITADMIN_PRIVATE_GIST_DIR/$1/.git" ]; then
        git -C "$GITADMIN_PRIVATE_GIST_DIR/$1" pull -q
      else
        git -q -C "$GITADMIN_CWD" clone -q "$GITADMIN_PRIVATE_GIST_SERVER/$1" "$GITADMIN_PRIVATE_GIST_DIR/$1"
      fi
      [ -d "$GITADMIN_PRIVATE_GIST_DIR/$1/.git" ] && printf_green "Cloned $GITADMIN_PRIVATE_GIST_SERVER/$1 to $GITADMIN_PRIVATE_GIST_DIR/$1" || printf_exit "Failed to clone"
      ;;
    esac
    ;;
  esac
  ;;

# Issue options
issues)
  shift 1
  case "$1" in
  count)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ] && __printf_help "Usage: gitadmin issues count username/projectname"; }
    __api_issues_token "$@"
    get_count="$(__api_issues "GET" | __jq 'map(select(.pull_request == null)) | length' 2>/dev/null || false)"
    [ -n "$get_count" ] || printf_exit 1 1 "failed to get count"
    printf_blue "You currently have $get_count issues"
    printf_cyan "$ISSUE_HTML"
    exit $?
    ;;

  list)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ] && __printf_help "Usage: gitadmin issues count username/projectname"; }
    if [ "$1" = "json" ]; then
      shift 1
      __api_issues_token "$@"
      __api_issues "GET" | __jq
    else
      printf_green "Showing 10 of the most recent issues"
      __api_issues_token "$@"

      __api_issues "GET" | __jq -rc '.[]|[.title,.html_url]' 2>/dev/null | sed 's|","|: |g;s|"||g;s|\]||g;s|\[||g' | head -n 10 | printf_readline "5"
    fi
    ;;

  create)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ] && __printf_help "Usage: gitadmin issues count username/projectname"; }
    user="${1:-$GITADMIN_DEFAULT_USERNAME}" && shift 1
    issue_repo="$1" && shift 1
    issue_title="$1" && shift 1
    [ -f "$1" ] && issue_body="$(cat "$1" | sed 's|^| |g')" || issue_body="$1"
    shift
    content="$(printf "%s\r" "{ \"title\": \"$issue_title\", \"body\": \"$issue_body\" }" | tee "$GITADMIN_TEMP_FILE")"
    __api_issues_token ${user} ${issue_repo:-}
    printf_green "Attempting to create a new issue "
    __curl_gh_api -X "POST" "$ISSUE_API" -d @$GITADMIN_TEMP_FILE 2>/dev/null | __jq -r ".html_url" 2>/dev/null | grep -v 'null' | printf_readline | grep '^' || printf_exit 1 "Failed to create the issue on\n$ISSUE_API"
    ;;

  edit)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ] && __printf_help "Usage: gitadmin issues count username/projectname"; }
    issue_number="$1" && shift 1
    user="${1:-$GITADMIN_DEFAULT_USERNAME}" && shift 1
    issue_repo="$1" && shift 1
    issue_title="$1" && shift 1
    [ -f "$1" ] && issue_body="$(cat "$1" | sed 's|^| |g')" || issue_body="$1"
    shift
    content="$(printf "%s\r" "{ \"title\": \"$issue_title\", \"body\": \"$issue_body\" }" | tee "$GITADMIN_TEMP_FILE")"
    __api_issues_token "$user" "$issue_repo"
    printf_green "Attempting to edit issue $issue_number"
    __curl_gh_api -X "PATCH" "$ISSUE_API/$issue_number" -d @$GITADMIN_TEMP_FILE 2>/dev/null | __jq -r ".html_url" 2>/dev/null | grep -v 'null' | printf_readline | grep '^' || printf_exit 1 "Failed to edit the issue at\n$ISSUE_API/$issue_number"
    ;;

  delete)
    shift 1
    { [ $# = 0 ] || [ "$1" = "help" ] && __printf_help "Usage: gitadmin issues count username/projectname"; }
    printf_exit "Not implemented yet"
    issue_number="$1" && shift 1
    __api_issues_token "$@"
    ;;

  *)
    { [ $# = 0 ] || [ "$1" = "help" ] && __printf_help "Usage: gitadmin issues [list,count,create] username/projectname"; }
    $APPNAME issues list "$@"
    exit $?
    ;;
  esac
  ;;

cron | updater)
  shift 1
  { [ $# = 0 ] || [ "$1" = "help" ]; } && __printf_help "Usage: gitadmin cron [run,remove,add]"
  case "$1" in
  run)
    shift 1
    __run_cron "run"
    ;;
  remove)
    shift 1
    __run_cron "remove"
    ;;
  add)
    shift 1
    __run_cron "add"
    ;;
  esac
  ;;

*)
  if [ $# -eq 0 ] || [ "$1" = "help" ]; then
    __help
    exit 0
  else
    git_cmd="$(builtin type -P git 2>/dev/null)"
    if $git_cmd $1 --help 2>&1 | grep -vq 'is not a git command'; then
      $git_cmd -C "$GITADMIN_CWD" "$@"
      exitCode=$?
    else
      printf_red "git $1 is not valid command"
      exitCode=127
    fi
  fi
  ;;
esac
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set exit code
exitCode="${exitCode:-0}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# End application
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# lets exit with code
exit ${exitCode:-0}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# ex: ts=2 sw=2 et filetype=sh
