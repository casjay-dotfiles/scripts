#!/usr/bin/env bash
# shellcheck shell=bash
# - - - - - - - - - - - - - - - - - - - - - - - - -
##@Version           :  202602101843-git
# @@Author           :  Jason Hempstead
# @@Contact          :  jason@casjaysdev.pro
# @@License          :  WTFPL
# @@ReadME           :  gitcommit --help
# @@Copyright        :  Copyright: (c) 2022 Jason Hempstead, Casjays Developments
# @@Created          :  Monday, Aug 08, 2022 23:40 EDT
# @@File             :  gitcommit
# @@Description      :  Commit changes to a git repo - self-contained, no external dependencies
# @@Changelog        :  Synchronized __help with actual commands (added pull, merge, merge-resolve, etc.)
# @@TODO             :  Fix/re-write variables
# @@Other            :
# @@Resource         :
# @@Terminal App     :  no
# @@sudo/root        :  no
# @@Template         :  bash/system
# - - - - - - - - - - - - - - - - - - - - - - - - -
# shellcheck disable=SC1001,SC1003,SC2001,SC2003,SC2016,SC2031,SC2090,SC2115,SC2120,SC2155,SC2199,SC2229,SC2317,SC2329
# - - - - - - - - - - - - - - - - - - - - - - - - -
APPNAME="$(basename -- "$0" 2>/dev/null)"
VERSION="202602101843-git"
USER="${SUDO_USER:-$USER}"
RUN_USER="${RUN_USER:-$USER}"
USER_HOME="${USER_HOME:-$HOME}"
SCRIPT_SRC_DIR="${BASH_SOURCE%/*}"
GITCOMMIT_REQUIRE_SUDO="${GITCOMMIT_REQUIRE_SUDO:-no}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Reopen in a terminal
#if [ ! -t 0 ] && { [ "$1" = --term ] || [ $# = 0 ]; }; then { [ "$1" = --term ] && shift 1 || true; } && TERMINAL_APP="TRUE" myterminal -e "$APPNAME $*" && exit || exit 1; fi
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set script title
#CASJAYS_DEV_TILE_FORMAT="${USER}@${HOSTNAME}:${PWD/#$HOME/~} - $APPNAME"
#CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}"
#[ -z "$CASJAYSDEV_TITLE_SET" ] && printf '\033]0;%s\007' "$CASJAYS_DEV_TILE_FORMAT" && CASJAYSDEV_TITLE_SET="$APPNAME"
export CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}" CASJAYSDEV_TITLE_SET
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Initial debugging
[ "$1" = "--debug" ] && set -x && export SCRIPT_OPTS="--debug" && export _DEBUG="on"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Disables colorization
[ "$1" = "--raw" ] && export SHOW_RAW="true"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# pipes fail
set -o pipefail
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Send all output to /dev/null
__devnull() {
  tee &>/dev/null && exitCode=0 || exitCode=1
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -'
# Send errors to /dev/null
__devnull2() {
  [ -n "$1" ] && local cmd="$1" && shift 1 || return 1
  eval $cmd "$*" 2>/dev/null && exitCode=0 || exitCode=1
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -'
# See if the executable exists
__cmd_exists() {
  local exitCode=0
  [ -n "$1" ] || return 0
  for cmd in "$@"; do
    if builtin command -v "$cmd" &>/dev/null; then
      exitCode=$((exitCode + 0))
    else
      exitCode=$((exitCode + 1))
    fi
  done
  [ $exitCode -eq 0 ] || exitCode=3
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Grep wrapper - suppresses errors, returns 0 on match, 1 on failure
__grep() {
  grep "$@" 2>/dev/null || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for a valid internet connection
__am_i_online() {
  local exitCode=0
  if ! curl -q -LSsfI --max-time 2 --retry 1 "${1:-https://1.1.1.1}" 2>&1 | __grep -qi 'server:.*cloudflare'; then
    exitCode=4
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# colorization
if [ "$SHOW_RAW" = "true" ]; then
  NC=""
  RESET=""
  BLACK=""
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  PURPLE=""
  CYAN=""
  WHITE=""
  ORANGE=""
  LIGHTRED=""
  BG_GREEN=""
  BG_RED=""
  ICON_INFO="[ info ]"
  ICON_GOOD="[ ok ]"
  ICON_WARN="[ warn ]"
  ICON_ERROR="[ error ]"
  ICON_QUESTION="[ ? ]"
  printf_column() { tee | __grep '^'; }
  printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
else
  printf_color() { printf "%b" "$(tput setaf "${2:-7}" 2>/dev/null)" "$1" "$(tput sgr0 2>/dev/null)"; }
fi
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional printf_ colors
__printf_head() { printf_blue "$1"; }
__printf_opts() { printf_purple "$1"; }
__printf_line() { printf_cyan "$1"; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
# output version
__version() { printf_cyan "$VERSION"; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Inlined external functions - BEGIN
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Printf functions from colors.bash
printf_newline() {
  [[ -n "$1" ]] && printf '%b\n' "${*:-}" || printf '\n'
}
printf_green() {
  printf_color "$1" 2
  printf "\n"
}
printf_red() {
  printf_color "$1" 208
  printf "\n"
}
printf_purple() {
  printf_color "$1" 5
  printf "\n"
}
printf_yellow() {
  printf_color "$1" 3
  printf "\n"
}
printf_blue() {
  printf_color "$1" 33
  printf "\n"
}
printf_cyan() {
  printf_color "$1" 6
  printf "\n"
}
printf_return() {
  test -n "$1" && test -z "${1//[0-9]/}" && local color="$1" && shift 1 || local color="208"
  test -n "$1" && test -z "${1//[0-9]/}" && local exitCode="$1" && shift 1 || local exitCode="1"
  local msg="$*"
  [ ${#msg} = 0 ] || { printf_color "$msg" "$color" 1>&2 && printf "\n"; }
  return ${exitCode:-2}
}
printf_error() {
  test -n "$1" && test -z "${1//[0-9]/}" && local color="$1" && shift 1 || local color="208"
  test -n "$1" && test -z "${1//[0-9]/}" && local exitCode="$1" && shift 1 || local exitCode="1"
  local msg="$*"
  printf_color "$ICON_ERROR $msg" "$color" 1>&2
  printf "\n"
  return $exitCode
}
printf_exit() {
  test -n "$1" && test -z "${1//[0-9]/}" && local color="$1" && shift 1 || local color="208"
  test -n "$1" && test -z "${1//[0-9]/}" && local exitCode="$1" && shift 1 || local exitCode="1"
  local msg="$*"
  shift
  printf_color "$msg" "$color" 1>&2
  printf "\n"
  exit "$exitCode"
}
printf_read_question() {
  test -n "$1" && test -z "${1//[0-9]/}" && local color="$1" && shift 1 || local color="208"
  local msg="$1" && shift 1
  test -n "$1" && test -z "${1//[0-9]/}" && local lines="$1" && shift 1 || local lines="120"
  local reply="${1:-REPLY}" && shift 1
  local readopts="${1:-}" && shift 1
  printf_color "$msg " "${PRINTF_COLOR:-$color}"
  read -t 30 -e -r -n $lines ${readopts:-} ${reply:-} || return 1
  [ -z "$reply" ] && printf '\n' && return 1 || return 0
}
printf_answer_yes() {
  local answerVar="${1:-$REPLY}"
  if [[ "$answerVar" =~ ${2:-^[Yy]$} ]]; then
    exitCode=0
  elif [ -z "$answerVar" ] || [ "$answerVar" = "" ]; then
    printf '\n'
    exitCode=1
  else
    exitCode=1
  fi
  return ${exitCode:-0}
}
printf_custom() {
  test -n "$1" && test -z "${1//[0-9]/}" && local color="$1" && shift 1 || local color="5"
  local msg="$*"
  shift
  printf_color "$msg" "${PRINTF_COLOR:-$color}"
  printf "\n"
}
printf_readline() {
  set -o pipefail
  test -n "$1" && test -z "${1//[0-9]/}" && local color="$1" && shift 1 || local color="6"
  while read line; do
    printf_color "$line" "${PRINTF_COLOR:-$color}"
    printf "\n"
  done
  set +o pipefail
}
printf_column() {
  local -a column=""
  set -o pipefail
  test -n "$1" && test -z "${1//[0-9]/}" && local color="$1" && shift 1 || local color="7"
  cat - |& column | printf_readline "${color:-$COLOR}"
  printf "\n"
  set +o pipefail
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Exit status functions from exit_status.bash
__setexitstatus() {
  local EXITCODE=$?
  test -n "$1" && test -z "${1//[0-9]/}" && local EXITCODE="$1" && shift 1
  [ -z "$1" ] || EXIT="$1"
  if [ "$EXITCODE" = 0 ]; then
    NEW_BG_EXIT="${BG_GREEN}"
  else
    NEW_BG_EXIT="${BG_RED}"
  fi
  export NEW_BG_EXIT
  return ${exitCode:-0}
}
__returnexitcode() {
  local EXITCODE=$?
  test -n "$1" && test -z "${1//[0-9]/}" && local EXITCODE="$1" && shift 1
  if [ $EXITCODE -eq 0 ]; then
    NEW_BG_EXIT="${BG_GREEN}"
    NEW_PS_SYMBOL=" üò∫ [ $EXITCODE] "
    EXIT=0
  elif [ $EXITCODE -gt 1 ]; then
    NEW_BG_EXIT="${BG_RED}"
    NEW_PS_SYMBOL=" ‚ÅâÔ∏è [ $EXITCODE] "
  else
    NEW_BG_EXIT="${BG_RED}"
    NEW_PS_SYMBOL=" üòü [ $EXITCODE] "
  fi
  export NEW_BG_EXIT NEW_PS_SYMBOL
  return ${exitCode:-0}
}
__getexitcode() {
  local EXITCODE=$?
  test -n "$1" && test -z "${1//[0-9]/}" && EXITCODE="$1" && shift 1 || EXITCODE="${EXITCODE:-0}"
  if [ -n "$1" ]; then
    local PSUCCES="$1"
  elif [ -n "$SUCCES" ]; then
    local PSUCCES="$SUCCES"
  elif [ -n "$GETEXITCODE_SUCCES" ]; then
    local PSUCCES="$GETEXITCODE_SUCCES"
  else
    local PSUCCES="Command successful"
  fi
  if [ -n "$2" ]; then
    local PERROR="$2"
  elif [ -n "$ERROR" ]; then
    local PERROR="$ERROR"
  elif [ -n "$GETEXITCODE_ERROR" ]; then
    local PSUCCES="$GETEXITCODE_ERROR"
  else
    local PERROR="Last command failed to complete"
  fi
  if [ "$EXITCODE" = 0 ]; then
    printf_cyan "$PSUCCES"
  else
    printf_error "$PERROR"
  fi
  __returnexitcode "$EXITCODE"
  return "$EXITCODE"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Inlined external functions - END
# - - - - - - - - - - - - - - - - - - - - - - - - -
# list options
__list_options() {
  printf_color "$1: " "$5"
  echo -ne "$2" | sed 's|:||g;s/'$3'/ '$4'/g' | tr '\n' ' '
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# create the config file
__gen_config() {
  local NOTIFY_CLIENT_NAME="$APPNAME"
  if [ "$INIT_CONFIG" != "TRUE" ]; then
    printf_blue "Generating the config file in"
    printf_cyan "$GITCOMMIT_CONFIG_DIR/$GITCOMMIT_CONFIG_FILE"
  fi
  [ -d "$GITCOMMIT_CONFIG_DIR" ] || mkdir -p "$GITCOMMIT_CONFIG_DIR"
  [ -d "$GITCOMMIT_CONFIG_BACKUP_DIR" ] || mkdir -p "$GITCOMMIT_CONFIG_BACKUP_DIR"
  [ -f "$GITCOMMIT_CONFIG_DIR/$GITCOMMIT_CONFIG_FILE" ] &&
    cp -Rf "$GITCOMMIT_CONFIG_DIR/$GITCOMMIT_CONFIG_FILE" "$GITCOMMIT_CONFIG_BACKUP_DIR/$GITCOMMIT_CONFIG_FILE.$$"
  cat <<EOF >"$GITCOMMIT_CONFIG_DIR/$GITCOMMIT_CONFIG_FILE"
# Settings for gitcommit
GITCOMMIT_NO_CONFIRM="${GITCOMMIT_NO_CONFIRM:-true}"
GITCOMMIT_PROJECT_DIR="${GIT_PROJECT_DIR:-$HOME/Projects}"
GITCOMMIT_CHANGELOG_FILE_NAME="${GITCOMMIT_CHANGELOG_FILE_NAME:-CHANGELOG.md}"
GITCOMMIT_VERSION_FILE="${GIT_VERSION_FILE:-version.txt}"
GITCOMMIT_MAIN_CONFIG=${GITCOMMIT_MAIN_CONFIG:-gitmainconfig}
GITCOMMIT_VERSION_FORMAT="${VERSION_DATE_FORMAT:-%Y%m%d%H%M-git}"
GITCOMMIT_RELEASE_FORMAT="${GITCOMMIT_RELEASE_FORMAT:-%Y.%m.%d}"
GITCOMMIT_RANDOM_API_URL="${GITCOMMIT_RANDOM_API_URL:-https://api.casjay.vercel.app/api/v1/commit/txt/}"
GITCOMMIT_CHANGELOG_ICON="${GITCOMMIT_CHANGELOG_ICON:-}"
GITCOMMIT_DEFAULT_COMMIT_FILE="${GITCOMMIT_DEFAULT_COMMIT_FILE:-}"
GITCOMMIT_DEFAULT_AI_COMMAND="${GITCOMMIT_DEFAULT_AI_COMMAND:-}"
GITCOMMIT_DEFAULT_AI_ARGS="${GITCOMMIT_DEFAULT_AI_ARGS:-}"
GITCOMMIT_LOG_SHOW_EXCLUDE="${GITCOMMIT_LOG_SHOW_EXCLUDE:-Version Bump:}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
GITCOMMIT_OUTPUT_COLOR_1="${GITCOMMIT_OUTPUT_COLOR_1:-}"
GITCOMMIT_OUTPUT_COLOR_2="${GITCOMMIT_OUTPUT_COLOR_2:-}"
GITCOMMIT_OUTPUT_COLOR_GOOD="${GITCOMMIT_OUTPUT_COLOR_GOOD:-}"
GITCOMMIT_OUTPUT_COLOR_ERROR="${GITCOMMIT_OUTPUT_COLOR_ERROR:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
GITCOMMIT_NOTIFY_ENABLED="${GITCOMMIT_NOTIFY_ENABLED:-}"
GITCOMMIT_GOOD_NAME="${GITCOMMIT_GOOD_NAME:-}"
GITCOMMIT_ERROR_NAME="${GITCOMMIT_ERROR_NAME:-}"
GITCOMMIT_GOOD_MESSAGE="${GITCOMMIT_GOOD_MESSAGE:-}"
GITCOMMIT_ERROR_MESSAGE="${GITCOMMIT_ERROR_MESSAGE:-}"
GITCOMMIT_NOTIFY_CLIENT_NAME="${GITCOMMIT_NOTIFY_CLIENT_NAME:-}"
GITCOMMIT_NOTIFY_CLIENT_ICON="${GITCOMMIT_NOTIFY_CLIENT_ICON:-}"
GITCOMMIT_NOTIFY_CLIENT_URGENCY="${GITCOMMIT_NOTIFY_CLIENT_URGENCY:-}"

EOF
  if builtin type -t __gen_config_local | __grep -q 'function'; then __gen_config_local; fi
  if [ -f "$GITCOMMIT_CONFIG_DIR/$GITCOMMIT_CONFIG_FILE" ]; then
    [ "$INIT_CONFIG" = "TRUE" ] || printf_green "Your config file for $APPNAME has been created"
    . "$GITCOMMIT_CONFIG_DIR/$GITCOMMIT_CONFIG_FILE"
    exitCode=0
  else
    printf_red "Failed to create the config file"
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Help function - Align to 50
__help() {
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "gitcommit:  Commit changes to a git repo (self-contained) - $VERSION"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "Usage: gitcommit [options] [directory] [commands] [message]"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Repository Commands"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "status, s                       - Show git status"
  __printf_line "log [limit]                     - Show the log (optionally limit results)"
  __printf_line "log show [commit]               - Show full commit details"
  __printf_line "log search [query]              - Search through the log"
  __printf_line "search [query]                  - Search through the commit history"
  __printf_line "is clean|dirty                  - Check if repo is clean or dirty"
  __printf_line "init                            - Initialize a repo"
  __printf_line "setup [all|org]                 - Setup repository configuration"
  __printf_line "reset                           - Reset a git repo"
  __printf_line "branch                          - Create a new branch"
  __printf_line "pull                            - Pull changes from remote repo"
  __printf_line "push                            - Push changes to remote repo"
  __printf_line "merge <branch> [strategy]       - Smart merge (auto|ff|no-ff|squash)"
  __printf_line "merge-resolve [action]          - Resolve merge conflicts (status|show|edit|ours|theirs|abort)"
  __printf_line "tag [add|remove|version]        - Manage tags"
  __printf_line "tar                             - Create a tar release"
  __printf_line "version                         - Bump the version"
  __printf_line "fixup                           - Fix last commit (auto-skips version bumps)"
  __printf_line "squash [num] [msg]              - Squash last N commits (default: 2)"
  __printf_line "amend                           - Amend a previous commit"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Commit Commands"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "all                             - Commit all files"
  __printf_line "files                           - Commit files based on status"
  __printf_line "modified                        - Commit only modified files"
  __printf_line "updated                         - Commit only updated files"
  __printf_line "deleted                         - Commit only deleted files"
  __printf_line "added                           - Commit only added files"
  __printf_line "renamed                         - Commit only renamed files"
  __printf_line "changed                         - Commit only changed files"
  __printf_line "restored                        - Commit restored files"
  __printf_line "spelling                        - Commit spelling fixes"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Semantic Commit Types"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "new                             - New files/features"
  __printf_line "improved                        - Improved files"
  __printf_line "fixes                           - File fixes"
  __printf_line "release                         - New release"
  __printf_line "deploy                          - Deploy changes"
  __printf_line "docs                            - Documentation changes"
  __printf_line "test                            - Test changes"
  __printf_line "breaking                        - Breaking changes"
  __printf_line "refactor                        - Refactoring code"
  __printf_line "performance                     - Performance improvement"
  __printf_line "permissions                     - Permission fixes"
  __printf_line "bugs                            - Bug fixes"
  __printf_line "alot                            - Lazy message (updated a lot of files)"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Project Type Commits"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "docker                          - Docker project"
  __printf_line "node                            - NodeJS project"
  __printf_line "ruby                            - Ruby project"
  __printf_line "php                             - PHP project"
  __printf_line "perl                            - Perl project"
  __printf_line "python                          - Python project"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Repository Type Commits"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "scratchpad                      - Scratchpad repo"
  __printf_line "todo                            - TODO repo"
  __printf_line "notes                           - Notes repo"
  __printf_line "blog                            - Blog repo"
  __printf_line "recipe                          - Recipe repo"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Special Commit Commands"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "ai                              - Generate commit message using AI"
  __printf_line "random                          - Generate a random commit message"
  __printf_line "emojify                         - Emojify a commit"
  __printf_line "custom                          - Specify custom message"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Options"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "--message, -m                   - Specify custom message"
  __printf_line "--amend                         - Amend a commit"
  __printf_line "--force                         - Force changes and push"
  __printf_line "--dir                           - Sets the working directory"
  __printf_line "--help                          - Shows this message"
  __printf_line "--config                        - Generate user config file"
  __printf_line "--version                       - Show script version"
  __printf_line "--options                       - Shows all available options"
  __printf_line "--debug                         - Enables script debugging"
  __printf_line "--raw                           - Removes all formatting on output"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# check if arg is a builtin option
__is_an_option() { if echo "$ARRAY" | __grep -q "${1:-^}"; then return 1; else return 0; fi; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__trap_exit() {
  exitCode=${exitCode:-0}
  [ -f "$GITCOMMIT_TEMP_FILE" ] && rm -Rf "$GITCOMMIT_TEMP_FILE" &>/dev/null
  #unset CASJAYSDEV_TITLE_SET && printf '\033]2‚îÇ;%s\033\\' "${USER}@${HOSTNAME}:${PWD/#$HOME/~} - ${CASJAYSDEV_TITLE_PREV:-$SHELL}"
  if builtin type -t __trap_exit_local | __grep -q 'function'; then __trap_exit_local; fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined functions
__trap_exit_local() {
  local statusCode="${GITCOMMIT_EXITCODE:-1}"
  local commit_file="$GITCOMMIT_ROOT_DIR/.git/COMMIT_EDITMSG"
  if [ "$statusCode" -eq 0 ]; then
    if [ -n "$commit_file" ] && [ -f "$commit_file" ]; then
      rm -Rf "$commit_file"
    fi
    # Clean up both COMMIT_MSG and COMMIT_MESS files on success
    if [ -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MSG" ]; then
      rm -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MSG"
    fi
    if [ -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MESS" ]; then
      rm -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MESS"
    fi
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__parse_commit_mess_file() {
  local commit_mess_file="${1:-$GITCOMMIT_MESSAGE_FILE}"
  if [ -f "$commit_mess_file" ] && [ -s "$commit_mess_file" ]; then
    local first_line=""
    local remaining_lines=""
    first_line="$(head -n 1 "$commit_mess_file" | __grep -v '^$' | __grep '^' || true)"
    remaining_lines="$(tail -n +2 "$commit_mess_file" | __grep -v '^$' | __grep '^' || true)"
    if [ -n "$first_line" ]; then
      GITCOMMIT_MESSAGE_SHORT="$first_line"
      GITCOMMIT_MESSAGE_LONG="$remaining_lines"
      GITCOMMIT_MESSAGE_FROM_FILE="true"
      export GITCOMMIT_MESSAGE_SHORT GITCOMMIT_MESSAGE_LONG GITCOMMIT_MESSAGE_FROM_FILE
      return 0
    fi
  fi
  return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_s_added() { git -C "$GEN_CHANGELOG_CWD" status -s 2>/dev/null | __grep -Ew ^'\?\?|^A|^AA|^ A' | awk '{print $2}' | sort -u | __grep -v '^$' | __grep '^' || return 1; }
__git_s_renamed() { git -C "$GEN_CHANGELOG_CWD" status -s 2>/dev/null | __grep -Ew ^'R|^RM|^ R' | awk '{print $2}' | sort -u | __grep -v '^$' | __grep '^' || return 1; }
__git_s_modified() { git -C "$GEN_CHANGELOG_CWD" status -s 2>/dev/null | __grep -Ew ^'M|^MM|^ M' | awk '{print $2}' | sort -u | __grep -v '^$' | __grep '^' || return 1; }
__git_s_updated() { git -C "$GEN_CHANGELOG_CWD" status -s 2>/dev/null | __grep -Ew ^'U|^UU|^ U' | awk '{print $2}' | sort -u | __grep -v '^$' | __grep '^' || return 1; }
__git_s_deleted() { git -C "$GEN_CHANGELOG_CWD" status -s 2>/dev/null | __grep -E ^'[M, ]D|DD' | awk '{print $2}' | sort -u | __grep -v '^$' | __grep '^' || return 1; }
__git_s_message() { __git_s_added || __git_s_renamed || __git_s_modified || __git_s_deleted || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__changelog_commit() { gen-changelog --amend --dir "$GITCOMMIT_ROOT_DIR" || return; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__sanitize_url() { sed 's|://*.*:|://|g'; }
__emj_check() { sed 's/\xf0\x9f/\r&/g; s/\s*\r.//g'; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__run_push() {
  [ -f "$GITCOMMIT_ROOT_DIR/.no_push" ] && printf_yellow "„äóÔ∏è Push is disabled for $GITCOMMIT_ROOT_DIR „äóÔ∏è " && exit 0
  export PUSH_ENABLE="${PUSH_ENABLE:-true}"
  __changelog_commit
  __update_version
  if [ "$PUSH_ENABLE" = "true" ]; then
    __git_push "$@" && export PUSH_ENABLE="" && export GITCOMMIT_PUSH="TRUE"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_tag_add() {
  local eCode=""
  local message=""
  local release=""
  local repo="$REMOTE_REPO"
  release="${1:-$(date +'%Y.%m')}"
  message="${2:-üöÄüåü Updated to version $release üöÄüåü}"
  [ -n "$release" ] || printf_exit "Usage: $APPNAME release [version] [message]"
  if __git_repo "$GITCOMMIT_ROOT_DIR" tag -a "$release" -m "$message" >/dev/null 2>/dev/null; then
    printf_green "Added tag $release"
    if __git_repo "$GITCOMMIT_ROOT_DIR" push origin "$release" >/dev/null 2>/dev/null; then
      printf_cyan "Pushed $release to $repo"
    fi
    return 0
  else
    return 1
  fi
  return
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_tag_del() {
  local repo="$REMOTE_REPO"
  if __git_repo "$GITCOMMIT_ROOT_DIR" tag -d "$1" >/dev/null 2>/dev/null; then
    printf_green "Deleted tag $1"
    if __git_repo "$GITCOMMIT_ROOT_DIR" push origin --delete "$1" >/dev/null 2>/dev/null; then
      printf_cyan "Deleted $1 from $repo"
    fi
    return 0
  else
    return 1
  fi
  return
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_signing_enabled() {
  local git_dir="${1:-$GITCOMMIT_ROOT_DIR}"
  if [ "$(git -C "$git_dir" config --get tag.gpgSign 2>/dev/null)" = "true" ] ||
    [ "$(git -C "$git_dir" config --get commit.gpgSign 2>/dev/null)" = "true" ]; then
    return 0
  fi
  return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_release_version() {
  local version="$1"
  local message="${2:-}"
  local repo="$REMOTE_REPO"
  local sign_flag=""
  # Check if signing is enabled
  if __git_signing_enabled "$GITCOMMIT_ROOT_DIR"; then
    sign_flag="-s"
  fi
  # Prepend 'v' if version starts with a number
  if [[ "$version" =~ ^[0-9] ]]; then
    version="v$version"
  fi
  # Delete local and remote tag if they exist
  if __git_repo "$GITCOMMIT_ROOT_DIR" tag -l "$version" | __grep -q "^$version$"; then
    printf_yellow "Deleting existing release $version"
    __git_repo "$GITCOMMIT_ROOT_DIR" tag -d "$version" >/dev/null 2>&1
    __git_repo "$GITCOMMIT_ROOT_DIR" push origin ":refs/tags/$version" >/dev/null 2>&1
  fi
  # Create new tag with message and push
  printf_cyan "üöÄ Creating release: $version"
  if [ -n "$message" ]; then
    __git_repo "$GITCOMMIT_ROOT_DIR" tag $sign_flag -a "$version" -m "$message" >/dev/null 2>&1
  else
    __git_repo "$GITCOMMIT_ROOT_DIR" tag $sign_flag -a "$version" -m "üöÄ Release $version üöÄ" >/dev/null 2>&1
  fi
  printf_green "üì¶ Pushing release to remote"
  __git_repo "$GITCOMMIT_ROOT_DIR" push origin "$version" >/dev/null 2>&1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__tar_release() {
  local release="" backup_dir="" eCode=""
  release="${1:-$(date +'%Y.%m.%d')}"
  backup_dir="$HOME/.local/backups/$APPNAME"
  eCode="1"
  [ -d "$backup_dir" ] || mkdir -p "$backup_dir"
  printf_cyan "Creating backup from $GITCOMMIT_ROOT_DIR to $backup_dir/$release.tar.gz "
  tar -cvf "$backup_dir/$release.tar.gz" "$GITCOMMIT_ROOT_DIR" && eCode=0
  if [ "$eCode" = 0 ]; then
    printf_green "Successfully created tar file"
  else
    printf_red "Failed to create archive"
  fi
  return $eCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# TODO: Turn this into a seperate script
__changelog_create() {
  __cmd_exists gen-changelog || return 0
  local get_changed_files="$1"
  local git_commit_mess="${2:-$GITCOMMIT_MESSAGE_SHORT}"
  local custom_action="$3"
  local changed_icon="${icon:-$GITCOMMIT_CHANGELOG_ICON}"
  local changed_files="${get_changed_files:-$(__changed_files "all")}"
  local changelog_file="$GITCOMMIT_ROOT_DIR/${GITCOMMIT_CHANGELOG_FILE_NAME:-CHANGELOG.md}"
  [ -f "$changelog_file" ] || return 0
  if [ -n "$custom_action" ]; then
    gen-changelog --silent --message "$git_commit_mess" --files "$changed_files" --icon "$changed_icon"
    GITCOMMIT_AMEND=""
  else
    gen-changelog --silent --message "$git_commit_mess" --files "$changed_files" --icon "$changed_icon"
    GITCOMMIT_AMEND=""
  fi
  gen-changelog --silent --amend
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__gitmessage() {
  GITCOMMIT_MESSAGE_FULL=""
  GITCOMMIT_MESSAGE_SHORT="${1:-$GITCOMMIT_MESSAGE_SHORT}"
  GITCOMMIT_MESSAGE_LONG="${2:-$GITCOMMIT_MESSAGE_LONG}"
  test_long_message="$(echo "$GITCOMMIT_MESSAGE_LONG" | __grep -v '^$' | head -n1 | __grep '^' || false)"
  test_short_message="$(echo "$GITCOMMIT_MESSAGE_SHORT" | __grep -v '^$' | head -n1 | __grep '^' || false)"
  if [ ${#GITCOMMIT_MESSAGE_SHORT} -ge 75 ]; then
    nomessage="true"
    GITCOMMIT_MESSAGE_SHORT="...${GITCOMMIT_MESSAGE_SHORT:0:69}..."
    printf '%s  \n' "${GITCOMMIT_MESSAGE_SHORT}" | sed 's|[ ] *| |g;s|^ ||g' >"$GITCOMMIT_MESSAGE_FILE"
  else
    nomessage="true"
    printf '%s  \n' "$GITCOMMIT_MESSAGE_SHORT" | sed 's|[ ] *| |g;s|^ ||g' >"$GITCOMMIT_MESSAGE_FILE"
  fi
  if [ -n "$test_long_message" ]; then
    GITCOMMIT_MESSAGE_LONG="$(printf '%b\n' "$GITCOMMIT_MESSAGE_LONG")"
    printf '%s  \n\n\n%s  \n' "$GITCOMMIT_MESSAGE_SHORT" "$GITCOMMIT_MESSAGE_LONG" | sed 's|[ ] *| |g;s|^ ||g' >"$GITCOMMIT_MESSAGE_FILE"
  fi
  if [ -f "$GITCOMMIT_MESSAGE_FILE" ]; then
    GITCOMMIT_MESSAGE_FULL="$(<"$GITCOMMIT_MESSAGE_FILE")"
  fi
  [ -n "$GITCOMMIT_MESSAGE_LONG" ] || unset GITCOMMIT_MESSAGE_LONG
  [ -n "$GITCOMMIT_MESSAGE_SHORT" ] || unset GITCOMMIT_MESSAGE_SHORT
  [ "$GITCOMMIT_MESSAGE_LONG" = "$GITCOMMIT_MESSAGE_SHORT" ] && unset GITCOMMIT_MESSAGE_LONG
  unset test_short_message test_long_message test_full_message
  export nomessage message_set="TRUE"
  export GITCOMMIT_MESSAGE_FULL GITCOMMIT_MESSAGE_SHORT GITCOMMIT_MESSAGE_LONG GITCOMMIT_MESSAGE_FILE
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__gitcommit_cmd() {
  export GITCOMMIT_RAN="" GITADMIN_NO_ERROR_MESSAGE=""

  if __git_merge_status "$GITCOMMIT_ROOT_DIR"; then
    printf_cyan "üîç Checking for conflict markers before commit..."
    local all_files="$(__git_repo "$GITCOMMIT_ROOT_DIR" diff --cached --name-only 2>/dev/null)"
    local marker_found=0
    local files_with_markers=""

    if [ -n "$all_files" ]; then
      while IFS= read -r file; do
        if [ -f "$GITCOMMIT_ROOT_DIR/$file" ]; then
          if __git_check_conflict_markers "$GITCOMMIT_ROOT_DIR/$file" "$GITCOMMIT_ROOT_DIR"; then
            files_with_markers="$files_with_markers  ‚ö†Ô∏è  $file\n"
            marker_found=1
          fi
        fi
      done <<<"$all_files"
    fi

    if [ $marker_found -eq 1 ]; then
      printf_red ""
      printf_red "üòø CANNOT COMMIT: Conflict markers found in staged files üòø"
      printf_yellow ""
      printf_yellow "Files with markers (<<<<<<<, =======, >>>>>>>):"
      printf "%s\n" "$files_with_markers"
      printf_yellow ""
      printf_cyan "Please resolve conflicts first:"
      printf_cyan "  gitcommit merge-resolve status     - Check all files"
      printf_cyan "  gitcommit merge-resolve edit <file> - Edit and validate"
      printf_yellow ""
      return 1
    fi
    printf_green "‚úÖ No conflict markers found ‚úÖ"
  fi

  if [ -s "$GITCOMMIT_MESSAGE_FILE" ]; then
    __git_repo "$GITCOMMIT_ROOT_DIR" commit -q -S -m "$(<"$GITCOMMIT_MESSAGE_FILE")" &>"$GITCOMMIT_TEMP_FILE" || return 1
  else
    __git_repo "$GITCOMMIT_ROOT_DIR" commit -q -S -m "$GITCOMMIT_MESSAGE_FULL" &>"$GITCOMMIT_TEMP_FILE" || return 1
  fi
  export GITCOMMIT_RAN="true" GITADMIN_NO_ERROR_MESSAGE="true"
  # Delete commit message file if it was used from .git/COMMIT_MSG or .git/COMMIT_MESS
  if [ -n "$GITCOMMIT_MESSAGE_FROM_FILE" ]; then
    if [ -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MSG" ]; then
      rm -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MSG" 2>/dev/null
    fi
    if [ -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MESS" ]; then
      rm -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MESS" 2>/dev/null
    fi
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__gitcommit() {
  __git_porcelain "$GITCOMMIT_ROOT_DIR" &>/dev/null && return
  local mess="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  local succ="Successfully committed the changes to"
  local fail="Failed to commit the changes to"
  local column_length=$(($(tput cols) - 20))
  local removemess="${mess:10:30}"
  local add_changelog_to_commit=""
  GITCOMMIT_EXITCODE="${GITCOMMIT_EXITCODE:-0}"
  [ -n "$message_set" ] || __gitmessage "$mess"
  [ -n "$message_set" ] || [ -s "$GITCOMMIT_MESSAGE_FILE" ] || printf_exit "The commit message is empty"
  [ -n "$nomessage" ] || show_message="$(__grep -shvE "$removemess" "$GITCOMMIT_MESSAGE_FILE" | __grep -v '^$' | tr '\n' ' ' | __grep '^')"
  printf_cyan "üëä Committing Changes with the following message: üëä"
  printf_yellow "$mess"
  [ -n "$show_message" ] && [ "$show_message" != "$mess" ] && printf_blue "${show_message:0:$column_length}"
  if __gitcommit_cmd; then
    if [ "$NO_MESSAGE" != "true" ]; then
      if __getexitcode "$GITCOMMIT_EXITCODE" "üîó $succ $(__git_repobase "$GITCOMMIT_ROOT_DIR") üîó" "üö´ $fail $(__git_repobase "$GITCOMMIT_ROOT_DIR") üö´"; then
        COMMIT_ID="$(__git_commitid "$GITCOMMIT_ROOT_DIR")"
      fi
    fi
  else
    printf_readline "5" <"$GITCOMMIT_TEMP_FILE"
    printf_exit "Failed to commit the changes"
  fi
  export GITCOMMIT_RAN="true" GITADMIN_NO_ERROR_MESSAGE="true"
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_init() {
  local exitCode=""
  is_url "$1" && REPO="$1" && shift 1
  message="$*"
  local emoji_default="üìÇ"
  local icon_emoji="${set_icon:-$emoji_default}"
  icon="${icon_emoji}$(__fix_emoji_spacing "$icon_emoji")"
  action="${set_action:-$emoji_default}"
  timem="$(date +'%H:%M')"
  datem="$(date +'%Y-%m-%d')"
  initm="New repo created on $datem at $timem"
  message="${setmess:-$(printf '%b\n' "$initm")}"
  setmess="$(printf '%b\n' "$action $message $icon")"
  GITCOMMIT_MESSAGE_LONG="${GITCOMMIT_MESSAGE_LONG:-$(printf '%b\n' "$setmess\n\n$message\n")}"
  __gitmessage "$setmess"
  __gitignore_init "$GITCOMMIT_ROOT_DIR" &>/dev/null
  gitadmin --dir "$GITCOMMIT_ROOT_DIR" setup "${REPO:-}" --message="$setmess" && exitCode=0 || exitCode=1
  exit ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__changed_files() {
  local files=""
  while :; do
    case $1 in
    message)
      shift
      __git_s_message || return 1
      ;;
    added)
      shift
      __git_s_added | __grep -v '^CHANGELOG.md' || return 1
      ;;
    renamed)
      shift
      __git_s_renamed | __grep -v '^CHANGELOG.md' || return 1
      ;;
    modified)
      shift
      (__git_s_updated || __git_s_modified) | __grep -v '^CHANGELOG.md' || return 1
      ;;
    deleted)
      shift
      __git_s_deleted || return 1
      ;;
    changelog)
      shift
      files+="$(__git_s_added | __grep '^CHANGELOG.md') "
      files+="$(__git_s_deleted | __grep '^CHANGELOG.md') "
      files+="$(__git_s_renamed | __grep '^CHANGELOG.md') "
      files+="$(__git_s_modified | __grep '^CHANGELOG.md') "
      results="$(printf '%b\n' "$files" | tr ' ' '\n' | sort -u | __grep -v '^$' | __grep '^')"
      [ -n "$results" ] && echo "$results"
      ;;
    all)
      shift 1
      files+="$(__changed_files added) "
      files+="$(__changed_files modified) "
      files+="$(__changed_files deleted) "
      files+="$(__changed_files renamed) "
      printf '%b\n' "$files" | tr ' ' '\n' | sort -u | __grep -v '^$' | __grep '^'
      ;;
    *)
      break
      ;;
    esac
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__default_git_action() {
  export PUSH_ENABLE="false"
  local modified added deleted message
  if [ "$1" = "--add-all-files" ]; then
    shift 1
    message="$(printf '%b\n' "$*")"
    export PUSH_ENABLE="true"
    __git_all "$message"
  else
    message="$(printf '%b\n' "$*")"
    added="$(__changed_files added)"
    deleted="$(__changed_files deleted)"
    renamed="$(__changed_files renamed)"
    modified="$(__changed_files modified)"
    files_have_been_changed="$(__changed_files all)"
    [ -n "$added" ] && for a in $added; do __git_add "$message"; done
    [ -n "$modified" ] && for m in $modified; do __git_mod "$message"; done
    [ -n "$deleted" ] && for d in $deleted; do __git_del "$message"; done
    [ -n "$renamed" ] && for r in $renamed; do __git_mod "$message"; done
    [ -n "$files_have_been_changed" ] && export PUSH_ENABLE="true" || export PUSH_ENABLE=""
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_updated() {
  exitCode="${exitCode:-0}"
  local message="$*"
  prepend="${prepend_name:-$prepend}"
  changelog_message="${prepend:-Updated}"
  changed_files="$(__changed_files modified)"
  __git_add "$(printf '%b\n' "$message")" || exitCode=$((exitCode + 1))
  __git_mod "$(printf '%b\n' "$message")" || exitCode=$((exitCode + 1))
  unset prepend
  export GITADMIN_NO_ERROR="${GITADMIN_NO_ERROR:-true}"
  [ $exitCode -eq 0 ] && export PUSH_ENABLE="${PUSH_ENABLE:-true}" || export PUSH_ENABLE=""
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_all() {
  local message="$*"
  local exitCode=0
  local emoji_default="üóÉ"
  local icon_emoji="${set_icon:-$emoji_default}"
  local icon="${icon_emoji}$(__fix_emoji_spacing "$icon_emoji")"
  local action="${set_action:-$emoji_default}"
  local prepend="${prepend_name:-}"
  local local_set_mess="$(printf '%b\n' "$message")"
  changed_files="$(__changed_files all)"
  if [ -z "$changed_files" ] || [ "$GITADMIN_NO_ERROR" != "true" ]; then
    [ "$GITADMIN_NO_ERROR_MESSAGE" = "true" ] || printf_return "üôÅ No files have changed in $GITCOMMIT_ROOT_DIR üôÅ"
    export GITADMIN_NO_ERROR_MESSAGE="true"
    return 1
  fi
  [ -n "$local_set_mess" ] || local_set_mess="$prepend"
  changelog_message="$prepend"
  setmess="$(printf '%b\n' "$action $local_set_mess $icon")"
  GITCOMMIT_MESSAGE_LONG="$changed_files"
  __gitmessage "$setmess" "$changed_files"
  if __git_repo "$GITCOMMIT_ROOT_DIR" add . &>/dev/null && __gitcommit "$setmess"; then
    __changelog_create "$setmess" "$changed_files"
  else
    exitCode+=$((exitCode + 1))
  fi
  unset changed_files prepend
  [ $exitCode -eq 0 ] && export PUSH_ENABLE="${PUSH_ENABLE:-true}" || export PUSH_ENABLE=""
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_mod() {
  local message="$*"
  local exitCode=0
  local local_set_mess=""
  local emoji_default="üóÉ"
  local icon_emoji="${set_icon:-$emoji_default}"
  local icon="${icon_emoji}"
  local action_emoji="${set_action:-$emoji_default}"
  local action="${action_emoji}$(__fix_emoji_spacing "$action_emoji")"
  local prepend="${prepend_name:-Modified}:"
  changed_files="$(__changed_files all)"
  if [ -z "$changed_files" ] || [ "$GITADMIN_NO_ERROR" != "true" ]; then
    [ "$GITADMIN_NO_ERROR_MESSAGE" = "true" ] || printf_return "üôÅ No files have changed in $GITCOMMIT_ROOT_DIR üôÅ"
    export GITADMIN_NO_ERROR_MESSAGE="true"
    return 1
  fi
  for file in $changed_files; do
    f="$file"
    changelog_message="$prepend"
    local_set_mess="$prepend $f"
    setmess="$(printf '%b\n' "$action $local_set_mess $icon")"
    GITCOMMIT_MESSAGE_LONG="$(printf '%b\n' "$prepend $f" | sed "s|$f.*.$f|$f|g")"
    __gitmessage "$setmess"
    if __git_repo "$GITCOMMIT_ROOT_DIR" add "$f" &>/dev/null && __gitcommit "$setmess"; then
      __changelog_create "$f"
    else
      exitCode+=$((exitCode + 1))
    fi
  done
  [ $exitCode -eq 0 ] && export PUSH_ENABLE="${PUSH_ENABLE:-true}" || export PUSH_ENABLE=""
  unset changed_files prepend
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional git helper functions (previously external)
# - - - - - - - - - - - - - - - - - - - - - - - - -
__basename() {
  basename -- "${1:-.}" 2>/dev/null
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_top_dir() {
  git -C "${1:-.}" rev-parse --show-toplevel 2>/dev/null |
    __grep -v fatal && return 0 || echo "${1:-$PWD}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for git lock file
__git_check_lock() {
  local git_dir="${1:-$GITCOMMIT_ROOT_DIR}"
  local lock_file="$git_dir/.git/index.lock"
  if [ -f "$lock_file" ]; then
    local lock_age=0
    if [ -f "$lock_file" ]; then
      lock_age=$(( $(date +%s) - $(stat -c %Y "$lock_file" 2>/dev/null || echo "0") ))
    fi
    # If lock is older than 5 minutes, it's probably stale
    if [ "$lock_age" -gt 300 ]; then
      printf_yellow "Removing stale git lock file (age: ${lock_age}s)"
      rm -f "$lock_file" 2>/dev/null
      return 0
    else
      printf_red "Git lock file exists: $lock_file"
      printf_red "Another git process may be running (lock age: ${lock_age}s)"
      printf_yellow "Remove with: rm -f \"$lock_file\""
      return 1
    fi
  fi
  return 0
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_remote_pull() {
  local remote_url=""
  remote_url="$(git -C "${1:-.}" remote -v 2>/dev/null | __grep push | head -n 1 | awk '{print $2}' 2>/dev/null | __grep '^')"
  if [ -n "$remote_url" ]; then
    echo "$remote_url"
    return 0
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_remote_fetch() {
  local remote_url=""
  remote_url="$(git -C "${1:-.}" remote -v 2>/dev/null | __grep fetch | head -n 1 | awk '{print $2}' 2>/dev/null | __grep '^')"
  if [ -n "$remote_url" ]; then
    echo "$remote_url"
    return 0
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_remote_origin() {
  local dir="${1:-$GITCOMMIT_ROOT_DIR}"
  local origin_url="" push_url="" fetch_url=""

  # Try push URL first (important for forks)
  push_url="$(git -C "$dir" remote -v 2>/dev/null | __grep 'push' | head -n 1 | awk '{print $2}' 2>/dev/null | __grep '^')"

  # Fallback to fetch URL
  if [ -z "$push_url" ]; then
    fetch_url="$(git -C "$dir" remote -v 2>/dev/null | __grep 'fetch' | head -n 1 | awk '{print $2}' 2>/dev/null | __grep '^')"
  fi

  origin_url="${push_url:-$fetch_url}"

  if [ -n "$origin_url" ]; then
    echo "$origin_url"
    return 0
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_porcelain_count() {
  [ -d "$(__git_top_dir ${1:-.})/.git" ] &&
    [ "$(git -C "${1:-.}" status --porcelain 2>/dev/null | wc -l 2>/dev/null)" -eq "0" ] &&
    return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_porcelain() {
  __git_porcelain_count "${1:-.}" &&
    return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_repobase() { __basename "$(__git_top_dir "${1:-$PWD}")" 2>/dev/null || echo "$(__basename "$PWD")"; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
# End additional git helper functions
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_add() {
  local message="$*"
  local exitCode=0
  local emoji_default="‚ùì"
  local icon_emoji="${set_icon:-$emoji_default}"
  local icon="${icon_emoji}"
  local action_emoji="${set_action:-$emoji_default}"
  local action="${action_emoji}$(__fix_emoji_spacing "$action_emoji")"
  local prepend="${prepend_name:-Added}:"
  changed_files="$(__changed_files all)"
  if [ -z "$changed_files" ] || [ "$GITADMIN_NO_ERROR" != "true" ]; then
    [ "$GITADMIN_NO_ERROR_MESSAGE" = "true" ] || printf_return "üôÅ No files have been added in $GITCOMMIT_ROOT_DIR üôÅ"
    export GITADMIN_NO_ERROR_MESSAGE="true"
    return 1
  fi
  for file in $changed_files; do
    f="$file"
    setmess="$(printf '%b\n' "$action $prepend $f $icon")"
    GITCOMMIT_MESSAGE_LONG="$(printf '%b\n' "$prepend $f" | sed "s|$f.*.$f|$f|g")"
    __gitmessage "$setmess"
    __git_repo "$GITCOMMIT_ROOT_DIR" add "$f" &>/dev/null
    __gitcommit "$setmess" || exitCode+=$((exitCode + 1))
    __changelog_create "$f"
  done
  unset changed_files prepend
  [ $exitCode -eq 0 ] && export PUSH_ENABLE="${PUSH_ENABLE:-true}" || export PUSH_ENABLE=""
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_del() {
  local message="$*"
  local exitCode=0
  local local_set_mess=""
  local emoji_default="‚ûñ"
  local icon_emoji="${set_icon:-$emoji_default}"
  local icon="${icon_emoji}"
  local action_emoji="${set_action:-$emoji_default}"
  local action="${action_emoji}$(__fix_emoji_spacing "$action_emoji")"
  local prepend="${prepend_name:-Deleted}:"
  changed_files="$(__changed_files deleted)"
  if [ -z "$changed_files" ] || [ "$GITADMIN_NO_ERROR" != "true" ]; then
    [ "$GITADMIN_NO_ERROR_MESSAGE" = "true" ] || printf_return "üôÅ No files have been deleted in $GITCOMMIT_ROOT_DIR üôÅ"
    export GITADMIN_NO_ERROR_MESSAGE="true"
    return 1
  fi
  for file in $changed_files; do
    f="$file"
    setmess="$(printf '%b\n' "$action $prepend $f $icon")"
    GITCOMMIT_MESSAGE_LONG="$(printf '%b\n' "$prepend $f" | sed "s|$f.*.$f|$f|g")"
    __gitmessage "$setmess"
    if __git_repo "$GITCOMMIT_ROOT_DIR" rm "$f" &>/dev/null && __gitcommit "$setmess"; then
      __changelog_create "$f"
    else
      exitCode+=$((exitCode + 1))
    fi
  done
  unset changed_files prepend
  [ $exitCode -eq 0 ] && export PUSH_ENABLE="${PUSH_ENABLE:-true}" || export PUSH_ENABLE=""
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_renamed() {
  local file_from="${1//$GITCOMMIT_ROOT_DIR\//}" && shift 1
  local file_move="${1//$GITCOMMIT_ROOT_DIR\//}" && shift 1
  local message="$*"
  local exitCode=0
  local local_set_mess=""
  local emoji_default="‚úîÔ∏è"
  local icon_emoji="${set_icon:-$emoji_default}"
  local icon="${icon_emoji}"
  local action_emoji="${set_action:-$emoji_default}"
  local action="${action_emoji}$(__fix_emoji_spacing "$action_emoji")"
  local prepend="${prepend_name:-Renamed}:"
  local create_dir="$(dirname "$(realpath "$file_move")")"
  [ -n "$file_from" ] && [ -n "$file_move" ] || return 1
  [ -d "$create_dir" ] || mkdir -p "$(dirname "$create_dir")"
  [ -e "$file_move" ] && mv -f "$file_from" "$file_move" &>/dev/null
  setmess="$(printf '%b\n' "$action $prepend $file_from ‚û° $file_move $icon")"
  GITCOMMIT_MESSAGE_LONG="$(printf '%b\n%b\n' "Deleted: $file_from" "Added: $file_move" | sed "s|$f.*.$f|$f|g")"
  __gitmessage "$setmess"
  if __git_repo "$GITCOMMIT_ROOT_DIR" rm "$file_from" -rf &>/dev/null; then
    __changelog_create "$file_from" "$action Deleted: $file_from $icon\n\n\nDeleted $file_from" "custom"
    if __git_repo "$GITCOMMIT_ROOT_DIR" add "$file_move" &>/dev/null; then
      __changelog_create "$file_move" "$action Added: $file_from $icon\n\n\nAdded $file_move" "custom"
      __gitcommit "$setmess" || exitCode+=$((exitCode + 1))
    fi
  fi
  unset prepend
  [ $exitCode -eq 0 ] && export PUSH_ENABLE="${PUSH_ENABLE:-true}" || export PUSH_ENABLE=""
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__files() {
  local message="$*"
  local exitCode=0
  local emoji_default="‚ûñ"
  local icon_emoji="${set_icon:-$emoji_default}"
  local icon="${icon_emoji}"
  local action_emoji="${set_action:-$emoji_default}"
  local action="${action_emoji}$(__fix_emoji_spacing "$action_emoji")"
  local local_set_mess="$(printf '%b\n' "$message")"
  local added_files="$(__changed_files added)"
  local deleted_files="$(__changed_files deleted)"
  local all_files="$(printf '%s\n%s\n' "$added_files" "$deleted_files" | __grep -v '^$' | __grep '^')"
  setmess="$(printf '%b\n' "$action $local_set_mess $icon")"
  GITCOMMIT_MESSAGE_LONG="$(printf '%b\n' "$all_files")"
  if [ -n "$added_files" ]; then
    __gitmessage "$setmess" "$added_files"
    if __git_repo "$GITCOMMIT_ROOT_DIR" add $added_files &>/dev/null; then
      __changelog_create "$added_files"
    else
      unset added_files
    fi
  fi
  if [ -n "$deleted_files" ]; then
    __gitmessage "$setmess" "$deleted_files"
    if __git_repo "$GITCOMMIT_ROOT_DIR" rm $deleted_files &>/dev/null; then
      __changelog_create "$deleted_files"
    else
      unset deleted_files
    fi
  fi
  { [ -n "$added_files" ] || [ -n "$deleted_files" ]; } && __gitcommit "$setmess"
  unset prepend
  [ $exitCode -eq 0 ] && export PUSH_ENABLE="${PUSH_ENABLE:-true}" || export PUSH_ENABLE=""
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__gitignore_init() {
  local exitCode=0
  [ -e "${1:-$GITCOMMIT_ROOT_DIR}/.gitignore" ] && return
  if [ -d "${1:-$GITCOMMIT_ROOT_DIR}/node_modules" ]; then
    gitignore --dir "${1:-$GITCOMMIT_ROOT_DIR}" dirignore default node
  else
    gitignore --dir "${1:-$GITCOMMIT_ROOT_DIR}" dirignore default
  fi
  __test_gitignore
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__test_gitignore() {
  if ! __grep -sh -A1 '# ignore commit message' "${1:-$GITCOMMIT_ROOT_DIR}/.gitignore" | __grep -q ^'**/.gitcommit'; then
    printf '%s\n%s\n' '# ignore commit message' '**/.gitcommit' >>"$GITCOMMIT_ROOT_DIR/.gitignore"
  fi
  if [ -d "${1:-$GITCOMMIT_ROOT_DIR}/.git" ]; then
    git -C "${1:-$GITCOMMIT_ROOT_DIR}" add .gitignore &>/dev/null && git -C "${1:-$GITCOMMIT_ROOT_DIR}" commit -q -S -m "ü§ñ Added .gitignore ü§ñ" ".gitignore" || return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_root() {
  if git -C "${1:-$GITCOMMIT_ROOT_DIR}" rev-parse --show-toplevel >/dev/null 2>&1; then
    git -C "${1:-$GITCOMMIT_ROOT_DIR}" rev-parse --show-toplevel 2>/dev/null
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_dir() {
  local git_dir="" makerepo=""
  git_dir="${1:-$GITCOMMIT_ROOT_DIR}"
  makerepo=""
  if [ "$(git -C "$git_dir" rev-parse --is-inside-work-tree 2>/dev/null)" == "" ]; then
    printf_read_question "4" "$git_dir is not a repo! Would you like to turn into a git repo? y/N" "1" "makerepo"
    if printf_answer_yes "$makerepo"; then
      __gitignore_init "$git_dir"
      gen-gitattr --dir "$git_dir" save &>/dev/null
      gitadmin --dir "$git_dir" setup
      exit $?
    else
      printf_error "You are not in a git repo"
      exit 1
    fi
  fi
  [ -d "$git_dir" ] || printf_exit "$git_dir doesn't seem to be a directory"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_commitid() {
  echo -n "$(git -C "${1:-$GITCOMMIT_ROOT_DIR}" rev-parse --short HEAD)"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_check_cherry() {
  if __git_repo "$GITCOMMIT_ROOT_DIR" cherry -v 2>&1 | wc -l | __grep -q '0'; then
    return 1
  else
    return 0
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_check_ahead() {
  if __git_repo "$GITCOMMIT_ROOT_DIR" log --oneline origin..HEAD 2>&1 | wc -l | __grep -q '0'; then
    return 1
  else
    return 0
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_check_branch() {
  if __git_repo "$GITCOMMIT_ROOT_DIR" branch -avvv 2>&1 | __grep -q ': ahead '; then
    return 0
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_check_push() {
  local exitCode=1
  if [ "$GITCOMMIT_PUSH_VERSION" = "true" ]; then
    exitCode=0
  elif [ "$(__git_repo "$GITCOMMIT_ROOT_DIR" diff --stat origin/main 2>/dev/null | wc -l)" -ne 0 ]; then
    exitCode=0
  elif __git_check_ahead; then
    exitCode=0
  else
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_push_check() {
  if __git_check_push; then
    return 0
  elif __git_check_cherry; then
    return 0
  elif __git_check_ahead; then
    return 0
  elif __git_check_branch; then
    return 0
  elif git s | __grep -v '## ' | __grep -q '^'; then
    return 0
  elif [ -n "$GITCOMMIT_RAN" ]; then
    return 0
  elif [ "$PUSH_ENABLE" = "true" ]; then
    return 0
  elif [ -n "$FORCE_PUSH" ]; then
    return 0
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_smart_merge() {
  local source_branch="$1"
  local merge_strategy="${2:-auto}"
  local custom_message="$3"
  local git_dir="${GITCOMMIT_ROOT_DIR}"
  local current_branch=""
  local merge_msg=""
  local exitCode=0

  if [ -z "$source_branch" ]; then
    printf_exit "Usage: $APPNAME merge <source_branch> [strategy] [message]\n  strategy: auto (default), ff, no-ff, squash\n  message: Custom merge commit message"
  fi

  current_branch="$(__git_repo "$git_dir" branch --show-current 2>/dev/null)"
  if [ -z "$current_branch" ]; then
    printf_exit "üòø Failed to detect current branch üòø"
  fi

  if [ "$current_branch" = "$source_branch" ]; then
    printf_exit "üòø Cannot merge branch into itself: $current_branch üòø"
  fi

  if ! __git_repo "$git_dir" rev-parse --verify "$source_branch" &>/dev/null; then
    printf_exit "üòø Source branch does not exist: $source_branch üòø"
  fi

  if ! __git_repo "$git_dir" diff-index --quiet HEAD -- 2>/dev/null; then
    printf_yellow "‚ö†Ô∏è You have uncommitted changes ‚ö†Ô∏è"
    printf_cyan "üîπ Stash changes: git stash"
    printf_cyan "üîπ Commit changes: gitcommit all <message>"
    printf_cyan "üîπ Or discard changes: git reset --hard"
    printf_exit "üòø Please commit or stash changes before merging üòø"
  fi

  printf_custom "6" "üîÄ Merging $source_branch into $current_branch üîÄ"

  local can_ff="false"
  if __git_repo "$git_dir" merge-base --is-ancestor HEAD "$source_branch" 2>/dev/null; then
    can_ff="true"
    printf_custom "2" "‚ú® Fast-forward merge possible ‚ú®"
  fi

  case "$merge_strategy" in
  ff)
    if [ "$can_ff" = "true" ]; then
      __git_repo "$git_dir" merge --ff-only "$source_branch"
      exitCode=$?
    else
      printf_exit "üòø Fast-forward not possible - branches have diverged üòø"
    fi
    ;;

  no-ff)
    merge_msg="${custom_message:-Merge branch '$source_branch' into $current_branch}"
    __git_repo "$git_dir" merge --no-ff -m "üîÄ $merge_msg üîÄ" "$source_branch"
    exitCode=$?
    ;;

  squash)
    merge_msg="${custom_message:-Squash merge branch '$source_branch' into $current_branch}"
    __git_repo "$git_dir" merge --squash "$source_branch"
    exitCode=$?
    if [ $exitCode -eq 0 ]; then
      printf_custom "3" "üì¶ Changes squashed - creating commit üì¶"
      __git_repo "$git_dir" commit -m "üì¶ $merge_msg üì¶"
      exitCode=$?
    fi
    ;;

  auto|*)
    if [ "$can_ff" = "true" ]; then
      printf_custom "2" "üöÄ Using fast-forward merge üöÄ"
      __git_repo "$git_dir" merge --ff "$source_branch"
      exitCode=$?
    else
      merge_msg="${custom_message:-Merge branch '$source_branch' into $current_branch}"
      printf_custom "3" "üîÄ Creating merge commit üîÄ"
      __git_repo "$git_dir" merge --no-ff -m "üîÄ $merge_msg üîÄ" "$source_branch"
      exitCode=$?
    fi
    ;;
  esac

  if [ $exitCode -ne 0 ]; then
    if __git_repo "$git_dir" status | __grep_lang_c -q "Unmerged paths\|both modified\|both added"; then
      printf_red "üòø MERGE CONFLICT DETECTED üòø"
      printf_yellow ""
      printf_yellow "Conflicted files:"
      __git_repo "$git_dir" diff --name-only --diff-filter=U | while read file; do
        printf_custom "1" "  ‚ö†Ô∏è  $file"
      done
      printf_yellow ""
      printf_cyan "üîß Quick resolution options:"
      printf_cyan "  gitcommit merge-resolve status              - Check status"
      printf_cyan "  gitcommit merge-resolve show <file>         - View conflicts"
      printf_cyan "  gitcommit merge-resolve ours <file>         - Keep current (auto-stages)"
      printf_cyan "  gitcommit merge-resolve theirs <file>       - Keep incoming (auto-stages)"
      printf_cyan "  gitcommit merge-resolve edit <file>         - Edit manually (validates)"
      printf_cyan "  gitcommit merge-resolve abort               - Abort merge"
      printf_yellow ""
      printf_cyan "üí° Pro tip: The resolve commands automatically stage files and check for markers"
      printf_yellow ""
      return 1
    else
      printf_red "üòø Merge failed üòø"
      return $exitCode
    fi
  fi

  printf_green "‚úÖ Successfully merged $source_branch into $current_branch ‚úÖ"

  local merge_commit="$(__git_repo "$git_dir" rev-parse HEAD)"
  printf_cyan "üìù Merge commit: ${merge_commit:0:8}"

  if [ "$can_ff" = "false" ] || [ "$merge_strategy" = "no-ff" ]; then
    printf_cyan ""
    printf_cyan "Changed files:"
    __git_repo "$git_dir" diff --name-status HEAD~1 HEAD | while read status file; do
      case "$status" in
      M) printf_custom "3" "  üìù Modified: $file" ;;
      A) printf_custom "2" "  ‚ú® Added: $file" ;;
      D) printf_custom "1" "  üóëÔ∏è  Deleted: $file" ;;
      R*) printf_custom "6" "  ‚ôªÔ∏è  Renamed: $file" ;;
      esac
    done
  fi

  return 0
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_check_conflict_markers() {
  local file="$1"
  local git_dir="${2:-$GITCOMMIT_ROOT_DIR}"
  local has_markers=0

  if __grep_lang_c -q '^<<<<<<<\|^=======\|^>>>>>>>' "$file" 2>/dev/null; then
    has_markers=1
  fi

  return $has_markers
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_merge_status() {
  local git_dir="${1:-$GITCOMMIT_ROOT_DIR}"

  if [ -f "$git_dir/.git/MERGE_HEAD" ]; then
    return 0
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_merge_resolve() {
  local action="${1:-status}"
  local git_dir="${GITCOMMIT_ROOT_DIR}"
  local conflicted_files=""
  local files_with_markers=""
  local exitCode=0

  if ! __git_merge_status "$git_dir"; then
    printf_yellow "‚ÑπÔ∏è  No merge in progress"
    return 0
  fi

  conflicted_files="$(__git_repo "$git_dir" diff --name-only --diff-filter=U 2>/dev/null)"

  case "$action" in
  status|check)
    if [ -z "$conflicted_files" ]; then
      printf_green "‚úÖ No conflicted files found ‚úÖ"

      printf_cyan ""
      printf_cyan "Checking for leftover conflict markers..."

      local all_changed="$(__git_repo "$git_dir" diff --name-only HEAD 2>/dev/null)"
      local marker_count=0

      if [ -n "$all_changed" ]; then
        while IFS= read -r file; do
          if [ -f "$git_dir/$file" ]; then
            if __git_check_conflict_markers "$git_dir/$file" "$git_dir"; then
              if [ $marker_count -eq 0 ]; then
                printf_red ""
                printf_red "üòø WARNING: Conflict markers still present in files üòø"
                printf_yellow ""
              fi
              printf_custom "1" "  ‚ö†Ô∏è  $file"
              ((marker_count++))
            fi
          fi
        done <<<"$all_changed"
      fi

      if [ $marker_count -gt 0 ]; then
        printf_yellow ""
        printf_yellow "Found $marker_count file(s) with conflict markers (<<<<<<<, =======, >>>>>>>)"
        printf_cyan "Please edit these files to remove markers before committing"
        return 1
      else
        printf_cyan ""
        printf_cyan "‚ú® All conflicts resolved and no markers found ‚ú®"
        printf_cyan ""
        printf_cyan "Ready to complete merge:"
        printf_custom "2" "  git commit"
        printf_custom "2" "  OR: gitcommit all \"Merge commit message\""
        return 0
      fi
    else
      printf_red "üòø Unresolved merge conflicts üòø"
      printf_yellow ""
      printf_yellow "Conflicted files:"
      echo "$conflicted_files" | while IFS= read -r file; do
        printf_custom "1" "  ‚ö†Ô∏è  $file"
      done
      printf_yellow ""
      printf_cyan "Use: gitcommit merge-resolve show <file> - to see conflicts"
      printf_cyan "Use: gitcommit merge-resolve edit <file> - to edit file"
      printf_cyan "Use: gitcommit merge-resolve ours <file> - to keep current branch version"
      printf_cyan "Use: gitcommit merge-resolve theirs <file> - to keep incoming branch version"
      return 1
    fi
    ;;

  show)
    shift 1 2>/dev/null || true
    local show_file="$1"

    if [ -z "$show_file" ]; then
      printf_exit "Usage: $APPNAME merge-resolve show <file>"
    fi

    if [ ! -f "$git_dir/$show_file" ]; then
      printf_exit "üòø File not found: $show_file üòø"
    fi

    printf_custom "6" "üîç Showing conflicts in: $show_file üîç"
    printf_yellow ""

    local in_conflict=0
    local conflict_num=0
    local line_num=0

    while IFS= read -r line; do
      ((line_num++))

      if echo "$line" | __grep_lang_c -q '^<<<<<<<'; then
        ((conflict_num++))
        in_conflict=1
        printf_yellow "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        printf_custom "6" "Conflict #$conflict_num (line $line_num):"
        printf_custom "2" "‚ñº CURRENT BRANCH (ours) ‚ñº"
      elif echo "$line" | __grep_lang_c -q '^======='; then
        printf_custom "1" "‚ñ≤ CURRENT BRANCH ‚ñ≤"
        printf_yellow "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        printf_custom "3" "‚ñº INCOMING BRANCH (theirs) ‚ñº"
      elif echo "$line" | __grep_lang_c -q '^>>>>>>>'; then
        printf_custom "1" "‚ñ≤ INCOMING BRANCH ‚ñ≤"
        printf_yellow "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        in_conflict=0
      else
        if [ $in_conflict -eq 1 ]; then
          echo "  $line"
        fi
      fi
    done <"$git_dir/$show_file"

    if [ $conflict_num -eq 0 ]; then
      printf_green "‚úÖ No conflicts found in this file ‚úÖ"
    else
      printf_yellow ""
      printf_cyan "Found $conflict_num conflict(s) in $show_file"
      printf_cyan ""
      printf_cyan "Resolution options:"
      printf_cyan "  gitcommit merge-resolve edit $show_file     - Edit manually"
      printf_cyan "  gitcommit merge-resolve ours $show_file     - Keep current branch"
      printf_cyan "  gitcommit merge-resolve theirs $show_file   - Keep incoming branch"
    fi
    ;;

  edit)
    shift 1 2>/dev/null || true
    local edit_file="$1"

    if [ -z "$edit_file" ]; then
      printf_exit "Usage: $APPNAME merge-resolve edit <file>"
    fi

    if [ ! -f "$git_dir/$edit_file" ]; then
      printf_exit "üòø File not found: $edit_file üòø"
    fi

    local editor="${EDITOR:-${VISUAL:-vi}}"
    printf_custom "6" "‚úèÔ∏è  Opening $edit_file in $editor ‚úèÔ∏è"

    "$editor" "$git_dir/$edit_file"

    if __git_check_conflict_markers "$git_dir/$edit_file" "$git_dir"; then
      printf_yellow ""
      printf_yellow "‚ö†Ô∏è  Conflict markers still present in file ‚ö†Ô∏è"
      printf_cyan "Make sure to remove all <<<<<<< ======= >>>>>>> markers"
      return 1
    else
      printf_green ""
      printf_green "‚úÖ No conflict markers found ‚úÖ"
      printf_cyan "Stage this file: git add $edit_file"
      return 0
    fi
    ;;

  ours)
    shift 1 2>/dev/null || true
    local ours_file="$1"

    if [ -z "$ours_file" ]; then
      printf_exit "Usage: $APPNAME merge-resolve ours <file>"
    fi

    printf_custom "2" "‚úÖ Keeping current branch version of: $ours_file ‚úÖ"
    __git_repo "$git_dir" checkout --ours "$ours_file" && __git_repo "$git_dir" add "$ours_file"
    exitCode=$?

    if [ $exitCode -eq 0 ]; then
      printf_green "‚úÖ Resolved with current branch version ‚úÖ"
    else
      printf_red "üòø Failed to resolve with ours üòø"
    fi
    return $exitCode
    ;;

  theirs)
    shift 1 2>/dev/null || true
    local theirs_file="$1"

    if [ -z "$theirs_file" ]; then
      printf_exit "Usage: $APPNAME merge-resolve theirs <file>"
    fi

    printf_custom "3" "‚úÖ Keeping incoming branch version of: $theirs_file ‚úÖ"
    __git_repo "$git_dir" checkout --theirs "$theirs_file" && __git_repo "$git_dir" add "$theirs_file"
    exitCode=$?

    if [ $exitCode -eq 0 ]; then
      printf_green "‚úÖ Resolved with incoming branch version ‚úÖ"
    else
      printf_red "üòø Failed to resolve with theirs üòø"
    fi
    return $exitCode
    ;;

  abort)
    printf_yellow "‚ö†Ô∏è  Aborting merge ‚ö†Ô∏è"
    __git_repo "$git_dir" merge --abort
    exitCode=$?

    if [ $exitCode -eq 0 ]; then
      printf_green "‚úÖ Merge aborted successfully ‚úÖ"
    else
      printf_red "üòø Failed to abort merge üòø"
    fi
    return $exitCode
    ;;

  *)
    printf_exit "Usage: $APPNAME merge-resolve [status|show|edit|ours|theirs|abort] <file>\n\nCommands:\n  status          - Check merge status and find leftover markers\n  show <file>     - Display conflicts in file with context\n  edit <file>     - Edit file in editor and validate markers removed\n  ours <file>     - Keep current branch version\n  theirs <file>   - Keep incoming branch version\n  abort           - Abort the merge"
    ;;
  esac

  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_custom_pull() {
  local git_dir="${1:-$GITCOMMIT_ROOT_DIR}"
  local exitCode=0
  if [ -d "$git_dir/.git" ]; then
    __git_auto_pull "$git_dir"
    exitCode=$?
    if [ $exitCode -eq 0 ]; then
      printf_green "‚úÖ Pull from $(__git_remote_pull 2>/dev/null || echo "origin") has completed ‚úÖ"
    else
      printf_red "üòø Pull from $(__git_remote_pull 2>/dev/null || echo "origin") has failed üòø"
    fi
  else
    printf_red "‚ö†Ô∏è  Not a git repository: $git_dir ‚ö†Ô∏è"
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_custom_push() {
  local git_dir="${1:-$GITCOMMIT_ROOT_DIR}"
  local remote_origin="" exitCode=0 retVal=0
  if [ -d "$git_dir/.git" ]; then
    printf_custom "4" "üêõ Pushing the repo in $git_dir üêõ"
    __git_auto_push "$git_dir"
    exitCode=$?

    if [ -f "$git_dir/.gitmirror" ]; then
      while read -r url; do
        printf '%b' "$(printf_blue "üëæ Pushing to mirror $url: ")"
        if git -C "$git_dir" push "$url" -q 2>/dev/null; then
          retVal=0
          printf_green "success üëæ"
        else
          retVal=1
          printf_red "Failed ‚ö†Ô∏è"
          exitCode=$((exitCode + retVal))
        fi
      done <"$git_dir/.gitmirror"
    fi

    remote_origin="$(__git_remote_push 2>/dev/null || echo "origin")"
    if [ $exitCode -eq 0 ]; then
      printf_green "üëæ Push to $remote_origin has completed üëæ"
    else
      printf_red "üòø Push to $remote_origin has failed üòø"
    fi
  else
    printf_red "‚ö†Ô∏è  Not a git repository: $git_dir ‚ö†Ô∏è"
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_push() {
  local GITCOMMIT_EXITCODE=0 git_dir="" git_repo="" git_remote=""
  local git_failed="" git_succes="" git_push="" git_repo_clean=""
  git_dir="${1:-$GITCOMMIT_ROOT_DIR}"
  errorlog="$GITCOMMIT_ERROR_LOG"
  git_icon_succes="„äóÔ∏è "
  git_icon_failed="üòø "
  git_remote="$(__git_remote_push 2>/dev/null || echo "")"
  if __git_push_check; then
    if [ -z "$git_remote" ]; then
      printf_yellow "‚ö†Ô∏è No remote configured - skipping push ‚ö†Ô∏è"
      return 0
    fi
    git_repo="$(__git_remote_fetch "$GITCOMMIT_ROOT_DIR" 2>/dev/null || echo "$REMOTE_REPO")"
    git_repo_clean="$(echo "$git_repo" | __sanitize_url)"
    git_failed="Failed to push the changes to $git_repo:"
    git_succes="Successfully pushed the changes for commit ID:"
    remote_formatted="$(echo "$git_remote" | sed 's|\.git$||g' | __grep '^' || echo "")"
    [ -f "$git_dir/.nopush" ] && return
    am_i_online --error -m "üö´ No internet connection. Skipping push üö´" || exit 1
    if [ "$git_repo" != "localdir" ]; then
      if echo "$git_remote" | __grep -F 'github\.com'; then
        __github_create_repo "${git_repo_clean}"
      fi
      if [ -n "$FORCE_PUSH" ]; then
        printf_green "üîº Pushing the changes to $git_repo_clean üîº"
        git -C "$git_dir" push -f -q 2>"$GITCOMMIT_ERROR_LOG" >/dev/null && GITCOMMIT_EXITCODE=0 || GITCOMMIT_EXITCODE=1
        __getexitcode $GITCOMMIT_EXITCODE "$git_icon_succes $git_succes $(__git_commitid "$git_dir")$git_icon_succes" "$git_icon_failed$git_failed $(<"$errorlog") $git_icon_failed"
      elif [[ "$*" =~ --automated ]] || [[ "$*" =~ --force ]]; then
        printf_green "üîº Pushing the changes to $git_repo_clean üîº"
        git -C "$git_dir" push -q 2>"$GITCOMMIT_ERROR_LOG" >/dev/null && GITCOMMIT_EXITCODE=0 || GITCOMMIT_EXITCODE=1
        __getexitcode $GITCOMMIT_EXITCODE "$git_icon_succes $git_succes $(__git_commitid "$git_dir")$git_icon_succes" "$git_icon_failed$git_failed $(<"$errorlog") $git_icon_failed"
      else
        if [ "$GITCOMMIT_NO_CONFIRM" != "true" ]; then
          printf_read_question "3" "Should I push to $git_repo_clean? [y/n]" "1" "git_push"
        else
          git_push="Y"
        fi
        if printf_answer_yes "$git_push"; then
          printf_green "üìç Pushing the changes to $git_repo_clean üìç"
          git -C "$git_dir" push -q 2>"$GITCOMMIT_ERROR_LOG" >/dev/null && GITCOMMIT_EXITCODE=0 || GITCOMMIT_EXITCODE=1
          __getexitcode $GITCOMMIT_EXITCODE "$git_icon_succes$git_succes $(__git_commitid "$git_dir") $git_icon_succes" "$git_icon_failed $git_failed $git_icon_failed"
        fi
      fi
    else
      printf_red "‚ö†Ô∏è Doesn't seem to have a remote setup ‚ö†Ô∏è"
      GITCOMMIT_EXITCODE=0
    fi
  else
    printf_red "üõ† No changes to push in $GITCOMMIT_ROOT_DIR üõ†"
    GITCOMMIT_EXITCODE=1
  fi
  return $GITCOMMIT_EXITCODE
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# smart auto-resolving pull function
__git_auto_pull() {
  local git_dir="" args="" regex="" exitCode=0
  local current_branch="" remote_origin="" error_msg="" has_commits=""
  [ -n "$1" ] && [ -d "$1/.git" ] && git_dir="$1" && shift 1 || git_dir="$GITCOMMIT_ROOT_DIR"
  args="$*"
  regex="(https?|ftp|file|git|ssh)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]"

  remote_origin="$(__git_remote_pull 2>/dev/null)"

  if [ -z "$remote_origin" ]; then
    printf_yellow "‚ö†Ô∏è  No remote configured for $(basename "$git_dir") - skipping pull"
    return 0
  fi

  current_branch="$(git -C "$git_dir" branch --show-current 2>/dev/null)"
  has_commits="$(git -C "$git_dir" rev-parse HEAD 2>/dev/null)"

  if [[ "$remote_origin" =~ $regex ]]; then
    if ! am_i_online --error; then
      printf_yellow "‚ö†Ô∏è  Offline - skipping pull for $(basename "$git_dir")"
      return 1
    fi
  fi

  if [ -n "$has_commits" ]; then
    if ! git -C "$git_dir" diff-index --quiet HEAD -- 2>/dev/null; then
      printf_cyan "üíæ Stashing uncommitted changes in $(basename "$git_dir")..."
      git -C "$git_dir" stash push -q -m "Auto-stash before pull $(date +%Y%m%d_%H%M%S)" 2>/dev/null
    fi
  fi

  error_msg="$(git -C "$git_dir" pull $args --no-edit 2>&1)"
  exitCode=$?

  if [ $exitCode -ne 0 ]; then
    if echo "$error_msg" | __grep -qi "no such ref was fetched\|couldn't find remote ref"; then
      printf_yellow "‚ö†Ô∏è  Remote repository is empty - nothing to pull"
      return 0
    elif echo "$error_msg" | __grep -qi "divergent\|diverged"; then
      printf_yellow "üîÑ Branches diverged - trying rebase strategy..."
      git -C "$git_dir" pull --rebase $args --no-edit 2>/dev/null
      exitCode=$?

      if [ $exitCode -ne 0 ]; then
        printf_yellow "‚ö†Ô∏è  Rebase failed - trying merge with strategy..."
        git -C "$git_dir" rebase --abort 2>/dev/null
        git -C "$git_dir" pull --no-rebase -X theirs $args --no-edit 2>/dev/null
        exitCode=$?
      fi
    elif echo "$error_msg" | __grep -qi "conflict"; then
      printf_yellow "‚ö†Ô∏è  Merge conflicts detected - auto-resolving with theirs strategy..."
      git -C "$git_dir" pull -X theirs $args --no-edit 2>/dev/null
      exitCode=$?
    elif echo "$error_msg" | __grep -qi "authentication\|permission\|403\|401"; then
      printf_red "üòø Authentication failed for $(basename "$git_dir") üòø"
      return 1
    else
      printf_yellow "‚ö†Ô∏è  Pull failed - trying force update..."
      printf_yellow "‚ö†Ô∏è  Force update will discard local changes"
      if git -C "$git_dir" stash list 2>/dev/null | __grep -q "Auto-stash before pull"; then
        git -C "$git_dir" stash drop -q 2>/dev/null
        printf_yellow "‚ö†Ô∏è  Dropped auto-stash due to force update"
      fi
      if [ -n "$current_branch" ]; then
        git -C "$git_dir" fetch origin "$current_branch" 2>/dev/null
        git -C "$git_dir" reset --hard "origin/$current_branch" 2>/dev/null
        exitCode=$?
      else
        git -C "$git_dir" fetch origin 2>/dev/null
        default_branch="$(git -C "$git_dir" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')"
        if [ -n "$default_branch" ]; then
          git -C "$git_dir" checkout -B "$default_branch" "origin/$default_branch" 2>/dev/null
          exitCode=$?
        else
          git -C "$git_dir" checkout -B main origin/main 2>/dev/null || git -C "$git_dir" checkout -B master origin/master 2>/dev/null
          exitCode=$?
        fi
      fi
      return $exitCode
    fi
  fi

  if git -C "$git_dir" stash list 2>/dev/null | __grep -q "Auto-stash before pull"; then
    printf_cyan "üîÑ Restoring stashed changes..."
    if ! git -C "$git_dir" stash pop -q 2>/dev/null; then
      printf_yellow "‚ö†Ô∏è  Could not auto-restore stash - conflicts may exist"
      printf_cyan "Run: git -C $git_dir stash pop"
    fi
  fi

  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# smart auto-resolving push function
__git_auto_push() {
  local git_dir="" args="" regex="" exitCode=0
  local current_branch="" remote_origin="" error_msg="" upstream_branch=""
  [ -n "$1" ] && [ -d "$1/.git" ] && git_dir="$1" && shift 1 || git_dir="$GITCOMMIT_ROOT_DIR"
  args="$*"
  regex="(https?|ftp|file|git|ssh)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]"

  [ -f "$git_dir/.no_push" ] && return 0
  [ -f "$git_dir/.nopush" ] && return 0

  remote_origin="$(__git_remote_push 2>/dev/null)"

  if [ -z "$remote_origin" ]; then
    printf_yellow "‚ö†Ô∏è  No remote configured for $(basename "$git_dir") - skipping push"
    return 0
  fi

  current_branch="$(git -C "$git_dir" branch --show-current 2>/dev/null)"

  if [ -z "$current_branch" ]; then
    printf_yellow "‚ö†Ô∏è  Detached HEAD or no branch - skipping push for $(basename "$git_dir")"
    return 1
  fi

  if [[ "$remote_origin" =~ $regex ]]; then
    if ! am_i_online --error; then
      printf_yellow "‚ö†Ô∏è  Offline - skipping push for $(basename "$git_dir")"
      return 1
    fi
  fi

  upstream_branch="$(git -C "$git_dir" rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null)"

  error_msg="$(git -C "$git_dir" push $args 2>&1)"
  exitCode=$?

  if [ $exitCode -ne 0 ]; then
    if echo "$error_msg" | __grep -qi "no upstream branch\|has no upstream branch"; then
      printf_yellow "üîÑ No upstream branch - setting upstream to origin/$current_branch..."
      git -C "$git_dir" push --set-upstream origin "$current_branch" $args 2>/dev/null
      exitCode=$?
    elif echo "$error_msg" | __grep -qi "rejected.*non-fast-forward\|rejected.*fetch first"; then
      printf_yellow "üîÑ Remote has changes - pulling with auto-resolution first..."
      if __git_auto_pull "$git_dir"; then
        printf_cyan "üîÑ Retrying push after pull..."
        git -C "$git_dir" push $args 2>/dev/null
        exitCode=$?
      else
        printf_red "üòø Pull failed - cannot push üòø"
        return 1
      fi
    elif echo "$error_msg" | __grep -qi "diverged"; then
      printf_yellow "üîÑ Branches diverged - pulling with auto-resolution first..."
      if __git_auto_pull "$git_dir"; then
        printf_cyan "üîÑ Retrying push after pull..."
        git -C "$git_dir" push $args 2>/dev/null
        exitCode=$?
      else
        printf_red "üòø Pull failed - cannot push üòø"
        return 1
      fi
    elif echo "$error_msg" | __grep -qi "authentication\|permission\|403\|401"; then
      printf_red "üòø Authentication failed for $(basename "$git_dir") üòø"
      return 1
    elif echo "$error_msg" | __grep -qi "protected branch\|required status check"; then
      printf_red "üòø Protected branch - cannot force push to $(basename "$git_dir") üòø"
      printf_yellow "‚ö†Ô∏è  This branch has protection rules that prevent direct push"
      return 1
    elif echo "$error_msg" | __grep -qi "pre-receive hook declined\|pre-push hook"; then
      printf_red "üòø Push rejected by remote hook üòø"
      printf_yellow "‚ö†Ô∏è  Remote repository has validation rules that failed"
      return 1
    elif echo "$error_msg" | __grep -qi "large file\|file size"; then
      printf_red "üòø Large file detected - consider using git-lfs üòø"
      printf_yellow "‚ö†Ô∏è  Files exceed size limits for standard git push"
      return 1
    else
      printf_yellow "‚ö†Ô∏è  Push failed with unknown error"
      printf_cyan "Error: $error_msg"
      return 1
    fi
  fi

  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__commit_custom_cmd() {
  local commit_result=0
  if [ "$1" = "update_version" ]; then
    shift 1
    version_update="update_version"
    version_file="${1:-$GITCOMMIT_ROOT_DIR/$GITCOMMIT_VERSION_FILE}"
  else
    op="${*:-.}"
  fi
  if [ "$version_update" = "update_version" ]; then
    __git_repo "$GITCOMMIT_ROOT_DIR" add "$version_file" &&
      __git_repo "$GITCOMMIT_ROOT_DIR" commit -q -S -m "$GITCOMMIT_MESSAGE_VERSION" "$version_file" &>/dev/null && commit_result=0 || commit_result=1
  elif [ -n "$GITCOMMIT_MESSAGE_FULL" ]; then
    __git_repo "$GITCOMMIT_ROOT_DIR" add $op &>/dev/null &&
      __git_repo "$GITCOMMIT_ROOT_DIR" commit -q -S -m "$GITCOMMIT_MESSAGE_FULL" &>/dev/null && commit_result=0 || commit_result=1
  else
    __git_repo "$GITCOMMIT_ROOT_DIR" add $op &>/dev/null &&
      __git_repo "$GITCOMMIT_ROOT_DIR" commit -q -S -m "$GITCOMMIT_MESSAGE_SHORT" &>/dev/null && commit_result=0 || commit_result=1
  fi
  # Delete commit message file if commit succeeded and it was used from .git/COMMIT_MSG or .git/COMMIT_MESS
  if [ "$commit_result" = "0" ] && [ -n "$GITCOMMIT_MESSAGE_FROM_FILE" ]; then
    if [ -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MSG" ]; then
      rm -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MSG" 2>/dev/null
    fi
    if [ -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MESS" ]; then
      rm -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MESS" 2>/dev/null
    fi
  fi
  return $commit_result
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_repo() {
  git -C "${1:-$GITCOMMIT_ROOT_DIR}" "${@:2}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Grep with C locale for byte-level matching
__grep_lang_c() {
  LC_ALL=C grep "$@" 2>/dev/null || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__sed_clean() {
  LC_ALL=C sed "$@" 2>/dev/null
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__fix_emoji_spacing() {
  local emoji="$1"
  local spaces=""

  # Wide emojis (complex, multi-codepoint) need 2 spaces
  # Most simple emojis need 1 space
  case "$emoji" in
  # Wide/Complex emojis - need 2 spaces
  "üë®‚Äçüíª" | "üë©‚Äçüíª" | "üßë‚Äçüíª" | "üë∑‚Äç‚ôÇÔ∏è" | "üë∑‚Äç‚ôÄÔ∏è" | "üßë‚Äçüîß" | "üßë‚Äçüè≠") spaces="  " ;;
  "üèóÔ∏è" | "üè≠" | "üè¢" | "üè™" | "üè¨") spaces="  " ;;
  # Single-width emojis - need 1 space (most common)
  "üêõ" | "‚ú®" | "üìù" | "üöÄ" | "‚ôªÔ∏è" | "üóÉÔ∏è" | "üê≥" | "üõ†Ô∏è" | "‚öôÔ∏è" | "üîß" | "‚úÖ") spaces=" " ;;
  "üî•" | "üí°" | "üì¶" | "üé®" | "üéØ" | "üìä" | "üíª" | "üñ•Ô∏è" | "‚å®Ô∏è") spaces=" " ;;
  "üåü" | "‚≠ê" | "üí´" | "‚ú¥Ô∏è" | "üå†") spaces=" " ;;
  "üì±" | "üì≤" | "üíæ" | "üíø" | "üìÄ") spaces=" " ;;
  "üéâ" | "üéä" | "üéà" | "üéÅ") spaces=" " ;;
  "‚¨ÜÔ∏è" | "‚¨áÔ∏è" | "‚û°Ô∏è" | "‚¨ÖÔ∏è" | "üîÑ" | "üîÉ") spaces=" " ;;
  # Default: try to detect by byte length
  *)
    local byte_length=$(echo -n "$emoji" | wc -c)
    if [ "$byte_length" -gt 6 ]; then
      spaces="  " # Complex emoji, likely wide
    else
      spaces=" " # Simple emoji
    fi
    ;;
  esac

  echo "$spaces"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__normalize_message_spacing() {
  local message="$1"
  local start_emoji="$2"
  local end_emoji="${3:-$start_emoji}"

  # Strategy: Use perl or python for better Unicode handling, fallback to simpler method
  # Strip emojis from start and end while preserving all other text

  # Trim all whitespace first
  message="$(echo "$message" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

  # Try perl first (most reliable for Unicode)
  if command -v perl >/dev/null 2>&1; then
    # Remove leading emojis using perl Unicode regex
    message="$(echo "$message" | perl -CS -pe 's/^[\x{1F300}-\x{1F9FF}\x{2600}-\x{27BF}\x{1F000}-\x{1F02F}\x{1F0A0}-\x{1F0FF}\x{1F100}-\x{1F64F}\x{1F680}-\x{1F6FF}\x{1F900}-\x{1F9FF}\x{1FA00}-\x{1FAFF}\x{2700}-\x{27BF}\x{24C2}-\x{1F251}\x{FE0F}\x{200D}]+\s*//')"
    # Remove trailing emojis
    message="$(echo "$message" | perl -CS -pe 's/\s*[\x{1F300}-\x{1F9FF}\x{2600}-\x{27BF}\x{1F000}-\x{1F02F}\x{1F0A0}-\x{1F0FF}\x{1F100}-\x{1F64F}\x{1F680}-\x{1F6FF}\x{1F900}-\x{1F9FF}\x{1FA00}-\x{1FAFF}\x{2700}-\x{27BF}\x{24C2}-\x{1F251}\x{FE0F}\x{200D}]+$//')"
  elif command -v python3 >/dev/null 2>&1; then
    # Fallback to python if perl not available
    message="$(echo "$message" | python3 -c "import sys, re; print(re.sub(r'^[\U0001F300-\U0001F9FF\U00002600-\U000027BF\U0001F000-\U0001F02F\U0001F0A0-\U0001F0FF\U0001F100-\U0001F64F\U0001F680-\U0001F6FF\U0001F900-\U0001F9FF\U0001FA00-\U0001FAFF\U00002700-\U000027BF\U000024C2-\U0001F251\uFE0F\u200D]+\s*', '', sys.stdin.read().strip()))")"
    message="$(echo "$message" | python3 -c "import sys, re; print(re.sub(r'\s*[\U0001F300-\U0001F9FF\U00002600-\U000027BF\U0001F000-\U0001F02F\U0001F0A0-\U0001F0FF\U0001F100-\U0001F64F\U0001F680-\U0001F6FF\U0001F900-\U0001F9FF\U0001FA00-\U0001FAFF\U00002700-\U000027BF\U000024C2-\U0001F251\uFE0F\u200D]+$', '', sys.stdin.read().strip()))")"
  else
    # Last resort: simple character stripping (may not work perfectly with all emojis)
    # Strip leading non-ASCII, non-printable characters
    local i=0
    while [ $i -lt 5 ]; do
      local before="$message"
      # Remove first few bytes if they look like emojis (high bit set)
      message="$(echo "$message" | __sed_clean 's/^[^ -~][^ -~]*//')"
      message="$(echo "$message" | sed 's/^[[:space:]]*//')"
      [ "$before" = "$message" ] && break
      i=$((i + 1))
    done
    # Strip trailing non-ASCII
    i=0
    while [ $i -lt 5 ]; do
      local before="$message"
      message="$(echo "$message" | __sed_clean 's/[^ -~][^ -~]*$//')"
      message="$(echo "$message" | sed 's/[[:space:]]*$//')"
      [ "$before" = "$message" ] && break
      i=$((i + 1))
    done
  fi

  # Final cleanup
  message="$(echo "$message" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

  # Get proper spacing for emojis
  local start_spacing="$(__fix_emoji_spacing "$start_emoji")"
  local end_spacing="$(__fix_emoji_spacing "$end_emoji")"

  # Build properly spaced message
  echo "${start_emoji}${start_spacing}${message}${end_spacing}${end_emoji}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__auto_detect_emoji() {
  local changed_files="$1"
  local emoji="üóÉÔ∏è"
  local total_files=$(echo "$changed_files" | __grep -v '^$' | wc -l)

  # Count file types
  local docker_files=$(echo "$changed_files" | __grep -cE "Dockerfile|docker-compose|\.dockerignore" || true)
  local md_files=$(echo "$changed_files" | __grep -cE "\.md$" || true)
  local bin_files=$(echo "$changed_files" | __grep -cE "^bin/" || true)
  local test_files=$(echo "$changed_files" | __grep -cE "test|spec|\.t$" || true)
  local config_files=$(echo "$changed_files" | __grep -cE "\.conf$|\.config|\.yml$|\.yaml$|\.json$" || true)
  local function_files=$(echo "$changed_files" | __grep -cE "^functions/" || true)

  # Auto-select emoji based on dominant file type (80% threshold)
  if [ "$docker_files" -gt 0 ] && [ $((docker_files * 100 / total_files)) -ge 80 ]; then
    emoji="üê≥"
  elif [ "$md_files" -gt 0 ] && [ $((md_files * 100 / total_files)) -ge 80 ]; then
    emoji="üìù"
  elif [ "$test_files" -gt 0 ] && [ $((test_files * 100 / total_files)) -ge 50 ]; then
    emoji="‚úÖ"
  elif [ "$bin_files" -gt 0 ] && [ $((bin_files * 100 / total_files)) -ge 50 ]; then
    emoji="üõ†Ô∏è"
  elif [ "$config_files" -gt 0 ] && [ $((config_files * 100 / total_files)) -ge 80 ]; then
    emoji="üîß"
  elif [ "$function_files" -gt 0 ] && [ $((function_files * 100 / total_files)) -ge 50 ]; then
    emoji="‚öôÔ∏è"
  fi

  echo "$emoji"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__auto_generate_message() {
  local changed_files="$1"
  local detected_emoji="$2"
  local message=""
  local override_emoji=""

  # Get diff statistics
  local diff_stats=$(__git_repo "$GITCOMMIT_ROOT_DIR" diff --cached --shortstat 2>/dev/null || __git_repo "$GITCOMMIT_ROOT_DIR" diff --shortstat 2>/dev/null)
  local insertions=$(echo "$diff_stats" | __grep -oE "[0-9]+ insertion" | __grep -oE "[0-9]+" || echo "0")
  local deletions=$(echo "$diff_stats" | __grep -oE "[0-9]+ deletion" | __grep -oE "[0-9]+" || echo "0")

  # Analyze diff content for keywords
  local diff_content=$(__git_repo "$GITCOMMIT_ROOT_DIR" diff --cached 2>/dev/null || __git_repo "$GITCOMMIT_ROOT_DIR" diff 2>/dev/null)

  # Smart message generation based on content and stats (message only, no emojis)
  if echo "$diff_content" | __grep -qE "^\+.*(fix|bug|error|Fixed|Bug|Error)"; then
    message="Fix issues in codebase"
    override_emoji="üêõ"
  elif echo "$diff_content" | __grep -qE "^\+.*(TODO|FIXME|XXX)"; then
    message="Update task list and TODOs"
  elif echo "$changed_files" | __grep -qE "VERSION|version\.txt"; then
    message="Version bump"
    override_emoji="üöÄ"
  elif [ "$deletions" -gt "$insertions" ] && [ "$deletions" -gt 50 ]; then
    message="Cleanup and refactor code"
    override_emoji="‚ôªÔ∏è"
  elif [ "$insertions" -gt "$((deletions * 3))" ]; then
    message="Add new features and functionality"
    override_emoji="‚ú®"
  elif echo "$changed_files" | __grep -qE "^\."; then
    message="Update configuration files"
    override_emoji="üîß"
  else
    message="Update codebase"
  fi

  # Return format: "MESSAGE|EMOJI" (emoji only if override detected)
  if [ -n "$override_emoji" ]; then
    echo "$message|$override_emoji"
  else
    echo "$message|"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__learn_from_history() {
  local file="$1"
  local learned_emoji=""

  if [ -n "$file" ] && [ -f "$file" ]; then
    learned_emoji=$(__git_repo "$GITCOMMIT_ROOT_DIR" log --oneline --follow "$file" -10 2>/dev/null |
      __grep -oE "(üêõ|‚ú®|üìù|üöÄ|‚ôªÔ∏è|üóÉÔ∏è|üê≥|üõ†Ô∏è|‚öôÔ∏è|üîß|‚úÖ)" |
      sort | uniq -c | sort -rn | head -1 |
      awk '{print $2}' || echo "")
  fi

  echo "$learned_emoji"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__commit_custom() {
  local git_repo=""
  local git_failed=""
  local git_succes=""
  local git_repo_clean=""
  local sicon="„äóÔ∏è"
  local ficon="üòø"
  local icon="${set_icon:-üóÉÔ∏è}"
  local initial_emoji="${set_action:-üóÉÔ∏è}"
  local action="${initial_emoji}$(__fix_emoji_spacing "$initial_emoji")"
  local prepend="${prepend_name:-All}:"
  local message="${GITCOMMIT_MESSAGE_SHORT:-Committing everything that changed}"
  local local_set_mess="$(printf '%b\n' "$message")"
  changed_files="$(__changed_files all)"
  if [ -z "$changed_files" ] || [ "$GITADMIN_NO_ERROR" != "true" ]; then
    [ "$GITADMIN_NO_ERROR_MESSAGE" = "true" ] || printf_return "üôÅ No files have changed in $GITCOMMIT_ROOT_DIR üôÅ"
    export GITADMIN_NO_ERROR_MESSAGE="true"
    return 1
  fi

  # Auto-detect emoji and generate intelligent message when not using COMMIT_MESS file
  if [ -z "$GITCOMMIT_MESSAGE_FROM_FILE" ]; then
    local auto_emoji="$(__auto_detect_emoji "$changed_files")"

    # Override icon/action if auto-detected and different from default
    if [ "$auto_emoji" != "üóÉÔ∏è" ] && [ "${icon}" = "üóÉÔ∏è" ]; then
      icon="$auto_emoji"
      set_icon="$auto_emoji"
      set_action="$auto_emoji"
    fi

    # Generate intelligent message if using default
    if [ "$message" = "Committing everything that changed" ]; then
      local auto_result="$(__auto_generate_message "$changed_files" "$auto_emoji")"
      local auto_message="${auto_result%|*}"
      local override_emoji="${auto_result#*|}"

      if [ -n "$auto_message" ]; then
        message="$auto_message"
        local_set_mess="$(printf '%b\n' "$message")"
        GITCOMMIT_MESSAGE_SHORT="$message"

        # Override emoji if content analysis detected a more specific one
        if [ -n "$override_emoji" ]; then
          icon="$override_emoji"
          set_icon="$override_emoji"
          set_action="$override_emoji"
        fi
      fi
    fi
  fi

  # Recalculate action based on potentially updated set_action (use smart spacing)
  local emoji_for_spacing="${set_action:-üóÉÔ∏è}"
  local smart_spaces="$(__fix_emoji_spacing "$emoji_for_spacing")"
  action="${emoji_for_spacing}${smart_spaces}"

  [ "$FORCE_PUSH" ] && ARGS="-f"
  [ -n "$local_set_mess" ] || local_set_mess="$prepend"
  changelog_message="$prepend"
  if [ -n "$GITCOMMIT_MESSAGE_FROM_FILE" ]; then
    # Message from file or AI - already has emojis, just normalize spacing
    local start_emoji="" end_emoji=""

    # Detect start emoji (first non-ASCII character sequence at beginning)
    # Use __grep_lang_c to detect bytes outside printable ASCII range
    if echo "$local_set_mess" | __grep_lang_c -q '^[[:space:]]*[^ -~]'; then
      start_emoji="$(echo "$local_set_mess" | sed -E 's/^[[:space:]]*//; s/^([^ -~]+).*/\1/' | head -c 10)"
    fi

    # Detect end emoji (last non-ASCII character sequence at end)
    if echo "$local_set_mess" | __grep_lang_c -q '[^ -~][[:space:]]*$'; then
      end_emoji="$(echo "$local_set_mess" | sed -E 's/[[:space:]]*$//; s/.*[[:space:]]([^ -~]+)$/\1/' | tail -c 10)"
    fi

    # Use detected emojis from AI/file, or fall back to default
    start_emoji="${start_emoji:-${set_action:-üóÉÔ∏è}}"
    end_emoji="${end_emoji:-$start_emoji}"

    setmess="$(__normalize_message_spacing "$local_set_mess" "$start_emoji" "$end_emoji")"
    if [ -n "$GITCOMMIT_MESSAGE_LONG" ]; then
      GITCOMMIT_MESSAGE_LONG="$(printf '%s\n\n%s' "$GITCOMMIT_MESSAGE_LONG" "$changed_files")"
    else
      GITCOMMIT_MESSAGE_LONG="$changed_files"
    fi
  else
    # Regular mode - build message with proper spacing
    setmess="$(__normalize_message_spacing "$local_set_mess" "$emoji_for_spacing" "$icon")"
    GITCOMMIT_MESSAGE_LONG="$changed_files"
  fi
  __gitmessage "$setmess" "$GITCOMMIT_MESSAGE_LONG"
  printf_cyan "üëä Committing Changes with the following message: üëä"
  printf_yellow "$GITCOMMIT_MESSAGE_SHORT"
  __commit_custom_cmd "$@"
  exitCode=$?
  if [ "$exitCode" = 0 ]; then
    __changelog_create "$changed_files"
    __update_version
    if [ ! -f "$GITCOMMIT_ROOT_DIR/.no_push" ] && __git_check_push; then
      git_repo="$(__git_remote_fetch "$GITCOMMIT_ROOT_DIR" 2>/dev/null || echo "")"
      if [ -z "$git_repo" ]; then
        printf_yellow "‚ö†Ô∏è No remote configured - skipping push ‚ö†Ô∏è"
      else
        git_failed="Failed to push the changes to $git_repo"
        git_succes="Successfully pushed the changes for commit ID:"
        git_repo_clean="$(echo "$git_repo" | __sanitize_url)"
        if echo "$git_repo_clean" | __grep -qF 'github.com'; then
          __github_create_repo "${git_repo_clean}"
        fi
        printf_green "üìç Pushing the changes to $git_repo_clean üìç"
        __git_repo "$GITCOMMIT_ROOT_DIR" push $ARGS -q &>/dev/null && GITCOMMIT_EXITCODE=0 || GITCOMMIT_EXITCODE=1
        __getexitcode $GITCOMMIT_EXITCODE "$sicon $git_succes $(__git_commitid "$GITCOMMIT_ROOT_DIR") $sicon" "$ficon $git_failed $ficon"
      fi
    fi
  else
    printf_exit "üòø Failed to commit the changes üòø"
  fi
  unset changed_files prepend
  exit "${exitCode:-0}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__write_version() {
  local vicon="üöÄ"
  local eicon="‚ö†Ô∏è"
  [ "$1" = "--force" ] && shift 1 && touch "$GITCOMMIT_ROOT_DIR/$GITCOMMIT_VERSION_FILE"
  if [ "$GITCOMMIT_NEW_VERSION" != "true" ] && [ -f "$GITCOMMIT_ROOT_DIR/$GITCOMMIT_VERSION_FILE" ]; then
    set_new_version="$(date +"$GITCOMMIT_VERSION_FORMAT")"
    get_new_version="$(<"$GITCOMMIT_ROOT_DIR/$GITCOMMIT_VERSION_FILE")"
    printf '%b\n' "$set_new_version" >"$GITCOMMIT_ROOT_DIR/$GITCOMMIT_VERSION_FILE"
    if [ "$set_new_version" = "$get_new_version" ]; then
      set_new_version="$get_new_version"
      GITCOMMIT_MESSAGE_VERSION="$eicon The version did not change $eicon"
    fi
    [ -n "$GITCOMMIT_MESSAGE_VERSION" ] || GITCOMMIT_MESSAGE_VERSION="$vicon Version Bump: $set_new_version $vicon"
    [ -n "$GITCOMMIT_NEW_VERSION" ] || printf_blue "$GITCOMMIT_MESSAGE_VERSION"
  fi
  export GITCOMMIT_NEW_VERSION="true" GITCOMMIT_MESSAGE_VERSION
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__set_version() {
  local exitCode=0
  if [ -f "$GITCOMMIT_ROOT_DIR/$GITCOMMIT_VERSION_FILE" ]; then
    local dir_name="$(basename -- "$GITCOMMIT_ROOT_DIR")"
    local git_succes="Successfully committed version:"
    local git_failed="Failed to commit the version change in"
    __commit_custom_cmd "update_version" "$GITCOMMIT_VERSION_FILE"
    if [ "$GITCOMMIT_NEW_VERSION" = "true" ]; then
      GITCOMMIT_PUSH_VERSION="true"
    fi
  fi
  export NO_MESSAGE="true" GITCOMMIT_PUSH_VERSION
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__update_version() { __write_version && __set_version || exit 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__rename_branch() {
  local fromBranch="" toBranch="" USER="" REPO=""
  fromBranch="$1" && shift 1
  toBranch="$1" && shift 1
  if [ $# -eq 1 ] && echo "$1" | __grep -q '/'; then
    USER_REPO="$1"
  elif echo "$*" | __grep -q ' '; then
    USER_REPO="$2/$3"
  else
    USER_REPO="$(basename -- "$(dirname "$GITCOMMIT_ROOT_DIR")")/$(basename -- "$GITCOMMIT_ROOT_DIR")"
  fi
  echo $USER_REPO | awk -F'/' '{print $2}' | __grep -q '^' || printf_exit "Usage:"
  # changelog_message="Renamed branch from $fromBranch to $toBranch"
  printf_blue "Changing git $fromBranch to $toBranch on $USER_REPO"
  __git_repo "$GITCOMMIT_ROOT_DIR" branch -m $fromBranch "$toBranch" &>/dev/null
  __git_repo "$GITCOMMIT_ROOT_DIR" push -u origin "$toBranch" -fq &>/dev/null
  if curl -q -LSs -X PATCH -H "Accept: application/vnd.github.v3+json" \
    -H "Authorization: token $GITCOMMIT_GITHUB_TOKEN" "https://api.github.com/repos/$USER_$REPO" \
    -d '{"default_branch":"'$toBranch'"}' | __grep -q '"default_branch": "'$fromBranch'"' &>/dev/null; then
    __git_repo "$GITCOMMIT_ROOT_DIR" push --delete origin $fromBranch -fq &>/dev/null
    printf_green "Changed the default branch on github.com/$USER_$REPO"
  fi &&
    printf_green "Successfully renamed the default branch" ||
    printf_exit 1 1 "Failed to rename the default branch"
  git config --global init.defaultBranch "$toBranch" &>/dev/null
  exit
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__curl_branch() {
  local branch="" USER="" REPO="" GITCOMMIT_EXITCODE=""
  branch="$1"
  if [ $# -eq 1 ] && echo "$1" | __grep -q '/'; then
    USER_REPO="$1"
  elif echo "$*" | __grep -q ' '; then
    USER_REPO="$2/$3"
  else
    USER_REPO="$(basename -- "$(dirname "$GITCOMMIT_ROOT_DIR")")/$(basename -- "$GITCOMMIT_ROOT_DIR")"
  fi
  echo $USER_REPO | awk -F'/' '{print $2}' | __grep -q '^' || printf_exit "Usage:"
  GITCOMMIT_EXITCODE=0
  printf_exit "$USER"/"$REPO"
  curl -q -LSs -X PATCH -H "Accept: application/vnd.github.v3+json" \
    -H "Authorization: token $GITCOMMIT_GITHUB_TOKEN" "https://api.github.com/repos/$USER_REPO" \
    -d '{"default_branch":"'$branch'"}' &>/dev/null || GITCOMMIT_EXITCODE=1
  return $GITCOMMIT_EXITCODE
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__check_ai_error() {
  local cmd_name="$1"
  local error_output="$2"
  local display_name="${3:-$cmd_name}"
  if [ -z "$error_output" ]; then
    return 0
  fi
  # Rate limit patterns (various providers)
  if echo "$error_output" | __grep -qiE 'rate.?limit|limit.?reached|too many requests|quota.?exceeded|usage.?limit|spending.?limit|billing|credits?.?(exhausted|exceeded|limit)|usage.?cap|overloaded|server.?busy|capacity|429|rate_limit_error|overloaded_error|resource.?exhausted|throttl'; then
    printf_red "‚ùå $display_name: Rate limit or quota exceeded. Please try again later."
    GITCOMMIT_AI_RATE_LIMITED="true"
    export GITCOMMIT_AI_RATE_LIMITED
    return 1
  # Authentication/authorization patterns
  elif echo "$error_output" | __grep -qiE 'unauthorized|authentication|invalid.?(token|key|api)|api.?key|credentials|403|401|permission.?denied|access.?denied|not.?authorized'; then
    printf_red "‚ùå $display_name: Authentication failed. Check your API credentials."
    return 1
  # Network/connectivity patterns
  elif echo "$error_output" | __grep -qiE 'timeout|timed.?out|connection.?(refused|reset|failed)|network.?error|unable to connect|unreachable|dns|resolve|ECONNREFUSED|ETIMEDOUT|ENOTFOUND'; then
    printf_yellow "‚ö†Ô∏è  $display_name: Network error or timeout."
    return 1
  # Command/installation patterns
  elif echo "$error_output" | __grep -qiE 'not found|command not found|no such file|cannot find|not.?installed'; then
    printf_yellow "‚ö†Ô∏è  $display_name: Command not found or not properly installed."
    return 1
  # Model availability patterns
  elif echo "$error_output" | __grep -qiE 'model.?(not.?found|unavailable|does.?not.?exist)|no.?model|invalid.?model|unknown.?model'; then
    printf_yellow "‚ö†Ô∏è  $display_name: Model not found or unavailable."
    return 1
  # Service unavailable patterns
  elif echo "$error_output" | __grep -qiE '500|502|503|504|service.?unavailable|internal.?error|server.?error|maintenance|temporarily.?unavailable'; then
    printf_yellow "‚ö†Ô∏è  $display_name: Service temporarily unavailable."
    return 1
  # Content policy / safety patterns
  elif echo "$error_output" | __grep -qiE 'content.?policy|safety|blocked|filtered|inappropriate|violation'; then
    printf_yellow "‚ö†Ô∏è  $display_name: Request blocked by content policy."
    return 1
  # Generic error patterns
  elif echo "$error_output" | __grep -qiE '^error|failed|exception|fatal'; then
    printf_yellow "‚ö†Ô∏è  $display_name: $(echo "$error_output" | head -n1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    return 1
  fi
  return 0
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Check if AI result itself contains error indicators
__check_ai_result_for_errors() {
  local result="$1"
  local display_name="${2:-AI}"
  if [ -z "$result" ]; then
    return 1  # Empty result is an error
  fi
  # Check for rate limit messages in the result
  if echo "$result" | __grep -qiE 'rate.?limit|quota.?exceeded|too many requests|limit.?reached|try again later|overloaded|capacity|throttl'; then
    printf_red "‚ùå $display_name: Rate limit detected in response."
    GITCOMMIT_AI_RATE_LIMITED="true"
    export GITCOMMIT_AI_RATE_LIMITED
    return 1
  fi
  # Check for error JSON responses
  if echo "$result" | __grep -qE '^\s*\{.*"error".*\}|"type"\s*:\s*"error"|"status"\s*:\s*"error"'; then
    printf_yellow "‚ö†Ô∏è  $display_name: Error response received."
    return 1
  fi
  # Check for HTML error pages
  if echo "$result" | __grep -qiE '^<!DOCTYPE|^<html|<title>.*error.*</title>|<h1>.*error.*</h1>'; then
    printf_yellow "‚ö†Ô∏è  $display_name: Received HTML error page instead of response."
    return 1
  fi
  return 0
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__ai_commit_message() {
  local diff_content="" prompt="" result="" changed_files=""
  local short_msg="" long_msg="" preferred_ai=""

  # Get the diff for context
  changed_files="$(__changed_files all)"
  diff_content="$(__git_repo "$GITCOMMIT_ROOT_DIR" diff --cached 2>/dev/null || __git_repo "$GITCOMMIT_ROOT_DIR" diff 2>/dev/null)"

  # Limit diff size to avoid token limits
  if [ ${#diff_content} -gt 4000 ]; then
    diff_content="${diff_content:0:4000}..."
  fi

  # Build prompt for full commit message
  prompt="Generate a git commit message for these changes with EXACTLY this format:

TITLE LINE (REQUIRED FORMAT):
{emoji} Short summary here {emoji}

Rules for title:
- MUST start with an emoji
- MUST end with the SAME emoji
- Maximum 72 characters total
- No period at the end
- Example: üîß Fixed authentication bug üîß

BODY (after blank line):
- 2-5 bullet points describing what changed and why
- Each bullet starts with a dash (-)

Common emojis: üêõ (fix), ‚ú® (feature), üìù (docs), üöÄ (release), ‚ôªÔ∏è (refactor), üîß (config/update)

Output ONLY the commit message, nothing else. No markdown, no explanations.

Files changed:
$changed_files

Diff:
$diff_content"

  # Helper function to check if string starts with emoji
  __starts_with_emoji() {
    local str="$1"
    # Match common emoji patterns at start using literal emojis
    echo "$str" | __grep -q "^[üêõ‚ú®üìùüöÄ‚ôªÔ∏èüîßüóÉÔ∏èüòø‚ö†Ô∏è‚ùåü§ñüí°üé®üî•üêûü©πüì¶üîíüîìüß™üèóÔ∏èüìåüéâüí•üö®üìÑüîçüí¨üè∑Ô∏è‚ûï‚ûñüîÄ‚¨ÜÔ∏è‚¨áÔ∏èüßπüåêüíæüìäüÜïüëå‚úîÔ∏è‚ûñ‚ùó„Ä∞Ô∏èüö§‚öíÔ∏èüè†‚ùáü¶àüêúüììüçï‚¨ÖÔ∏èüìÉüìñü§ñüìÅüîºüîÄ]"
  }

  # Helper function to extract emoji from string
  __extract_first_emoji() {
    local str="$1"
    # Extract first emoji character (use -o to get only matching part)
    echo "$str" | __grep -o "^[üêõ‚ú®üìùüöÄ‚ôªÔ∏èüîßüóÉÔ∏èüòø‚ö†Ô∏è‚ùåü§ñüí°üé®üî•üêûü©πüì¶üîíüîìüß™üèóÔ∏èüìåüéâüí•üö®üìÑüîçüí¨üè∑Ô∏è‚ûï‚ûñüîÄ‚¨ÜÔ∏è‚¨áÔ∏èüßπüåêüíæüìäüÜïüëå‚úîÔ∏è‚ûñ‚ùó„Ä∞Ô∏èüö§‚öíÔ∏èüè†‚ùáü¶àüêúüììüçï‚¨ÖÔ∏èüìÉüìñü§ñüìÅüîºüîÄ]" | head -1
  }

  # Helper function to fix commit message format
  __fix_commit_format() {
    local msg="$1"
    local emoji=""
    local text=""
    # Remove leading/trailing whitespace
    msg="$(echo "$msg" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    # Remove trailing period or ellipsis if present
    msg="${msg%.}"
    msg="${msg%...}"
    msg="${msg%‚Ä¶}"
    # Check if already has emoji at start
    if __starts_with_emoji "$msg"; then
      emoji="$(__extract_first_emoji "$msg")"
      # Remove emoji from start to get text
      text="$(echo "$msg" | sed 's/^[^[:alnum:]]*[[:space:]]*//')"
      # Remove emoji from end if present
      text="$(echo "$text" | sed 's/[[:space:]]*[^[:alnum:]]*$//')"
      # Check if ends with same emoji
      if echo "$msg" | __grep -qE "${emoji}[[:space:]]*$"; then
        echo "$msg"
      else
        echo "${emoji} ${text} ${emoji}"
      fi
    else
      # No emoji at start - add default based on content
      if echo "$msg" | __grep -qiE "^(fix|bug|patch|correct|repair)"; then
        emoji="üêõ"
      elif echo "$msg" | __grep -qiE "^(add|new|feature|implement|create)"; then
        emoji="‚ú®"
      elif echo "$msg" | __grep -qiE "^(update|change|modify|enhance|improve)"; then
        emoji="üîß"
      elif echo "$msg" | __grep -qiE "^(refactor|clean|reorganize|restructure)"; then
        emoji="‚ôªÔ∏è"
      elif echo "$msg" | __grep -qiE "^(doc|readme|comment)"; then
        emoji="üìù"
      elif echo "$msg" | __grep -qiE "^(release|version|bump)"; then
        emoji="üöÄ"
      else
        emoji="üóÉÔ∏è"
      fi
      echo "${emoji} ${msg} ${emoji}"
    fi
  }

  # Helper function to validate commit message format
  __validate_commit_message() {
    local msg="$1"
    # Check if message is empty
    [ -z "$msg" ] && return 1
    # Check minimum length (at least 5 chars)
    [ ${#msg} -lt 5 ] && return 1
    # Check maximum length for first line (72 chars recommended)
    [ ${#msg} -gt 150 ] && return 1
    # Reject trailing ellipsis or truncation indicators
    echo "$msg" | __grep -qE '\.\.\.$|‚Ä¶$' && return 1
    # check for API-like responses
    echo "$msg" | __grep -qiE "^(Error|API|Response|Code|Message|Status|Result|Data|{|\[)" && return 1
    # Check for common AI preamble/error patterns
    echo "$msg" | __grep -qiE "^(I |Here|Sure|Okay|Let me|I'll|I can|I would|Sorry|I apologize|As an AI|Based on|Looking at|After reviewing|The commit|This commit|For this|Given the)" && return 1
    # Check for AI meta-language about the message itself
    echo "$msg" | __grep -qiE "commit message|here's|here is|following|would be|should be|suggest|recommend" && return 1
    # Check for markdown artifacts
    echo "$msg" | __grep -qE "^\`\`\`|^#+\s|^\*\*" && return 1
    # Check it's not just the prompt echoed back
    echo "$msg" | __grep -qiE "^Generate a git commit|^First line:|^- First line:|^TITLE LINE|^Rules for|^Output ONLY" && return 1
    # Reject if it ends with a colon (incomplete response)
    echo "$msg" | __grep -qE ':$' && return 1
    return 0
  }

  # Helper function to parse AI result
  __parse_ai_result() {
    local res="$1"
    local ai_name="${2:-AI}"
    local found_valid=""
    # Check for empty result
    if [ -z "$res" ]; then
      printf_yellow "‚ö†Ô∏è  AI returned empty response"
      return 1
    fi
    # Check for rate limits and other errors in result content
    if ! __check_ai_result_for_errors "$res" "$ai_name"; then
      return 1
    fi
    # Check for obvious error responses in the result itself
    if echo "$res" | head -n1 | __grep -qiE "^(error|failed|exception|cannot|unable|invalid|unauthorized)"; then
      printf_yellow "‚ö†Ô∏è  AI returned error response"
      return 1
    fi
    # Strip common AI preamble patterns from the response
    res="$(echo "$res" | sed -E '
      s/^[Bb]ased on (the )?[^:]+:[[:space:]]*//
      s/^[Hh]ere.*(commit message|is|are)[^:]*:[[:space:]]*//
      s/^[Tt]he commit message[^:]*:[[:space:]]*//
      s/^[Ss]uggested commit[^:]*:[[:space:]]*//
      s/^[Cc]ommit message[^:]*:[[:space:]]*//
      s/^\*\*[^*]+\*\*[[:space:]]*//
    ' | sed '/^$/d')"
    # If stripping left us with empty, fail
    if [ -z "$res" ]; then
      printf_yellow "‚ö†Ô∏è  AI response was only preamble, no actual message"
      return 1
    fi
    short_msg="$(echo "$res" | head -n1)"
    # Validate the short message
    if ! __validate_commit_message "$short_msg"; then
      # Try to find a valid line in the output
      while IFS= read -r line; do
        if __validate_commit_message "$line"; then
          short_msg="$line"
          found_valid="true"
          break
        fi
      done <<<"$res"
      # If still invalid, return failure (will trigger fallback)
      if [ -z "$found_valid" ]; then
        if ! __validate_commit_message "$short_msg"; then
          printf_yellow "‚ö†Ô∏è  AI response failed validation, using fallback"
          return 1
        fi
      fi
    fi
    # Apply format fix to ensure {emoji} {text} {emoji} format
    short_msg="$(__fix_commit_format "$short_msg")"
    # Final check - make sure the fixed message is not an error
    if echo "$short_msg" | __grep -qiE "(error|failed|exception|cannot|unable)"; then
      printf_yellow "‚ö†Ô∏è  Message appears to be an error, using fallback"
      return 1
    fi
    # Validate length after fix (max 72 chars)
    if [ ${#short_msg} -gt 72 ]; then
      # Truncate text portion, keeping emoji format
      local emoji="$(__extract_first_emoji "$short_msg")"
      local text="$(echo "$short_msg" | sed 's/^[^[:alnum:]]*[[:space:]]*//;s/[[:space:]]*[^[:alnum:]]*$//')"
      local max_text_len=$((72 - ${#emoji} - ${#emoji} - 4))  # 4 for spaces
      text="${text:0:$max_text_len}"
      # Remove any trailing ellipsis from truncation
      text="${text%...}"
      text="${text%‚Ä¶}"
      text="$(echo "$text" | sed 's/[[:space:]]*$//')"
      short_msg="${emoji} ${text} ${emoji}"
    fi
    long_msg="$(echo "$res" | tail -n +2 | __grep -v '^$')"
    [ -n "$long_msg" ] && GITCOMMIT_MESSAGE_LONG="$long_msg"
    echo "$short_msg"
    return 0
  }

  # Check for user-preferred AI command
  local ai_cmd="${GITCOMMIT_DEFAULT_AI_COMMAND:-}"
  local ai_args="${GITCOMMIT_DEFAULT_AI_ARGS:-}"

  # If user specified a preferred AI command, try that first
  if [ -n "$ai_cmd" ]; then
    if ! __cmd_exists "$ai_cmd"; then
      printf_yellow "‚ö†Ô∏è  Configured AI command '$ai_cmd' not found, falling back to auto-detection"
    else
      printf_cyan "ü§ñ Using $ai_cmd to generate commit message..."
      case "$ai_cmd" in
      ollama)
        if [ -z "$ai_args" ]; then
          # Auto-detect first available model
          local ollama_model=""
          ollama_model="$(ollama list 2>/dev/null | tail -n +2 | head -n1 | awk '{print $1}')"
          if [ -z "$ollama_model" ]; then
            printf_yellow "‚ö†Ô∏è  ollama is not running or has no models, trying fallbacks..."
          else
            ai_args="run $ollama_model"
          fi
        fi
        if [ -n "$ai_args" ]; then
          error_output="$(mktemp)"
          result="$(ollama $ai_args "$prompt" 2>"$error_output" | __grep -v '^$')"
          if [ -s "$error_output" ]; then
            __check_ai_error "ollama" "$(<"$error_output")" "Ollama AI"
          fi
          rm -f "$error_output"
          if __parse_ai_result "$result"; then
            return 0
          else
            printf_yellow "‚ö†Ô∏è  ollama failed to generate message, trying fallbacks..."
          fi
        fi
        ;;
      claude)
        [ -z "$ai_args" ] && ai_args="-p --allowedTools \"\""
        error_output="$(mktemp)"
        result="$(claude $ai_args "$prompt" 2>"$error_output" | __grep -v '^$')"
        if [ -s "$error_output" ]; then
          if ! __check_ai_error "claude" "$(<"$error_output")" "Claude AI"; then
            rm -f "$error_output"
            printf_yellow "Falling back to alternative methods..."
          fi
        fi
        rm -f "$error_output"
        if __parse_ai_result "$result"; then
          return 0
        else
          printf_yellow "‚ö†Ô∏è  claude failed to generate message, trying fallbacks..."
        fi
        ;;
      codex)
        [ -z "$ai_args" ] && ai_args="exec"
        error_output="$(mktemp)"
        result="$(codex $ai_args "$prompt" 2>"$error_output" | __grep -v '^$')"
        if [ -s "$error_output" ]; then
          __check_ai_error "codex" "$(<"$error_output")" "Codex AI"
        fi
        rm -f "$error_output"
        if __parse_ai_result "$result"; then
          return 0
        else
          printf_yellow "‚ö†Ô∏è  codex failed to generate message, trying fallbacks..."
        fi
        ;;
      copilot)
        [ -z "$ai_args" ] && ai_args="-p --allow-all-tools"
        error_output="$(mktemp)"
        result="$(copilot $ai_args "$prompt" 2>"$error_output" | __grep -v '^$')"
        if [ -s "$error_output" ]; then
          __check_ai_error "copilot" "$(<"$error_output")" "GitHub Copilot"
        fi
        rm -f "$error_output"
        if __parse_ai_result "$result"; then
          return 0
        else
          printf_yellow "‚ö†Ô∏è  copilot failed to generate message, trying fallbacks..."
        fi
        ;;
      llama-cli | llama-cpp | llamafile)
        [ -z "$ai_args" ] && ai_args="-p --no-display-prompt"
        error_output="$(mktemp)"
        result="$($ai_cmd $ai_args "$prompt" 2>"$error_output" | __grep -v '^$')"
        if [ -s "$error_output" ]; then
          __check_ai_error "$ai_cmd" "$(<"$error_output")" "$(echo $ai_cmd | tr '-' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2));}1')"
        fi
        rm -f "$error_output"
        if __parse_ai_result "$result"; then
          return 0
        else
          printf_yellow "‚ö†Ô∏è  $ai_cmd failed to generate message, trying fallbacks..."
        fi
        ;;
      gpt4all-cli)
        error_output="$(mktemp)"
        result="$(gpt4all-cli ${ai_args:-} "$prompt" 2>"$error_output" | __grep -v '^$')"
        if [ -s "$error_output" ]; then
          __check_ai_error "gpt4all-cli" "$(<"$error_output")" "GPT4All"
        fi
        rm -f "$error_output"
        if __parse_ai_result "$result"; then
          return 0
        else
          printf_yellow "‚ö†Ô∏è  gpt4all-cli failed to generate message, trying fallbacks..."
        fi
        ;;
      lms)
        error_output="$(mktemp)"
        result="$(echo "$prompt" | lms ${ai_args:-chat} 2>"$error_output" | __grep -v '^$')"
        if [ -s "$error_output" ]; then
          __check_ai_error "lms" "$(<"$error_output")" "LM Studio"
        fi
        rm -f "$error_output"
        if __parse_ai_result "$result"; then
          return 0
        else
          printf_yellow "‚ö†Ô∏è  lms failed to generate message, trying fallbacks..."
        fi
        ;;
      *)
        # Generic command - user provides full args
        error_output="$(mktemp)"
        if [ -n "$ai_args" ]; then
          result="$($ai_cmd $ai_args "$prompt" 2>"$error_output" | __grep -v '^$')"
        else
          result="$(echo "$prompt" | $ai_cmd 2>"$error_output" | __grep -v '^$')"
        fi
        if [ -s "$error_output" ]; then
          __check_ai_error "$ai_cmd" "$(<"$error_output")" "$ai_cmd"
        fi
        rm -f "$error_output"
        if __parse_ai_result "$result"; then
          return 0
        else
          printf_yellow "‚ö†Ô∏è  $ai_cmd failed to generate message, trying fallbacks..."
        fi
        ;;
      esac
    fi
  fi

  # Reset rate limit flag at start
  GITCOMMIT_AI_RATE_LIMITED=""

  # Try local AI clients first (prefer local over cloud)

  # Try ollama
  if [ "$GITCOMMIT_AI_RATE_LIMITED" != "true" ] && __cmd_exists ollama; then
    local ollama_model=""
    ollama_model="$(ollama list 2>/dev/null | tail -n +2 | head -n1 | awk '{print $1}')"
    if [ -n "$ollama_model" ]; then
      error_output="$(mktemp)"
      result="$(ollama run "$ollama_model" "$prompt" 2>"$error_output" | __grep -v '^$')"
      [ -s "$error_output" ] && __check_ai_error "ollama" "$(<"$error_output")" "Ollama"
      rm -f "$error_output"
      __parse_ai_result "$result" "Ollama" && return 0
    fi
  fi

  # Try llama.cpp (llama-cli or main)
  if [ "$GITCOMMIT_AI_RATE_LIMITED" != "true" ] && __cmd_exists llama-cli; then
    error_output="$(mktemp)"
    result="$(llama-cli -p "$prompt" --no-display-prompt 2>"$error_output" | __grep -v '^$')"
    [ -s "$error_output" ] && __check_ai_error "llama-cli" "$(<"$error_output")" "Llama.cpp CLI"
    rm -f "$error_output"
    __parse_ai_result "$result" "Llama.cpp CLI" && return 0
  elif [ "$GITCOMMIT_AI_RATE_LIMITED" != "true" ] && __cmd_exists llama-cpp; then
    error_output="$(mktemp)"
    result="$(llama-cpp -p "$prompt" --no-display-prompt 2>"$error_output" | __grep -v '^$')"
    [ -s "$error_output" ] && __check_ai_error "llama-cpp" "$(<"$error_output")" "Llama.cpp"
    rm -f "$error_output"
    __parse_ai_result "$result" "Llama.cpp" && return 0
  fi

  # Try llamafile
  if [ "$GITCOMMIT_AI_RATE_LIMITED" != "true" ] && __cmd_exists llamafile; then
    error_output="$(mktemp)"
    result="$(llamafile -p "$prompt" --no-display-prompt 2>"$error_output" | __grep -v '^$')"
    [ -s "$error_output" ] && __check_ai_error "llamafile" "$(<"$error_output")" "Llamafile"
    rm -f "$error_output"
    __parse_ai_result "$result" "Llamafile" && return 0
  fi

  # Try gpt4all
  if [ "$GITCOMMIT_AI_RATE_LIMITED" != "true" ] && __cmd_exists gpt4all-cli; then
    error_output="$(mktemp)"
    result="$(gpt4all-cli "$prompt" 2>"$error_output" | __grep -v '^$')"
    [ -s "$error_output" ] && __check_ai_error "gpt4all-cli" "$(<"$error_output")" "GPT4All"
    rm -f "$error_output"
    __parse_ai_result "$result" "GPT4All" && return 0
  fi

  # Try lmstudio CLI
  if [ "$GITCOMMIT_AI_RATE_LIMITED" != "true" ] && __cmd_exists lms; then
    error_output="$(mktemp)"
    result="$(echo "$prompt" | lms chat 2>"$error_output" | __grep -v '^$')"
    [ -s "$error_output" ] && __check_ai_error "lms" "$(<"$error_output")" "LM Studio"
    rm -f "$error_output"
    __parse_ai_result "$result" "LM Studio" && return 0
  fi

  # Try cloud AI clients (skip if rate limited from local attempts)

  # Try claude CLI
  if [ "$GITCOMMIT_AI_RATE_LIMITED" != "true" ] && __cmd_exists claude; then
    error_output="$(mktemp)"
    result="$(claude -p "$prompt" --allowedTools "" 2>"$error_output" | __grep -v '^$')"
    [ -s "$error_output" ] && __check_ai_error "claude" "$(<"$error_output")" "Claude AI"
    rm -f "$error_output"
    __parse_ai_result "$result" "Claude AI" && return 0
  fi

  # Try codex CLI
  if [ "$GITCOMMIT_AI_RATE_LIMITED" != "true" ] && __cmd_exists codex; then
    error_output="$(mktemp)"
    result="$(codex exec "$prompt" 2>"$error_output" | __grep -v '^$')"
    [ -s "$error_output" ] && __check_ai_error "codex" "$(<"$error_output")" "Codex AI"
    rm -f "$error_output"
    __parse_ai_result "$result" "Codex AI" && return 0
  fi

  # Try GitHub Copilot CLI
  if [ "$GITCOMMIT_AI_RATE_LIMITED" != "true" ] && __cmd_exists copilot; then
    error_output="$(mktemp)"
    result="$(copilot -p "$prompt" --allow-all-tools 2>"$error_output" | __grep -v '^$')"
    [ -s "$error_output" ] && __check_ai_error "copilot" "$(<"$error_output")" "GitHub Copilot"
    rm -f "$error_output"
    __parse_ai_result "$result" "GitHub Copilot" && return 0
  fi

  # Try GitHub Copilot via gh extension
  if [ "$GITCOMMIT_AI_RATE_LIMITED" != "true" ] && __cmd_exists gh && gh extension list 2>/dev/null | __grep -q 'copilot'; then
    error_output="$(mktemp)"
    result="$(echo "$prompt" | gh copilot suggest -t shell 2>"$error_output" | __grep -v '^$')"
    [ -s "$error_output" ] && __check_ai_error "gh-copilot" "$(<"$error_output")" "GitHub Copilot (via gh)"
    rm -f "$error_output"
    __parse_ai_result "$result" "GitHub Copilot (via gh)" && return 0
  fi

  # Fallback to auto-generated message
  if [ "$GITCOMMIT_AI_RATE_LIMITED" = "true" ]; then
    printf_yellow "‚ö†Ô∏è  Rate limited - using auto-generated message"
  fi
  local auto_result="$(__auto_generate_message "$changed_files" "")"
  local auto_message="${auto_result%|*}"
  local auto_emoji="${auto_result#*|}"
  [ -z "$auto_emoji" ] && auto_emoji="$(__auto_detect_emoji "$changed_files")"

  GITCOMMIT_MESSAGE_LONG="$changed_files"
  echo "${auto_emoji} ${auto_message} ${auto_emoji}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__search() {
  [ -n "$1" ] || printf_exit "Usage: $APPNAME search [query] [optionalPath]"
  printf '\r%b ' "${YELLOW}Searching for $1${NC}"
  results="$(git grep -w -p --cached "$1" $2 | __grep '^')"
  printf '\n'
  [ -n "$results" ] && printf_blue "$results" || printf_exit "Your search provided not results"
  exit $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__get_random_message() {
  local random_message="$(curl -q -LSsf --max-time 3 "$GITCOMMIT_RANDOM_API_URL" 2>/dev/null || curl -q -LSsf --max-time 3 "$GITCOMMIT_RANDOM_API_BAK_URL" 2>/dev/null || false)"
  if [ -n "$random_message" ]; then
    echo "$random_message"
  else
    echo "Well I did things"
  fi
  return 0
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_repo_init() {
  __git_dir "$GITCOMMIT_ROOT_DIR"
  __gitignore_init "$GITCOMMIT_ROOT_DIR"
  [ -n "$REMOTE_REPO" ] || REMOTE_REPO="localdir"
  GITCOMMIT_ROOT_DIR="${GITCOMMIT_ROOT_DIR:-$(__git_root "$GITCOMMIT_ROOT_DIR")}"
  [ -f "$GITCOMMIT_VERSION_FILE" ] && GITCOMMIT_VERSION_CURRENT="$(<"$GITCOMMIT_VERSION_FILE")"
  [ -f "$GITCOMMIT_ROOT_DIR/.git/prev_commit_files.txt" ] || touch "$GITCOMMIT_ROOT_DIR/.git/prev_commit_files.txt"
  if [ "$GITCOMMIT_RUN_AMEND" = "true" ]; then
    [ -n "$1" ] && GITCOMMIT_AMEND_MESS="${1:-Amended commit}"
    changelog_message="$GITCOMMIT_AMEND_MESS"
    if [ -f "$GITCOMMIT_ROOT_DIR/.git/prev_commit_files.txt" ]; then
      changed_files="$(<"$GITCOMMIT_ROOT_DIR/.git/prev_commit_files.txt")"
      rm -Rf "$GITCOMMIT_ROOT_DIR/.git/prev_commit_files.txt"
    fi
    git commit --amend -m "‚ûï $GITCOMMIT_AMEND_MESS ‚ûï "
    git push --force &>/dev/null
    exit $?
  fi
  if [ ! -f "$GITCOMMIT_ROOT_DIR/.git/.init" ]; then
    if [ -f "$GITCOMMIT_ROOT_DIR/$GITCOMMIT_MAIN_CONFIG" ] && [ -d "$GITCOMMIT_ROOT_DIR/.git" ]; then
      cp -Rf "$GITCOMMIT_ROOT_DIR/$GITCOMMIT_MAIN_CONFIG" "$GITCOMMIT_ROOT_DIR/.git/config"
      touch "$GITCOMMIT_ROOT_DIR/.git/.init"
    fi
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_status() { git -C "${1:-.}" status -b -s 2>/dev/null && return 0 || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_log() {
  local dir="${1:-.}"
  local limit="${2:-}"
  local search_pattern="${3:-}"
  local exclude_patterns="${GITCOMMIT_LOG_SHOW_EXCLUDE-Version Bump:}"
  local git_cmd=""

  # Use different format when searching to show full commit body
  if [ -n "$search_pattern" ]; then
    git_cmd="git --no-pager -C '$dir' log --color=always --pretty='%C(magenta)%h%C(red)%d %C(yellow)%ar %C(green)%s %C(yellow)(%an)%n%C(white)%b' --grep='$search_pattern' -i 2>/dev/null"
  else
    git_cmd="git --no-pager -C '$dir' log --color=always --pretty='%C(magenta)%h%C(red)%d %C(yellow)%ar %C(green)%s %C(yellow)(%an)' 2>/dev/null"
  fi

  # Add limit if specified
  if [ -n "$limit" ] && [ "$limit" -gt 0 ] 2>/dev/null; then
    git_cmd="$git_cmd --max-count='$limit'"
  fi

  # Apply exclusion filter if patterns specified, then search filter
  if [ -n "$exclude_patterns" ]; then
    local grep_pattern=$(echo "$exclude_patterns" | sed 's/[[:space:]]*|[[:space:]]*/|/g')
    if [ -n "$search_pattern" ]; then
      eval "$git_cmd" | __grep --line-buffered -vE "$grep_pattern" | __grep --line-buffered --color=always -iE "$search_pattern|$"
    else
      eval "$git_cmd" | __grep --line-buffered -vE "$grep_pattern"
    fi
    return $?
  else
    if [ -n "$search_pattern" ]; then
      eval "$git_cmd" | __grep --line-buffered --color=always -iE "$search_pattern|$"
    else
      eval "$git_cmd"
    fi
    return $?
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_show_commit() {
  local dir="${1:-.}"
  local commit="${2:-}"

  # If no commit specified, get most recent commit excluding configured patterns
  if [ -z "$commit" ]; then
    local exclude_patterns="${GITCOMMIT_LOG_SHOW_EXCLUDE:-Version Bump:}"
    local grep_exclude=""

    # Build grep exclusion string from patterns (separated by |)
    if [ -n "$exclude_patterns" ]; then
      # Convert space-separated or pipe-separated patterns to grep -v format
      local IFS='|'
      for pattern in $exclude_patterns; do
        [ -n "$grep_exclude" ] && grep_exclude="$grep_exclude|" || true
        grep_exclude="${grep_exclude}${pattern}"
      done

      # Get first commit that doesn't match exclusion patterns
      if [ -n "$grep_exclude" ]; then
        commit="$(git -C "$dir" log --pretty='%H %s' 2>/dev/null | __grep -vE "$grep_exclude" | head -n1 | awk '{print $1}')"
      else
        commit="$(git -C "$dir" log --pretty='%H' 2>/dev/null | head -n1)"
      fi
    else
      # No exclusions, get most recent
      commit="$(git -C "$dir" log --pretty='%H' 2>/dev/null | head -n1)"
    fi
  fi

  if [ -z "$commit" ]; then
    printf_red "No commits found"
    return 1
  fi

  # Show the full commit details
  git -C "$dir" --no-pager show --stat --patch "$commit" 2>/dev/null
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__is_clean() { __git_status "$1" | __grep -v '##' | __grep -q '^' && return 1 || return 0; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__is_dirty() { __git_status "$1" | __grep -v '##' | __grep -q '^' && return 0 || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_remote_push() {
  git -C "${1:-${GITCOMMIT_ROOT_DIR:-.}}" remote -v 2>/dev/null | __grep 'push' | __grep -E 'http://|https://|git://|ssh://' | head -n 1 | awk '{print $2}' 2>/dev/null | __grep '^' || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__github_create_repo() {
  if echo "$1" | __grep -q '/'; then
    git_user="$(echo "$1" | awk -F '/' '{print $(NF-1)}')"
    git_repo="$(echo "$1" | awk -F '/' '{print $NF}')"
  elif [ $# -eq 2 ]; then
    git_user="$1"
    git_repo="$2"
  else
    return 1
  fi
  __cmd_exists gitadmin || return 1
  __github_api_repo_verify "$git_user" "$git_repo" || gitadmin create "$git_user" "$git_repo" | __grep -qi 'Success:'
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__github_api_repo_verify() {
  curl -q -LSsf -X GET -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${GITCOMMIT_GITHUB_TOKEN}" "https://api.github.com/repos/${1}/${2}" 2>/dev/null | jq -r '.html_url' 2>/dev/null | __grep -qF "${1}/${2}" &>/dev/null
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_fix_last() {
  local repo_dir="${1:-$GITCOMMIT_ROOT_DIR}"

  printf_cyan "Fixing last commit by adding current changes..."

  local version_bump_count=0
  local commit_hash=""
  local commit_msg=""

  while IFS= read -r line; do
    commit_hash=$(echo "$line" | awk '{print $1}')
    commit_msg=$(echo "$line" | cut -d' ' -f2-)

    if echo "$commit_msg" | __grep -qE "^üöÄ Version Bump:|Version Bump:"; then
      version_bump_count=$((version_bump_count + 1))
    else
      break
    fi
  done < <(git -C "$repo_dir" log --oneline -10 2>/dev/null)

  if [ -z "$commit_hash" ]; then
    printf_red "Could not find any commits"
    return 1
  fi

  if [ "$version_bump_count" -gt 0 ]; then
    printf_yellow "Removing $version_bump_count version bump commit(s)..."
    git -C "$repo_dir" reset --soft HEAD~${version_bump_count} || return 1
  fi

  printf_cyan "Last real commit: $commit_msg"
  printf_cyan "Amending with current changes..."

  if ! git -C "$repo_dir" diff --cached --quiet; then
    git -C "$repo_dir" commit --amend --no-edit
  elif ! git -C "$repo_dir" diff --quiet; then
    git -C "$repo_dir" add -u
    git -C "$repo_dir" commit --amend --no-edit
  else
    printf_yellow "No changes to add"
    return 1
  fi

  if [ $? -eq 0 ]; then
    printf_green "Successfully amended last commit: $commit_msg"
    return 0
  else
    printf_red "Failed to amend commit"
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_squash() {
  local num_commits="${1:-2}"
  local new_message="$2"
  local repo_dir="${3:-$GITCOMMIT_ROOT_DIR}"

  if ! [[ "$num_commits" =~ ^[0-9]+$ ]] || [ "$num_commits" -lt 2 ]; then
    printf_red "Number of commits must be 2 or greater"
    return 1
  fi

  local total_commits=$(git -C "$repo_dir" rev-list --count HEAD 2>/dev/null)
  if [ "$num_commits" -gt "$total_commits" ]; then
    printf_red "Cannot squash $num_commits commits (only $total_commits commits exist)"
    return 1
  fi

  printf_cyan "Squashing last $num_commits commits..."

  if [ -n "$new_message" ]; then
    GIT_SEQUENCE_EDITOR="sed -i -e '2,${num_commits}s/^pick/squash/'" git -C "$repo_dir" rebase -i HEAD~${num_commits} && \
    git -C "$repo_dir" commit --amend -m "$new_message"
  else
    GIT_SEQUENCE_EDITOR="sed -i -e '2,${num_commits}s/^pick/squash/'" git -C "$repo_dir" rebase -i HEAD~${num_commits}
  fi

  if [ $? -eq 0 ]; then
    printf_green "Successfully squashed $num_commits commits"
    return 0
  else
    printf_red "Failed to squash commits"
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined variables/import external variables

# - - - - - - - - - - - - - - - - - - - - - - - - -
# Application Folders
GITCOMMIT_CONFIG_FILE="${GITCOMMIT_CONFIG_FILE:-settings.conf}"
GITCOMMIT_CONFIG_DIR="${GITCOMMIT_CONFIG_DIR:-$HOME/.config/myscripts/gitcommit}"
GITCOMMIT_CONFIG_BACKUP_DIR="${GITCOMMIT_CONFIG_BACKUP_DIR:-$HOME/.local/share/myscripts/gitcommit/backups}"
GITCOMMIT_LOG_DIR="${GITCOMMIT_LOG_DIR:-$HOME/.local/log/gitcommit}"
GITCOMMIT_TEMP_DIR="${GITCOMMIT_TEMP_DIR:-$HOME/.local/tmp/system_scripts/gitcommit}"
GITCOMMIT_CACHE_DIR="${GITCOMMIT_CACHE_DIR:-$HOME/.cache/gitcommit}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
GITCOMMIT_OUTPUT_COLOR_1="${GITCOMMIT_OUTPUT_COLOR_1:-33}"
GITCOMMIT_OUTPUT_COLOR_2="${GITCOMMIT_OUTPUT_COLOR_2:-5}"
GITCOMMIT_OUTPUT_COLOR_GOOD="${GITCOMMIT_OUTPUT_COLOR_GOOD:-2}"
GITCOMMIT_OUTPUT_COLOR_ERROR="${GITCOMMIT_OUTPUT_COLOR_ERROR:-1}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
GITCOMMIT_NOTIFY_ENABLED="${GITCOMMIT_NOTIFY_ENABLED:-yes}"
GITCOMMIT_GOOD_NAME="${GITCOMMIT_GOOD_NAME:-Great:}"
GITCOMMIT_ERROR_NAME="${GITCOMMIT_ERROR_NAME:-Error:}"
GITCOMMIT_GOOD_MESSAGE="${GITCOMMIT_GOOD_MESSAGE:-No errors reported}"
GITCOMMIT_ERROR_MESSAGE="${GITCOMMIT_ERROR_MESSAGE:-Errors were reported}"
GITCOMMIT_NOTIFY_CLIENT_NAME="${GITCOMMIT_NOTIFY_CLIENT_NAME:-$APPNAME}"
GITCOMMIT_NOTIFY_CLIENT_ICON="${GITCOMMIT_NOTIFY_CLIENT_ICON:-notification-new}"
GITCOMMIT_NOTIFY_CLIENT_URGENCY="${GITCOMMIT_NOTIFY_CLIENT_URGENCY:-normal}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional Variables
GITCOMMIT_NO_CONFIRM="${GITCOMMIT_NO_CONFIRM:-true}"
GITCOMMIT_PROJECT_DIR="${GIT_PROJECT_DIR:-$HOME/Projects}"
GITCOMMIT_VERSION_FILE="${GIT_VERSION_FILE:-version.txt}"
GITCOMMIT_MAIN_CONFIG="${GITCOMMIT_MAIN_CONFIG:-gitmainconfig}"
GITCOMMIT_VERSION_FORMAT="${VERSION_DATE_FORMAT:-%Y%m%d%H%M-git}"
GITCOMMIT_RELEASE_FORMAT="${GITCOMMIT_RELEASE_FORMAT:-%Y.%m.%d}"
GITCOMMIT_ERROR_LOG="${GITCOMMIT_ERROR_LOG:-$GITCOMMIT_LOG_DIR/error.log}"
GITCOMMIT_RANDOM_API_URL="${GITCOMMIT_RANDOM_API_URL:-https://api.casjay.vercel.app/api/v1/commit}"
GITCOMMIT_RANDOM_API_BAK_URL="${GITCOMMIT_RANDOM_API_BAK_URL:-https://commitment-6jyr.onrender.com/txt}"
GITCOMMIT_GITHUB_TOKEN="${GITCOMMIT_GITHUB_TOKEN:-$GITHUB_ACCESS_TOKEN}"
GITCOMMIT_SILENT="${GITCOMMIT_SILENT:-true}"
GITCOMMIT_CHANGELOG_FILE_NAME="${GITCOMMIT_CHANGELOG_FILE_NAME:-CHANGELOG.md}"
GITCOMMIT_CHANGELOG_ICON="${GITCOMMIT_CHANGELOG_ICON:-üöÄ}"
GITCOMMIT_DEFAULT_COMMIT_FILE="${GITCOMMIT_DEFAULT_COMMIT_FILE:-.git/COMMIT_MESS}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Generate config files
[ -f "$GITCOMMIT_CONFIG_DIR/$GITCOMMIT_CONFIG_FILE" ] || [ "$*" = "--config" ] || INIT_CONFIG="${INIT_CONFIG:-TRUE}" __gen_config ${SETARGS:-$@}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Import config
[ -f "$GITCOMMIT_CONFIG_DIR/$GITCOMMIT_CONFIG_FILE" ] && . "$GITCOMMIT_CONFIG_DIR/$GITCOMMIT_CONFIG_FILE"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Ensure Directories exist
[ -d "$GITCOMMIT_LOG_DIR" ] || mkdir -p "$GITCOMMIT_LOG_DIR" |& __devnull
[ -d "$GITCOMMIT_TEMP_DIR" ] || mkdir -p "$GITCOMMIT_TEMP_DIR" |& __devnull
[ -d "$GITCOMMIT_CACHE_DIR" ] || mkdir -p "$GITCOMMIT_CACHE_DIR" |& __devnull
# - - - - - - - - - - - - - - - - - - - - - - - - -
GITCOMMIT_TEMP_FILE="${GITCOMMIT_TEMP_FILE:-$(mktemp $GITCOMMIT_TEMP_DIR/XXXXXX 2>/dev/null)}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup trap to remove temp file
trap '__trap_exit' EXIT
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup notification function
__notifications() {
  __cmd_exists notifications || return
  [ "$GITCOMMIT_NOTIFY_ENABLED" = "yes" ] || return
  [ "$SEND_NOTIFICATION" = "no" ] && return
  (
    export SCRIPT_OPTS="" _DEBUG=""
    export NOTIFY_GOOD_MESSAGE="${NOTIFY_GOOD_MESSAGE:-$GITCOMMIT_GOOD_MESSAGE}"
    export NOTIFY_ERROR_MESSAGE="${NOTIFY_ERROR_MESSAGE:-$GITCOMMIT_ERROR_MESSAGE}"
    export NOTIFY_CLIENT_ICON="${NOTIFY_CLIENT_ICON:-$GITCOMMIT_NOTIFY_CLIENT_ICON}"
    export NOTIFY_CLIENT_NAME="${NOTIFY_CLIENT_NAME:-$GITCOMMIT_NOTIFY_CLIENT_NAME}"
    export NOTIFY_CLIENT_URGENCY="${NOTIFY_CLIENT_URGENCY:-$GITCOMMIT_NOTIFY_CLIENT_URGENCY}"
    notifications "$@"
  ) |& __devnull &
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set custom actions
GITCOMMIT_GITHUB_TOKEN="${GITCOMMIT_GITHUB_TOKEN:-$GITHUB_ACCESS_TOKEN}"

# - - - - - - - - - - - - - - - - - - - - - - - - -
# Argument/Option settings
SETARGS=("$@")
# - - - - - - - - - - - - - - - - - - - - - - - - -
SHORTOPTS=""
SHORTOPTS+=""
# - - - - - - - - - - - - - - - - - - - - - - - - -
LONGOPTS="completions:,config,debug,dir:,help,options,raw,version,silent"
LONGOPTS+=",mess:,message:,amend,force,all"
# - - - - - - - - - - - - - - - - - - - - - - - - -
ARRAY="all amend is status log reset branch push init "
ARRAY+="search version files modified updated deleted added renamed changed new "
ARRAY+="improved fixed release deploy docs test breaking refactor performance permissions "
ARRAY+="bugs docker node ruby php perl python scratchpad todo notes blog recipe "
ARRAY+="emojify random notes blog emojify random custom tag tar spelling "
ARRAY+=""
# - - - - - - - - - - - - - - - - - - - - - - - - -
LIST=""
LIST+=""
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup application options
setopts=$(getopt -o "$SHORTOPTS" --long "$LONGOPTS" -n "$APPNAME" -- "$@" 2>/dev/null)
eval set -- "${setopts[@]}" 2>/dev/null
while :; do
  case "$1" in
  --raw)
    shift 1
    export SHOW_RAW="true"
    NC=""
    RESET=""
    BLACK=""
    RED=""
    GREEN=""
    YELLOW=""
    BLUE=""
    PURPLE=""
    CYAN=""
    WHITE=""
    ORANGE=""
    LIGHTRED=""
    BG_GREEN=""
    BG_RED=""
    ICON_INFO="[ info ]"
    ICON_GOOD="[ ok ]"
    ICON_WARN="[ warn ]"
    ICON_ERROR="[ error ]"
    ICON_QUESTION="[ ? ]"
    printf_column() { tee | __grep '^'; }
    printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
    ;;
  --debug)
    shift 1
    set -xo pipefail
    export SCRIPT_OPTS="--debug"
    export _DEBUG="on"
    __devnull() { tee || return 1; }
    __devnull2() { eval "$@" |& tee -p || return 1; }
    ;;
  --completions)
    if [ "$2" = "short" ]; then
      printf '%s\n' "-$SHORTOPTS" | sed 's|"||g;s|:||g;s|,|,-|g' | tr ',' '\n'
    elif [ "$2" = "long" ]; then
      printf '%s\n' "--$LONGOPTS" | sed 's|"||g;s|:||g;s|,|,--|g' | tr ',' '\n'
    elif [ "$2" = "array" ]; then
      printf '%s\n' "$ARRAY" | sed 's|"||g;s|:||g' | tr ',' '\n'
    elif [ "$2" = "list" ]; then
      printf '%s\n' "$LIST" | sed 's|"||g;s|:||g' | tr ',' '\n'
    else
      exit 1
    fi
    shift 2
    exit $?
    ;;
  --options)
    shift 1
    printf_blue "Current options for ${PROG:-$APPNAME}"
    [ -z "$SHORTOPTS" ] || __list_options "Short Options" "-${SHORTOPTS}" ',' '-' 4
    [ -z "$LONGOPTS" ] || __list_options "Long Options" "--${LONGOPTS}" ',' '--' 4
    [ -z "$ARRAY" ] || __list_options "Base Options" "${ARRAY}" ',' '' 4
    [ -z "$LIST" ] || __list_options "LIST Options" "${LIST}" ',' '' 4
    exit $?
    ;;
  --version)
    shift 1
    __version
    exit $?
    ;;
  --help)
    shift 1
    __help
    exit $?
    ;;
  --config)
    shift 1
    __gen_config
    exit $?
    ;;
  --silent)
    shift 1
    GITCOMMIT_SILENT="true"
    ;;
  --dir)
    CWD_IS_SET="TRUE"
    GITCOMMIT_CWD="$2"
    [ -d "$GITCOMMIT_CWD" ] || mkdir -p "$GITCOMMIT_CWD" |& __devnull
    shift 2
    ;;
  -m | --mess | --message)
    shift 1
    GITCOMMIT_MESSAGE_SHORT="$2"
    shift 1
    ;;
  --amend)
    shift 1
    GITCOMMIT_RUN_AMEND="true"
    ;;
  --force)
    FORCE_PUSH="true"
    shift 1
    ;;
  --all)
    shift 1
    GITCOMMIT_EVERYTHING="true"
    ;;
  --)
    shift 1
    break
    ;;
  esac
done
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Get directory from args
# set -- "$@"
# for arg in "$@"; do
# if [ -d "$arg" ]; then
# GITCOMMIT_CWD="$arg" && shift 1 && SET_NEW_ARGS=("$@") && break
# elif [ -f "$arg" ]; then
# GITCOMMIT_CWD="$(dirname "$arg" 2>/dev/null)" && shift 1 && SET_NEW_ARGS=("$@") && break
# else
# SET_NEW_ARGS+=("$arg")
# fi
# done
# set -- "${SET_NEW_ARGS[@]}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set directory to first argument
[ -d "$1" ] && __is_an_option "$1" && GITCOMMIT_CWD="$1" && shift 1 || GITCOMMIT_CWD="${GITCOMMIT_CWD:-$PWD}"
GITCOMMIT_CWD="$(realpath "${GITCOMMIT_CWD:-$PWD}" 2>/dev/null)"
if [ -d "$GITCOMMIT_CWD" ] && cd "$GITCOMMIT_CWD"; then
  true
# if [ "$GITCOMMIT_SILENT" != "true" ] && [ "$CWD_SILENCE" != "true" ]; then
# printf_cyan "Setting working dir to $GITCOMMIT_CWD"
# fi
else
  printf_exit "üíî $GITCOMMIT_CWD does not exist üíî"
fi
export GITCOMMIT_CWD
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set actions based on variables

# - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for required applications/Network check
#requiresudo "$0" "$@" || exit 2     # exit 2 if errors
#cmd_exists --error --ask bash || exit 3 # exit 3 if not found
#am_i_online --error || exit 4           # exit 4 if no internet
# - - - - - - - - - - - - - - - - - - - - - - - - -
# APP Variables overrides
GITCOMMIT_RAN=""
GITCOMMIT_CWD="${GITCOMMIT_CWD:-$PWD}"
GITCOMMIT_ROOT_DIR="$(__git_root "$GITCOMMIT_CWD" || echo "$GITCOMMIT_CWD")"
# Check for git lock file before proceeding
__git_check_lock "$GITCOMMIT_ROOT_DIR" || exit 5
REMOTE_REPO="$(__git_remote_fetch "$GITCOMMIT_ROOT_DIR" 2>/dev/null || echo "localdir")"
BASE_DIR="$(basename $GITCOMMIT_ROOT_DIR)"
GIT_USERNAME="$(basename -- "$(dirname "$GITCOMMIT_ROOT_DIR")")"
GIT_VERSION="$GITCOMMIT_VERSION_FORMAT"
GIT_PROJECT_DIR="$GITCOMMIT_PROJECT_DIR"
GITADMIN_NO_ERROR="true"
GITADMIN_NO_ERROR_MESSAGE=""
# Check for commit message files in priority order: COMMIT_MSG first, then COMMIT_MESS
if [ -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MSG" ] && [ -s "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MSG" ]; then
  GITCOMMIT_MESSAGE_FILE="$GITCOMMIT_ROOT_DIR/.git/COMMIT_MSG"
elif [ -f "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MESS" ] && [ -s "$GITCOMMIT_ROOT_DIR/.git/COMMIT_MESS" ]; then
  GITCOMMIT_MESSAGE_FILE="$GITCOMMIT_ROOT_DIR/.git/COMMIT_MESS"
else
  GITCOMMIT_MESSAGE_FILE="$GITCOMMIT_ROOT_DIR/$GITCOMMIT_DEFAULT_COMMIT_FILE"
fi
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions based on env

# - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute functions
__parse_commit_mess_file "$GITCOMMIT_MESSAGE_FILE"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute commands
if [ ! -L "$GITCOMMIT_ROOT_DIR/.git/config" ] && [ -f "$GITCOMMIT_ROOT_DIR/$GITCOMMIT_MAIN_CONFIG" ]; then
  rm -Rf "$GITCOMMIT_ROOT_DIR/.git/config"
  ln -sf "../$GITCOMMIT_MAIN_CONFIG" "$GITCOMMIT_ROOT_DIR/.git/config"
fi
# - - - - - - - - - - - - - - - - - - - - - - - - -
# begin main app
case "$1" in
amend)
  shift 1
  GITCOMMIT_AMEND="true"
  ;;
esac

case "$1" in
s | status)
  shift 1
  __git_status "$GITCOMMIT_ROOT_DIR"
  exit $?
  ;;

l | log)
  shift 1
  case "$1" in
  show)
    shift 1
    __git_show_commit "$GITCOMMIT_ROOT_DIR" "${1:-}"
    exit $?
    ;;
  search)
    shift 1
    __git_log "$GITCOMMIT_ROOT_DIR" "" "${1:-}"
    exit $?
    ;;
  *)
    # First arg can be limit (number) or search pattern (string)
    if [ -n "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null; then
      # It's a number (limit)
      __git_log "$GITCOMMIT_ROOT_DIR" "$1" "${2:-}"
    else
      # It's a search pattern (or empty)
      __git_log "$GITCOMMIT_ROOT_DIR" "" "${1:-}"
    fi
    exit $?
    ;;
  esac
  ;;

# repo status is? clean,dirty
is)
  shift 1
  case "$1" in
  # returns 1 if repo changed
  clean)
    shift 1
    __is_clean "${1:-$GITCOMMIT_ROOT_DIR}"
    exit $?
    ;;
    # returns 0 if repo changed
  dirty)
    shift 1
    __is_dirty "${1:-$GITCOMMIT_ROOT_DIR}"
    exit $?
    ;;
    # same as clean
  *)
    __is_clean "${1:-$GITCOMMIT_ROOT_DIR}"
    exit $?
    ;;
  esac
  ;;

search)
  shift 1
  __search "$1" "$2"
  ;;

init)
  shift 1
  set_action="üè†"
  set_icon="üè†"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT:-Initial commit}"
  __git_init "${GITCOMMIT_MESSAGE_SHORT:-}"
  ;;

setup)
  shift 1
  if [ "$1" = "all" ]; then
    shift 1
    GITCOMMIT_CWD="${1:-${GITCOMMIT_CWD:-$PWD}}"
    repos="$(ls -A "$GITCOMMIT_CWD" | sort -ru)"
    for repo in $repos; do
      if [ -d "$GITCOMMIT_CWD/$repo/.git" ]; then
        gitadmin --dir "$GITCOMMIT_CWD/$repo" setup --automated
      fi
    done
  elif [ "$1" = "org" ]; then
    shift 1
    GITCOMMIT_CWD="${1:-${GITCOMMIT_CWD:-$PWD}}"
    repos="$(ls -A "$GITCOMMIT_CWD" | sort -ru)"
    for repo in $repos; do
      if [ -d "$GITCOMMIT_CWD/$repo/.git" ]; then
        gitadmin --dir "$GITCOMMIT_CWD/$repo" setup --automated
      fi
    done
  else
    gitadmin --dir "$GITCOMMIT_CWD" setup "$@"
  fi
  exit $?
  ;;

reset)
  shift 1
  printf_read_question "3" "Should I reset? [y/n]" "1" "git_reset"
  if printf_answer_yes "$git_reset"; then
    __git_repo "$GITCOMMIT_ROOT_DIR" reset --hard
  else
    printf_return "Not resetting: user aborted"
  fi
  exit $?
  ;;

tag)
  shift 1
  case "$1" in
  version)
    shift 1
    [ $# -ne 0 ] || printf_exit "$APPNAME tag version [version] [message]"
    __git_release_version "$@"
    exit $?
    ;;
  add)
    shift 1
    [ $# -ne 0 ] || printf_exit "$APPNAME tag add [tag] [message]"
    if __git_tag_add "$@"; then
      printf_blue "Tag has been added to your project"
    else
      printf_return "Failed to add the to your project"
    fi
    exit
    ;;
  remove)
    shift 1
    [ $# -ne 0 ] || printf_exit "$APPNAME tag remove [tag]"
    if __git_tag_del "$@"; then
      printf_green "The tag has been deleted from your project"
    else
      printf_return "Failed to delete the tag from your project"
    fi
    exit
    ;;
  esac
  ;;

tar)
  shift 1
  __tar_release "$@"
  ;;

branch)
  shift 1
  __rename_branch "${1:-master}" "${2:-main}" $3 $4
  exit $?
  ;;

pull)
  shift 1
  __git_custom_pull "$GITCOMMIT_ROOT_DIR"
  exit $?
  ;;

push)
  shift 1
  __git_custom_push "$GITCOMMIT_ROOT_DIR"
  exit $?
  ;;

merge)
  shift 1
  if [ "$1" = "help" ]; then
    printf_exit "Usage: $APPNAME merge <source_branch> [strategy] [message]\n\nStrategies:\n  auto   - Auto-detect: fast-forward if possible, otherwise merge commit (default)\n  ff     - Fast-forward only (fails if not possible)\n  no-ff  - Always create merge commit (even if fast-forward possible)\n  squash - Squash all commits into one\n\nExamples:\n  $APPNAME merge feature-branch\n  $APPNAME merge develop ff\n  $APPNAME merge hotfix no-ff \"Emergency fix\"\n  $APPNAME merge feature squash \"Combined feature commits\""
  fi
  source_branch="$1"
  strategy="${2:-auto}"
  shift 2 2>/dev/null || shift 1 2>/dev/null || true
  message="$*"
  __git_smart_merge "$source_branch" "$strategy" "$message"
  exit $?
  ;;

merge-resolve)
  shift 1
  action="${1:-status}"
  shift 1 2>/dev/null || true
  __git_merge_resolve "$action" "$@"
  exit $?
  ;;

version)
  shift 1
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  __write_version
  __set_version --force
  __run_push "$GITCOMMIT_ROOT_DIR" --automated
  exit $?
  ;;

ai)
  shift 1
  printf_cyan "Generating commit message using AI... Please wait."
  GITCOMMIT_MESSAGE_SHORT="$(__ai_commit_message "$*")"
  GITCOMMIT_MESSAGE_FROM_FILE="true"
  export GITCOMMIT_MESSAGE_SHORT GITCOMMIT_MESSAGE_FROM_FILE
  repo_has_changed="$(__changed_files all)"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __commit_custom "."
  ;;

all)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME all [message]"
  set_action="üóÉÔ∏è"
  set_icon="üóÉÔ∏è"
  changelog_message="All"
  GITCOMMIT_MESSAGE_SHORT="${*:-${GITCOMMIT_MESSAGE_SHORT:-Committing everything that changed}}"
  repo_has_changed="$(__changed_files message)"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __commit_custom "."
  ;;

restored)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME restored [message]"
  set_action="üóÉÔ∏è"
  set_icon="üóÉÔ∏è"
  prepend_name="Restored"
  GITCOMMIT_MESSAGE_SHORT="${*:-${GITCOMMIT_MESSAGE_SHORT:-Committing restored files}}"
  repo_has_changed="$(__changed_files all)"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __commit_custom "."
  ;;

files)
  shift
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME files"
  set_action="üóÉÔ∏è"
  set_icon="üóÉÔ∏è"
  changelog_message="File"
  GITCOMMIT_MESSAGE_SHORT="${*:-${GITCOMMIT_MESSAGE_SHORT:-Committing all file changes}}"
  repo_has_changed="$(__changed_files deleted added modified)"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_del "$(printf '%b\n' "$GITCOMMIT_MESSAGE_SHORT")" || exitCode=$((${exitCode:-0} + 1))
  __git_add "$(printf '%b\n' "$GITCOMMIT_MESSAGE_SHORT")" || exitCode=$((${exitCode:-0} + 1))
  __git_mod "$(printf '%b\n' "$GITCOMMIT_MESSAGE_SHORT")" || exitCode=$((${exitCode:-0} + 1))
  __run_push
  exit ${exitCode:-0}
  ;;

modified)
  shift
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME modified"
  set_action="üóÉÔ∏è"
  set_icon="üóÉÔ∏è"
  prepend_name="Modified"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_mod "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

updated)
  shift
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME updated"
  set_action="üìÅ"
  set_icon="üìÅ"
  prepend_name="Updated"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_updated "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

deleted)
  shift
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME deleted"
  set_action="‚ûñ"
  set_icon="‚ûñ"
  prepend_name="Deleted"
  repo_has_changed="$(__changed_files deleted)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been deleted üòø"
  __git_del "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

added)
  shift
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME added"
  set_action="‚ûï"
  set_icon="‚ûï"
  prepend_name="Added"
  repo_has_changed="$(__changed_files added)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been added üòø"
  __git_add "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

renamed)
  shift 1
  [ $# -ne 2 ] && printf_exit "Usage: $APPNAME renamed oldfile newfile"
  set_action="‚úîÔ∏è"
  set_icon="‚úîÔ∏è"
  prepend_name="Renamed"
  repo_has_changed="$(__changed_files renamed)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || [ $# -eq 2 ] || printf_exit "üòø No files have been renamed üòø"
  __git_renamed "$1" "$2" "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

changed)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME changed filename[s]"
  set_action="‚úîÔ∏è"
  set_icon="‚úîÔ∏è"
  prepend_name="Changed"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been changed üòø"
  __git_mod "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

spelling)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME changed filename[s]"
  set_action="‚öîÔ∏è"
  set_icon="‚öîÔ∏è"
  prepend_name="Fixed spelling"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_mod "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

new)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME new filename[s]"
  set_action="üÜï"
  set_icon="üÜï"
  prepend_name="New"
  repo_has_changed="$(__changed_files added)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been added üòø"
  __git_add "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

improved)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME improved filename[s]"
  set_action="üëå"
  set_icon="üëå"
  prepend_name="IMPROVE"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been improved üòø"
  __git_mod "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

fixed | fixes)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME fixed filename[s]"
  set_action="‚úîÔ∏è"
  set_icon="‚úîÔ∏è"
  prepend_name="FIXED"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_mod "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

release)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME release filename[s]"
  set_action="üöÄ"
  set_icon="üöÄ"
  prepend_name="RELEASE"
  repo_has_changed="$(__changed_files deleted added modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been changed üòø"
  __set_version
  __default_git_action "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

deploy)
  shift
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME deploy"
  set_action="üìÉ"
  set_icon="üìÉ"
  prepend_name="Deployed"
  repo_has_changed="$(__changed_files all)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __write_version
  __default_git_action "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

docs)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME docs filename[s]"
  set_action="üìñ"
  set_icon="üìñ"
  prepend_name="Docs"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_updated "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

test)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME test filename[s]"
  set_action="ü§ñ"
  set_icon="ü§ñ"
  prepend_name="TEST"
  repo_has_changed="$(__changed_files all)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __default_git_action "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

breaking)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME breaking filename[s]"
  set_action="‚öíÔ∏è"
  set_icon="‚öíÔ∏è"
  prepend_name="BREAKING"
  repo_has_changed="$(__changed_files all)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __default_git_action "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

refactor)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME refactor filename[s]"
  set_action="„Ä∞Ô∏è"
  set_icon="„Ä∞Ô∏è"
  prepend_name="Refactor Code"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_updated "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

performance)
  shift 1
  [ "$1" = "help" ] && printf_exit "Usage: $APPNAME performance filename[s]"
  set_action="üö§"
  set_icon="üö§"
  prepend_name="Performance boost"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_updated "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

permission | permissions)
  shift 1
  set_action="‚ùó"
  set_icon="‚ùó"
  prepend_name="Fixed Permissions"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_updated "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

bug | bugs)
  shift 1
  set_action="üêõ"
  set_icon="üêõ"
  prepend_name="Bug Fixes"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_updated "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

alot)
  shift 1
  set_action="üè†"
  set_icon="üè†"
  prepend_name="Fixes and Updates"
  repo_has_changed="$(__changed_files all)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __default_git_action "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

docker)
  shift 1
  set_action="‚ùá"
  set_icon="‚ùá"
  prepend_name="Added Docker Workflow"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_updated "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

node)
  shift 1
  set_action="ü¶à"
  set_icon="ü¶à"
  prepend_name="Added nodejs Workflow"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_updated "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

ruby)
  shift 1
  set_action="üêú"
  set_icon="üêú"
  prepend_name="Added ruby Workflow"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_updated "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

php)
  shift 1
  set_action="ü¶à"
  set_icon="ü¶à"
  prepend_name="Added php Workflow"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_updated "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

perl)
  shift 1
  set_action="ü¶à"
  set_icon="ü¶à"
  prepend_name="Added perl Workflow"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_updated "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

python)
  shift 1
  set_action="ü¶à"
  set_icon="ü¶à"
  prepend_name="Added python Workflow"
  repo_has_changed="$(__changed_files modified)"
  GITCOMMIT_MESSAGE_SHORT="${*:-$GITCOMMIT_MESSAGE_SHORT}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __git_updated "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

scratchpad)
  shift 1
  set_action="üìì"
  set_icon="üìì"
  prepend_name="Scratchpad"
  repo_has_changed="$(__changed_files all)"
  GITCOMMIT_MESSAGE_SHORT="${*:-${GITCOMMIT_MESSAGE_SHORT:-Modified my scratchpad}}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __default_git_action --add-all-files "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

todo)
  shift 1
  set_action="üìì"
  set_icon="üìì"
  prepend_name="TODO"
  repo_has_changed="$(__changed_files all)"
  GITCOMMIT_MESSAGE_SHORT="${*:-${GITCOMMIT_MESSAGE_SHORT:-Modified my todo list}}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __default_git_action --add-all-files "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

notes)
  shift 1
  set_action="üìì"
  set_icon="üìì"
  prepend_name="Notes"
  repo_has_changed="$(__changed_files all)"
  GITCOMMIT_MESSAGE_SHORT="${*:-${GITCOMMIT_MESSAGE_SHORT:-Modified my notes}}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __default_git_action --add-all-files "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

blog)
  shift 1
  set_action="üêú"
  set_icon="üêú"
  prepend_name="Blog"
  repo_has_changed="$(__changed_files all)"
  GITCOMMIT_MESSAGE_SHORT="${*:-${GITCOMMIT_MESSAGE_SHORT:-New post}}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __default_git_action "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

recipe)
  shift 1
  set_action="üçï"
  set_icon="üçï"
  prepend_name="Recipes"
  repo_has_changed="$(__changed_files all)"
  GITCOMMIT_MESSAGE_SHORT="${*:-${GITCOMMIT_MESSAGE_SHORT:-Updated my recipes}}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __default_git_action "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

random)
  shift 1
  set_action="‚¨ÖÔ∏è"
  set_icon="‚¨ÖÔ∏è"
  prepend_name="Random"
  set_message="$(__get_random_message)"
  repo_has_changed="$(__changed_files all)"
  GITCOMMIT_MESSAGE_SHORT="${*:-${GITCOMMIT_MESSAGE_SHORT:-$set_message}}"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __default_git_action "--add-all-files" "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

emj | emojy | emojify)
  shift 1
  set_action="${setemj:-üêú}"
  set_icon="${setemj:-üêú}"
  repo_has_changed="$(__changed_files all)"
  GITCOMMIT_MESSAGE_SHORT="$(printf '%b\n' "${*:-$GITCOMMIT_MESSAGE_SHORT}" | __emj_check)"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  __cmd_exists emojify && setemj="$(emojify "$(printf '%b\n' "$GITCOMMIT_MESSAGE_SHORT")")"
  __default_git_action "$GITCOMMIT_MESSAGE_SHORT"
  __run_push
  exit $?
  ;;

custom)
  shift 1
  GITCOMMIT_MESSAGE_SHORT="${1:-${GITCOMMIT_MESSAGE_SHORT:-$GITCOMMIT_DEFAULT_MESSAGE}}"
  if [ -n "$GITCOMMIT_MESSAGE_SHORT" ]; then
    prepend_name=""
    repo_has_changed="$(__changed_files all)"
    [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
    __default_git_action "$GITCOMMIT_MESSAGE_SHORT"
    __run_push
  else
    printf_exit "You must specify your commit message"
  fi
  exit $?
  ;;

fixup | fix-last | fix)
  shift 1
  if [ "$1" = "help" ]; then
    printf_exit "Usage: $APPNAME fixup\n  Automatically amends last real commit (skips version bumps) with current changes"
  fi
  __git_fix_last
  exit $?
  ;;

squash)
  shift 1
  if [ "$1" = "help" ]; then
    printf_exit "Usage: $APPNAME squash [number] [new_message]\n  number: Number of commits to squash (default: 2)\n  new_message: Optional new commit message"
  fi
  num_commits="${1:-2}"
  shift 1 2>/dev/null || true
  new_message="$*"
  __git_squash "$num_commits" "$new_message"
  exit $?
  ;;

*)
  [ $# -ne 0 ] || [ -n "$GITCOMMIT_MESSAGE_FROM_FILE" ] || printf_exit "Usage: $APPNAME [option] [message]"
  GITCOMMIT_MESSAGE_SHORT="${*:-${GITCOMMIT_MESSAGE_SHORT:-$GITCOMMIT_DEFAULT_MESSAGE}}"
  shift $#
  if [ -n "$GITCOMMIT_MESSAGE_SHORT" ]; then
    [ "${#GITCOMMIT_MESSAGE_SHORT}" -gt "4" ] || printf_exit "Message must be longer than 4 characters"
  fi
  repo_has_changed="$(__changed_files all)"
  [ -n "$repo_has_changed" ] || printf_exit "üòø No files have been modified in $GITCOMMIT_ROOT_DIR üòø"
  if [ -n "$GITCOMMIT_MESSAGE_FROM_FILE" ]; then
    __commit_custom "."
  else
    __default_git_action "$GITCOMMIT_MESSAGE_SHORT"
  fi
  ;;
esac
#
if __git_porcelain "$GITCOMMIT_ROOT_DIR"; then
  if [ -z "$GITCOMMIT_RAN" ]; then
    [ "$GITADMIN_NO_ERROR_MESSAGE" = "true" ] || printf_red "There are no changes to commit in ${BASE_DIR}"
    export PUSH_ENABLE="no"
    false
  fi
else
  if [ -z "$GITCOMMIT_MESSAGE_SHORT" ]; then
    if [ -z "$GITCOMMIT_RAN" ]; then
      __gitcommit "üêú Fixes and Updates üêú "
      GITCOMMIT_EXITCODE=0 || GITCOMMIT_EXITCODE=1
    else
      GITCOMMIT_EXITCODE=1
    fi
  else
    if [ -z "$GITCOMMIT_RAN" ]; then
      __gitcommit "$GITCOMMIT_MESSAGE_SHORT" && GITCOMMIT_EXITCODE=0 || GITCOMMIT_EXITCODE=1
    else
      GITCOMMIT_EXITCODE=1
    fi
  fi
  if [ -n "$exitCode" ] && [ -n "$GITCOMMIT_EXITCODE" ]; then
    exitCode=$(($exitCode + $GITCOMMIT_EXITCODE))
  else
    exitCode="${exitCode:-0}"
  fi
fi
#
__run_push && exitCode=${exitCode:-0} || exitCode=1
printf_newline
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set exit code
exitCode="${exitCode:-0}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# End application
# - - - - - - - - - - - - - - - - - - - - - - - - -
# lets exit with code
exit ${exitCode:-0}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# ex: ts=2 sw=2 et filetype=sh
