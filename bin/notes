#!/usr/bin/env bash
# shellcheck shell=bash
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
##@Version           :  202208141346-git
# @@Author           :  Jason Hempstead
# @@Contact          :  jason@casjaysdev.pro
# @@License          :  WTFPL
# @@ReadME           :  notes --help
# @@Copyright        :  Copyright: (c) 2022 Jason Hempstead, Casjays Developments
# @@Created          :  Sunday, Aug 14, 2022 13:46 EDT
# @@File             :  notes
# @@Description      :  Take notes using bash
# @@Changelog        :  New script
# @@TODO             :  Refactor code
# @@Other            :
# @@Resource         :
# @@Terminal App     :  no
# @@sudo/root        :  no
# @@Template         :  bash/system
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# shellcheck disable=SC1003,SC2016,SC2031,SC2120,SC2155,SC2199,SC2317
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
APPNAME="$(basename -- "$0" 2>/dev/null)"
VERSION="202208141346-git"
USER="${SUDO_USER:-$USER}"
RUN_USER="${RUN_USER:-$USER}"
USER_HOME="${USER_HOME:-$HOME}"
SCRIPT_SRC_DIR="${BASH_SOURCE%/*}"
NOTES_REQUIRE_SUDO="${NOTES_REQUIRE_SUDO:-no}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Reopen in a terminal
if [ ! -t 0 ] && { [ "$1" = --term ] || [ $# = 0 ]; }; then { [ "$1" = --term ] && shift 1 || true; } && TERMINAL_APP="TRUE" myterminal -e "$APPNAME $*" && exit || exit 1; fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set script title
#CASJAYS_DEV_TILE_FORMAT="${USER}@${HOSTNAME}:${PWD//$HOME/\~} - $APPNAME"
#CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}"
#[ -z "$CASJAYSDEV_TITLE_SET" ] && printf '\033]2â”‚;%s\033\\' "$CASJAYS_DEV_TILE_FORMAT" && CASJAYSDEV_TITLE_SET="$APPNAME"
export CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}" CASJAYSDEV_TITLE_SET
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Initial debugging
[ "$1" = "--debug" ] && set -x && export SCRIPT_OPTS="--debug" && export _DEBUG="on"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Disables colorization
[ "$1" = "--raw" ] && export SHOW_RAW="true"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# pipes fail
set -o pipefail
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Import functions
CASJAYSDEVDIR="${CASJAYSDEVDIR:-/usr/local/share/CasjaysDev/scripts}"
SCRIPTSFUNCTDIR="${CASJAYSDEVDIR:-/usr/local/share/CasjaysDev/scripts}/functions"
SCRIPTSFUNCTFILE="${SCRIPTSAPPFUNCTFILE:-testing.bash}"
SCRIPTSFUNCTURL="${SCRIPTSAPPFUNCTURL:-https://github.com/dfmgr/installer/raw/main/functions}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if [ -f "$PWD/$SCRIPTSFUNCTFILE" ]; then
  . "$PWD/$SCRIPTSFUNCTFILE"
elif [ -f "$SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE" ]; then
  . "$SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE"
else
  echo "Can not load the functions file: $SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE" 1>&2
  exit 1
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Options are: *_install
# system user desktopmgr devenvmgr dfmgr dockermgr fontmgr iconmgr pkmgr systemmgr thememgr wallpapermgr
user_install && __options "$@"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Send all output to /dev/null
__devnull() {
  tee &>/dev/null && exitCode=0 || exitCode=1
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'
# Send errors to /dev/null
__devnull2() {
  [ -n "$1" ] && local cmd="$1" && shift 1 || return 1
  eval $cmd "$*" 2>/dev/null && exitCode=0 || exitCode=1
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'
# See if the executable exists
__cmd_exists() {
  exitCode=0
  [ -n "$1" ] && local exitCode="" || return 0
  for cmd in "$@"; do
    builtin command -v "$cmd" &>/dev/null && exitCode+=$(($exitCode + 0)) || exitCode+=$(($exitCode + 1))
  done
  [ $exitCode -eq 0 ] || exitCode=3
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for a valid internet connection
__am_i_online() {
  local exitCode=0
  curl -q -LSsfI --max-time 2 --retry 1 "${1:-https://1.1.1.1}" 2>&1 | grep -qi 'server:.*cloudflare' || exitCode=4
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# colorization
if [ "$SHOW_RAW" = "true" ]; then
  NC=""
  RESET=""
  BLACK=""
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  PURPLE=""
  CYAN=""
  WHITE=""
  ORANGE=""
  LIGHTRED=""
  BG_GREEN=""
  BG_RED=""
  ICON_INFO="[ info ]"
  ICON_GOOD="[ ok ]"
  ICON_WARN="[ warn ]"
  ICON_ERROR="[ error ]"
  ICON_QUESTION="[ ? ]"
  printf_column() { tee | grep '^'; }
  printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
else
  printf_color() { printf "%b" "$(tput setaf "${2:-7}" 2>/dev/null)" "$1" "$(tput sgr0 2>/dev/null)"; }
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional printf_ colors
__printf_head() { printf_blue "$1"; }
__printf_opts() { printf_purple "$1"; }
__printf_line() { printf_cyan "$1"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# output version
__version() { printf_cyan "$VERSION"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# list options
__list_options() {
  printf_color "$1: " "$5"
  echo -ne "$2" | sed 's|:||g;s/'$3'/ '$4'/g' | tr '\n' ' '
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# create the config file
__gen_config() {
  local NOTIFY_CLIENT_NAME="$APPNAME"
  if [ "$INIT_CONFIG" != "TRUE" ]; then
    printf_blue "Generating the config file in"
    printf_cyan "$NOTES_CONFIG_DIR/$NOTES_CONFIG_FILE"
  fi
  [ -d "$NOTES_CONFIG_DIR" ] || mkdir -p "$NOTES_CONFIG_DIR"
  [ -d "$NOTES_CONFIG_BACKUP_DIR" ] || mkdir -p "$NOTES_CONFIG_BACKUP_DIR"
  [ -f "$NOTES_CONFIG_DIR/$NOTES_CONFIG_FILE" ] &&
    cp -Rf "$NOTES_CONFIG_DIR/$NOTES_CONFIG_FILE" "$NOTES_CONFIG_BACKUP_DIR/$NOTES_CONFIG_FILE.$$"
  cat <<EOF >"$NOTES_CONFIG_DIR/$NOTES_CONFIG_FILE"
# Settings for notes
NOTES_HOME="${NOTES_HOME:-}"
NOTES_EDITOR="${NOTES_EDITOR:-}"
NOTES_SERVER_NAME="${NOTES_SERVER_NAME:-}"
NOTES_SERVER_PORT="${NOTES_SERVER_PORT:-}"
NOTES_GIT_ENABLED="${NOTES_GIT_ENABLED:-}"
NOTES_SERVER_DIRECTORY="${NOTES_SERVER_DIRECTORY:-}"
NOTES_SERVER_TIMEOUT="${NOTES_SERVER_TIMEOUT:-}"
NOTES_LOG_FILE="${NOTES_LOG_FILE:-}"
NOTES_DEDUP_NOTIFY="${NOTES_DEDUP_NOTIFY:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
NOTES_OUTPUT_COLOR_1="${NOTES_OUTPUT_COLOR_1:-}"
NOTES_OUTPUT_COLOR_2="${NOTES_OUTPUT_COLOR_2:-}"
NOTES_OUTPUT_COLOR_GOOD="${NOTES_OUTPUT_COLOR_GOOD:-}"
NOTES_OUTPUT_COLOR_ERROR="${NOTES_OUTPUT_COLOR_ERROR:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
NOTES_NOTIFY_ENABLED="${NOTES_NOTIFY_ENABLED:-}"
NOTES_GOOD_NAME="${NOTES_GOOD_NAME:-}"
NOTES_ERROR_NAME="${NOTES_ERROR_NAME:-}"
NOTES_GOOD_MESSAGE="${NOTES_GOOD_MESSAGE:-}"
NOTES_ERROR_MESSAGE="${NOTES_ERROR_MESSAGE:-}"
NOTES_NOTIFY_CLIENT_NAME="${NOTES_NOTIFY_CLIENT_NAME:-}"
NOTES_NOTIFY_CLIENT_ICON="${NOTES_NOTIFY_CLIENT_ICON:-}"
NOTES_NOTIFY_CLIENT_URGENCY="${NOTES_NOTIFY_CLIENT_URGENCY:-}"

EOF
  if builtin type -t __gen_config_local | grep -q 'function'; then __gen_config_local; fi
  if [ -f "$NOTES_CONFIG_DIR/$NOTES_CONFIG_FILE" ]; then
    [ "$INIT_CONFIG" = "TRUE" ] || printf_green "Your config file for $APPNAME has been created"
    . "$NOTES_CONFIG_DIR/$NOTES_CONFIG_FILE"
    exitCode=0
  else
    printf_red "Failed to create the config file"
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Help function - Align to 50
__help() {
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "notes:  Take notes using bash - $VERSION"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "Usage: notes [options] [commands]"
  __printf_line "*                               - Opens your notes in vim"
  __printf_line "something you want to jot down  - Appends that text to the file"
  __printf_line "xclip -o | notes or notes -    - Appends stdin to the file"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "client usage:                   "
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "client                          - used to send notes to the server - same syntax as notes"
  __printf_line "client message to send          - Appends that text to the server file"
  __printf_line "xclip -o | notes client         - Appends stdin to the server file"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "server usage:                   "
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "server                          - Run notes as a server using netcat"
  __printf_line "server open                     - Open your notes on remote server"
  __printf_line "server open all                 - Open all your notes on remote server"
  __printf_line "server --status                 - Shows the current status of the server"
  __printf_line "server --kill                   - Initiates the kill to stop the server"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "systemd server usage:           "
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "service systemd                 - Systemd functions"
  __printf_line "service systemd install         - Installs notes as a service using systemd"
  __printf_line "service systemd remove          - Remove the notes systemd service"
  __printf_line "service systemd start           - Start the notes systemd service"
  __printf_line "service systemd stop            - Stop the notes systemd service"
  __printf_line "service systemd restart         - Restart the notes systemd service"
  __printf_line "service systemd status          - Get the notes systemd service status"
  __printf_line "service systemd run/vars        - Used by systemd to run the notes server"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Other Options"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "--help                          - Shows this message"
  __printf_line "--config                        - Generate user config file"
  __printf_line "--version                       - Show script version"
  __printf_line "--options                       - Shows all available options"
  __printf_line "--debug                         - Enables script debugging"
  __printf_line "--raw                           - Removes all formatting on output"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "All variables can be overwritten by editing the file"
  __printf_opts "$NOTES_CONFIG_DIR/$NOTES_CONFIG_FILE"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# check if arg is a builtin option
__is_an_option() { if echo "$ARRAY" | grep -q "${1:-^}"; then return 1; else return 0; fi; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Is current user root
__user_is_root() {
  { [ $(id -u) -eq 0 ] || [ $EUID -eq 0 ] || [ "$WHOAMI" = "root" ]; } && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Is current user not root
__user_is_not_root() {
  if { [ $(id -u) -eq 0 ] || [ $EUID -eq 0 ] || [ "$WHOAMI" = "root" ]; }; then return 1; else return 0; fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check if user is a member of sudo
__sudo_group() {
  grep -sh "${1:-$USER}" "/etc/group" | grep -Eq 'wheel|adm|sudo' || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# # Get sudo password
__sudoask() {
  ask_for_password sudo true && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run sudo
__sudorun() {
  __sudoif && __cmd_exists sudo && sudo -HE "$@" || { __sudoif && eval "$@"; }
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Test if user has access to sudo
__can_i_sudo() {
  (sudo -vn && sudo -ln) 2>&1 | grep -vq 'may not' >/dev/null && return 0
  __sudo_group "${1:-$USER}" || __sudoif || __sudo true &>/dev/null || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User can run sudo
__sudoif() {
  __user_is_root && return 0
  __can_i_sudo "${RUN_USER:-$USER}" && return 0
  __user_is_not_root && __sudoask && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run command as root
requiresudo() {
  if [ "$NOTES_REQUIRE_SUDO" = "yes" ] && [ -z "$NOTES_REQUIRE_SUDO_RUN" ]; then
    export NOTES_REQUIRE_SUDO="no"
    export NOTES_REQUIRE_SUDO_RUN="true"
    __sudo "$@"
    exit $?
  else
    return 0
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute sudo
__sudo() {
  CMD="${1:-echo}" && shift 1
  CMD_ARGS="${*:--e "${RUN_USER:-$USER}"}"
  SUDO="$(builtin command -v sudo 2>/dev/null || echo 'eval')"
  [ "$(basename -- "$SUDO" 2>/dev/null)" = "sudo" ] && OPTS="--preserve-env=PATH -HE"
  if __sudoif; then
    export PATH="$PATH"
    $SUDO ${OPTS:-} $CMD $CMD_ARGS && true || false
    exitCode=$?
  else
    printf '%s\n' "This requires root to run"
    exitCode=1
  fi
  return ${exitCode:-1}
}
# End of sudo functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__trap_exit() {
  exitCode=${exitCode:-0}
  [ -f "$NOTES_TEMP_FILE" ] && rm -Rf "$NOTES_TEMP_FILE" &>/dev/null
  #unset CASJAYSDEV_TITLE_SET && printf '\033]2â”‚;%s\033\\' "${USER}@${HOSTNAME}:${PWD//$HOME/\~} - ${CASJAYSDEV_TITLE_PREV:-$SHELL}"
  if builtin type -t __trap_exit_local | grep -q 'function'; then __trap_exit_local; fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined functions
__server_start() {
  notes server start "$@" &>/dev/null &
  disown || return 1
  sleep 3
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# SystemD service file
systemd_service() {
  if [ -f "$HOME/.config/autostart/notes-server.desktop" ]; then
    printf_exit 1 1 "User autostart is enabled"
  fi
  [ -f "$1" ] && sudo rm -Rf "$1"
  cat <<EOF | sudo tee -p "$1" &>/dev/null
[Unit]
Description=Notes Server
After=network.target

[Service]
Type=dbus
Restart=always
RestartSec=5
KillMode=mixed
User=${USER:-daemon}
Group=${USER:-daemon}

Environment=HOME="${HOME}"
Environment=TERM="${TERM:-linux}"
Environment=NOTES_TEMP_DIR="${TMP:-/tmp/notes_server}"
Environment=NOTES_HOME="${HOME}/.local/share/editors/notes"
Environment=NOTES_LOG_FILE="${NOTES_TEMP_DIR}/notes_server.log"
Environment=NOTES_SERVER_NAME="$(hostname -f)"
Environment=NOTES_SERVER_PORT="65000"
Environment=NOTES_TEMP_FILE="$NOTES_TEMP_DIR/notes.server.tmp.txt"
Environment=NOTES_NOTIFY_ENABLED="${NOTES_NOTIFY_ENABLED:-yes}"

ExecStartPre=/usr/local/bin/notes server systemd run vars
ExecStopPost=/usr/bin/rm -Rf "$NOTES_TEMP_DIR $NOTES_LOG_FILE"
ExecStop=/usr/local/bin/notes server systemd run stop
ExecStart=/usr/local/bin/notes server systemd run start
ExecReload=/usr/local/bin/notes server systemd run restart
TimeoutSec=20
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target

EOF
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Enable user autostart
__server_enable() {
  if __system_service_exists notes_server; then
    printf_exit 1 1 "$ICON_WARN systemd service already exists"
  fi
  printf_green "Enabling the Notes Server on port $NOTES_SERVER_PORT"
  cat <<EOF | tee -p "$HOME/.config/autostart/notes-server.desktop" &>/dev/null
#!/usr/bin/env xdg-open

[Desktop Entry]
Version=1.1
Type=Application
Name=Notes Server
GenericName=NotesServer
Comment=Start Notes Server.
Icon=geany
Exec=notes server start loop &
Path=~
Terminal=false
Actions=
Categories=System;Development;GTK;X-XFCE;GNOME;
Keywords=notes;server;
StartupNotify=true

EOF
  { __server_start loop & } || false
  if [ $? = 0 ]; then
    printf_green "notes server has been installed for $USER"
    __notifications "NotesCLI" "Service has been enabled"
  else
    printf_error 1 1 "$ICON_WARN Failed to install the notes server for $USER"
    __notifications "$ICON_WARN Failed to install the notes server for $USER"
  fi
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__server_disable() {
  # __notifications "NotesCLI" "Disabling notes server"
  # printf_green "Disabling notes server"
  if [ -f "$HOME/.config/autostart/notes-server.desktop" ]; then
    __rm_rf "$HOME/.config/autostart/notes-server.desktop"
  fi
  if [ -f "/etc/systemd/system/notes_server.service" ]; then
    if __can_i_sudo || user_is_root; then
      sudo rm -Rf "/etc/systemd/system/notes_server.service" &>/dev/null
      sudo systemctl daemon-reload &>/dev/null
    else
      printf_red "sudo is required to delete the systemd service"
      __notifications "NotesCLI" "sudo is required to delete the systemd service"
    fi
  fi
  if [ -f "$HOME/.config/autostart/notes-server.desktop" ] || [ -f "/etc/systemd/system/notes_server.service" ]; then
    __notifications "NotesCLI" "Failed to disable the service"
    printf_red "Failed to disable the service"
  else
    __notifications "NotesCLI" "Service has been disabled"
    printf_green "Service has been disabled"
  fi
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NOTES_NETCAT_BIN="$(builtin type -P nc 2>/dev/null || builtin type -P netcat 2>/dev/null || false)"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__netcat_pids() {
  netstat -tupln 2>/dev/null | grep ":$1" | grep "$(__basename ${NOTES_NETCAT_BIN:-nc})" |
    awk '{print $7}' | sed 's#'/"$(__basename ${NOTES_NETCAT_BIN:-nc})"'##g' | grep '^'
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__kill_netpid() {
  netstatg "$1" | grep "$(__basename "$2")" | awk '{print $7}' |
    sed 's#/'$2'##g' && netstat -taupln | grep -qv "$1" || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__netcat_kill() {
  pidof "$NOTES_NETCAT_BIN" &>/dev/null && kill -s KILL "$(__netcat_pids "$1")" &>/dev/null
  netstat -taupln | grep -Fqv ":$1 " || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#__kill_server "port required" "print success" "print fail" "success message" "failed message"
__netcat_kill_server() {
  local port="" print_succ="" print_fail="" mess_succ="" mess_fail=""
  port="${1:?}"
  print_succ="${2:-printf_green}"
  print_fail="${3:-printf_red}"
  mess_succ="${4:-Server has been stopped}"
  mess_fail="${5:-Failed to stop}"
  __netcat_kill "${port}" >/dev/null 2>&1 &&
    ${print_succ} "${mess_succ}" || ${print_fail} "${mess_fail}"
  sleep 2
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__netcat_test() {
  __cmd_exists $NOTES_NETCAT_BIN || printf_exit "The program netcat is not installed"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__nc_send() {
  eval $NOTES_NETCAT_BIN -c $1 $2 2>>"$NOTES_LOG_FILE" && true || $NOTES_NETCAT_BIN -w 1 $1 $2 2>>"$NOTES_LOG_FILE" || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__local() {
  if [ "$NOTES_SERVER_NAME" = "$(hostname -f)" ] || [ "$NOTES_SERVER_NAME" = "$(hostname -s)" ] ||
    [ "$NOTES_SERVER_NAME" = "localhost" ]; then
    return 1
  else
    return 0
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__notes() {
  local editor="$(type -P "$NOTES_EDITOR" 2>/dev/null || type -P "vim" 2>/dev/null || type -P "nano" 2>/dev/null || type -P "nvim" 2>/dev/null || type -P "vi" 2>/dev/null || type -P "vi" 2>/dev/null || false)"
  if __cmd_exists tmux; then
    unset TMUX
    eval tmux -f "${NOTES_HOME}/tmux.conf" new-session -D -A -s notes "$editor ${1:-$NOTES_PATH}" &>/dev/null || return 1
  elif [ -n "$editor" ]; then
    eval "$editor ${1:-$NOTES_PATH}" &>/dev/null || return 1
  else
    __notifications "No editors found"
    exit 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__dedup() {
  local _MSG="" _NOTESP=""
  _MSG="$1"
  _NOTESP=${2:-$NOTES_PATH}
  shift $#
  if grep -shqx "$_MSG" "$_NOTESP"; then
    DEDUP=true
    if [ "${NOTES_DEDUP_NOTIFY:-$DEDUP_NOTIFY}" = "yes" ]; then
      __notifications "NotesCLI" "$_MSG already added to $_NOTESP"
    fi
    return 1
  else
    return 0
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#__update_notes "$message" "${NOTES_PATH}"
__update_notes() {
  [[ "$NOTES_SERVER_NAME" =~ $HOSTNAME ]] && return
  if __dedup "$1" "$2"; then
    printf "%s\n" "$1" >>"${2:-$NOTES_PATH}" 2>>"${3:-$NOTES_LOG_FILE}" && exitCode=0 && __notifications "New Note" "$1\nposted to\n$2"
    if [ "$exitCode" -ne 0 ]; then __notifications "Failed to post the note"; fi
  else
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__listdirfiles() {
  local dirs="" files=""
  dirs="$(find "$NOTES_HOME"/* -type d | grep -vE "/.git|archive" | sort -u)"
  for dir in $dirs; do
    file+=("$(find "$dir" -type f -iname '*.txt') ")
  done
  printf '%s\n' "${file[@]}" | sort -n
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# sync to all.txt
__run_sync() {
  if __find_mtime "${NOTES_PATH}" "3"; then
    __sync_all "$NOTES_PATH" "$NOTES_HOME/all.txt" 2>/dev/null
    [ $? = 0 ] && __notifications "NotesCLI" "Notes have been synced to all.txt"
  fi
  __run_git
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__sync_tmp() {
  local _NOTESP="" _TPATH=""
  _NOTESP="${1:-$NOTES_PATH}"
  _TPATH="${2:-$_PATH}"
  shift
  if [ -n "$_TPATH" ]; then cat "$_NOTESP" "$_TPATH" >"$NOTES_TEMP_DIR/notes_cli.tmp" &&
    __mv_f "$NOTES_TEMP_DIR/notes_cli.tmp" "$_NOTESP"; fi
  [ -f "$NOTES_HOME/all.txt" ] && __sync_all && echo synced >>"$NOTES_LOG_FILE"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__sync_all() {
  [ -z "$DEDUP" ] || return
  local exitCode=0 notesFile="" _NOTESP="" _NOTESA="" _NOTES_TMPFILE="" _ARCHIVE=""
  _NOTESP=${1:-$NOTES_PATH}
  _NOTESA="${2:-$NOTES_HOME/all.txt}"
  _NOTES_TMPFILE="${NOTES_TEMP_DIR:-/tmp}/notes.$$.tmp"
  _ARCHIVE="$NOTES_HOME/archive/$(date +'%y-%m-%d').txt"
  [ -f "$_NOTES_TMPFILE" ] && rm -f "$_NOTES_TMPFILE"
  [ -f "$_NOTESA" ] || touch "$_NOTESP"
  [ -f "$_NOTESA" ] || cat "$_NOTESP" >"$_NOTESA" 2>/dev/null
  for notesDir in $(__listdirfiles); do
    notesFile="$notesDir"
    [ "$show" = "true" ] && printf_green "$notesFile to ${_NOTESA/$NOTES_HOME\//}"
    cat "$notesFile" | sed '/^\#/d;/^$/d' | sort -u >>"$_NOTES_TMPFILE" 2>/dev/null || local exitCode=1
  done
  if [ "$all" = "true" ]; then
    [ "$show" = "true" ] && printf_green "Archiving ${_NOTESA/$NOTES_HOME\//} to ${_ARCHIVE/$NOTES_HOME\//}"
    __mkd "$NOTES_HOME/archive"
    __cp_rf $_NOTESA "$_ARCHIVE"
  fi
  if [ -f "$_NOTES_TMPFILE" ]; then
    echo "### All Active notes as of $(date)" >"$_NOTESA" &&
      cat "$_NOTES_TMPFILE" | sort -u >>"$_NOTESA" || local exitCode=1
  fi
  __rm_rf "$_NOTES_TMPFILE" "$_NOTESA.tmp"
  if [ "$show" = "true" ]; then
    [ "$exitCode" = 0 ] && printf_green "Sync completed" || printf_error 1 "Sync failed"
  fi
  return "$exitCode"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Server function for user autostart
__server() {
  local _PORT="" _KILL="" _TMPFILE="" NOTES_SERVER_LOOP="${NOTES_SERVER_LOOP:-}" errormsg=""
  [ "$1" = "loop" ] && NOTES_SERVER_LOOP="yes"
  _PORT="$NOTES_SERVER_PORT"
  _KILL="$NOTES_TEMP_DIR/kill_notes"
  _TMPFILE="$NOTES_TEMP_FILE"
  __mkd "$NOTES_TEMP_DIR"
  __netcat_test
  netstatg "$_PORT" &>/dev/null && printf_exit "Already Running" || printf_green "Launching server on port $_PORT"
  if [ "$NOTES_SERVER_LOOP" != "yes" ]; then
    __notifications "Notes Server" "Launching server on port $_PORT"
    echo "Starting notes server on port $_PORT" >>"$NOTES_LOG_FILE"
  fi
  timeout ${NOTES_SERVER_TIMEOUT:-600} $NOTES_NETCAT_BIN -l -p $_PORT >"$_TMPFILE"
  message="$(<"$_TMPFILE")"
  if __dedup "$message" "$NOTES_PATH"; then
    __update_notes "$message" "$NOTES_PATH" "$NOTES_LOG_FILE"
  else
    errormsg="$message seemes to be duplicate"
  fi
  if [ -n "$message" ] && [ -z "$DEDUP" ]; then
    echo "New note: $message" >>"$NOTES_LOG_FILE"
  else
    echo "NotesCLI" "Problem receiving message: ${errormsg:-File is empty}" >>"$NOTES_LOG_FILE"
  fi
  __rm_rf "$_TMPFILE"
  if [ -f "$_KILL" ]; then
    rm -Rf "$_KILL"
    echo "Notes server is shutting down" >>"$NOTES_LOG_FILE"
    __notifications "Notes Server" "Notes server is shutting down"
    exit 5
  fi
  unset message
  __server loop
  #notes server start loop
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Server function for SystemD
__run_service() {
  local _PORT="" _PATH="" DISPLAY="${DISPLAY:-}"
  local NOTES_SERVER_LOOP="${NOTES_SERVER_LOOP:-}"
  local NOTES_NOTIFY_ENABLED="${NOTES_NOTIFY_ENABLED:-}"
  _PORT="$NOTES_SERVER_PORT"
  _PATH="$NOTES_TEMP_FILE"
  NOTES_NOTIFY_ENABLED=${NOTES_NOTIFY_ENABLED:-yes}
  DISPLAY="${DISPLAY:-0.0}"
  kill -s KILL "$(netstatg $_PORT | awk '{print $7}' | head -n 1 | sed 's#/.*##g')" || true
  if [ "$NOTES_SERVER_LOOP" != "yes" ]; then
    echo "Launching server on port $_PORT"
    echo "Starting notes server on port $_PORT" >"$NOTES_LOG_FILE"
  fi
  rm -Rf "$NOTES_TEMP_DIR/kill_notes"
  rm -Rf "$_PATH"
  timeout ${NOTES_SERVER_TIMEOUT:-600} $NOTES_NETCAT_BIN -l -p "$_PORT" >"$_PATH"
  if __file_not_empty "$_PATH"; then
    cat "$_PATH" >>"${NOTES_PATH}" 2>>"$NOTES_LOG_FILE" || echo "Failed to commit the note"
    echo "New note: $(cat $_PATH) in ${NOTES_PATH}"
  fi
  rm -Rf "$_PATH"
  notes server systemd run start
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Client function
__client() {
  local MESSAGE="" DEDUP_NOTIFY="" _SERVER="" _PORT="" _PATH=""
  local _WRITE_MESSAGE="" _POSTMESSAGE=""
  __failed() {
    __notifications "${1:-NotesCLI}" "${2:-$MESSAGE Failed to send}"
    printf_red "failed to send message"
    return 1
  }
  __success() {
    __notifications "${1:-NotesCLI}" "${2:-$MESSAGE has been sent}"
    return 0
  }
  MESSAGE="$1"
  DEDUP_NOTIFY="${DEDUP_NOTIFY:-no}"
  _SERVER="${NOTES_SERVER_NAME}"
  _PORT=${NOTES_SERVER_PORT}
  _PATH="$NOTES_TEMP_FILE"
  _WRITE_MESSAGE="$(printf "%s\n" "$*" >"$_PATH" 2>>$NOTES_TEMP_DIR/notes_client && echo success || echo failed)"
  __netcat_test
  printf_green "Attempting to send message to $_SERVER on $_PORT"
  _POSTMESSAGE="$(cat "$_PATH" 2>>$NOTES_TEMP_DIR/notes_client | __nc_send "$_SERVER" "$_PORT" 2>>$NOTES_TEMP_DIR/notes_client && echo success || echo failed)"
  if [ "$_WRITE_MESSAGE" == "success" ] && [ "$_POSTMESSAGE" == "success" ]; then
    __dedup "$MESSAGE" "$NOTES_PATH"
    __success "NotesCLI"
    exitCode=0
  elif [ "$_WRITE_MESSAGE" == "success" ] || [ "$_POSTMESSAGE" == "success" ]; then
    $_POSTMESSAGE
    if [ "$_POSTMESSAGE" == "success" ]; then
      __dedup "$MESSAGE" "$NOTES_PATH"
      __success "NotesCLI"
      exitCode=0
    else
      __failed "NotesCLI"
      exitCode=1
    fi
  else
    __failed "NotesCLI"
    exitCode=1
  fi
  if [ ${exitCode:-0} = 0 ]; then
    if [ "$NOTES_NOTIFY_ENABLED" = "yes" ]; then
      if [ -z "$DEDUP" ]; then
        __notifications "New note" "$(cat $_PATH)\nPosted to: $NOTES_PATH"
      fi
    else
      __notifications "NotesCLI" "Sending of note failed"
    fi
  fi
  if [ -z "$DEDUP" ]; then
    __local && __sync_tmp "$NOTES_PATH" "$_PATH"
  fi
  rm -Rf "$_PATH"
  return "$?"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Import previous month notes
__import() {
  if [ -f "${1:-$NOTES_PREV_FILE}" ]; then
    if cat "${1:-$NOTES_PREV_FILE}" | sed '/^\#/d;/^$/d' | sort -u >>"${NOTES_PATH}"; then
      printf_green "Notes have been imported"
      sleep 1
      return 0
    else
      return 1
    fi
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__add_remote() {
  [ -f "$NOTES_HOME/.nopush" ] && return
  git -C "$NOTES_HOME" remote -v 2>&1 | grep -q 'fatal:' &>/dev/null || return
  printf_read_question "4" "Would you like to add a remote repo? " "1" "Yy"
  printf_answer "Yy" && printf_read_input "5" "What is the URL of your repo? " "200" "REMOTE" &&
    git -C "$NOTES_HOME" remote add origin "$REMOTE" || printf 'Push disabled\n' >"$NOTES_HOME/.nopush"
  [ -f "$NOTES_HOME/.nopush" ] || git -C "$NOTES_HOME" push -q &>/dev/null
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__run_git() {
  local git_author="" git_email="" git_enabled=""
  git_author="$(git config --get user.name | grep '^')"
  git_email="$(git config --get user.name | grep '^')"
  git_enabled="$NOTES_GIT_ENABLED"
  [ -n "$git_author" ] && [ -n "$git_email" ] || return
  { [ "$git_enabled" = "no" ] || [ "$git_enabled" = "disabled" ]; } && return
  if [ -d "$NOTES_HOME/.git" ]; then
    __git_commit
  else
    git -C "$NOTES_HOME" init &>/dev/null && gitcommit "$NOTES_HOME" notes
  fi
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_pull() {
  local REMOTE_URL
  REMOTE_URL="$(__git_remote_pull "$NOTES_HOME")"
  [ -n "$NOTES_GIT_ENABLED" ] && [ -n "$REMOTE_URL" ] || return
  { [ "$NOTES_GIT_ENABLED" = "no" ] || [ "$NOTES_GIT_ENABLED" = "disabled" ]; } && return
  git -C "$NOTES_HOME" pull -q || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# list all notes
__list_all() {
  printf_green "All notes in $NOTES_HOME"
  find ${NOTES_HOME}/*/* ${NOTES_HOME}/all.txt -type f -iname "*.txt" -not -path "${NOTES_HOME}/archive/*" |
    sed 's#'$NOTES_HOME/'##g' | printf_column 6
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__initialize_app() {
  NOTES_DIR="$(dirname "$NOTES_PATH")"
  if [ ! -d "$NOTES_HOME" ] || [ "$(__count_files "$NOTES_HOME" "4")" = 0 ]; then
    [ -d "$NOTES_HOME" ] && rm -Rf "$NOTES_HOME" 2>/dev/null
    printf_green "This seems to be a clean install"
    printf_read_question "4" "Would you like to import an existing notes?" "1" "YES"
    if printf_answer_yes "$YES"; then
      printf_read_input "6" "Please enter the url to your git repo: " "200" "REPO"
      [ -n "$REPO" ] && { git clone -q "$REPO" "$NOTES_HOME" &>/dev/null || printf_exit "Failed to clone $REPO"; }
      [ -d "$NOTES_HOME" ] || printf_return "Failed to import repo"
      if [ ! -f "$NOTES_PATH" ]; then
        cat -s "$NOTES_HOME"/*/*.txt 2>/dev/null >"/tmp/notes.$$.txt"
        echo -e "## Notes for $(date +%B) created on $(date +"%D at %H:%M") ##\n" >"${NOTES_PATH}"
        __import "/tmp/notes.$$.txt"
      else
        __mkd "$NOTES_HOME"
      fi
    fi
    if [ "$NOTES_GIT_ENABLED" = "yes" ] || [ "$NOTES_GIT_ENABLED" = "enabled" ]; then
      [ -f "$NOTES_HOME/LICENSE.md" ] || gen-license --dir "$NOTES_HOME" wtfpl
      [ -f "$NOTES_HOME/README.md" ] || printf '#  My notes  \n' >"$NOTES_HOME/README.md"
      [ -d "$NOTES_HOME/.git" ] || gitadmin --dir "$NOTES_HOME" setup --noreadme --nolicense
    fi
  elif [ "$NOTES_GIT_ENABLED" = "yes" ] || [ "$NOTES_GIT_ENABLED" = "enabled" ]; then
    [ -d "$NOTES_HOME/.git" ] && __git_pull
  fi
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  [ -d "$NOTES_DIR" ] || mkdir -p "$NOTES_DIR"
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # tmux config file
  if [ ! -f "$NOTES_HOME/tmux.conf" ]; then
    if [ -f "$HOME/.config/tmux/others/editors.conf" ]; then
      __cp_rf "$HOME/.config/tmux/others/editors.conf" "$NOTES_HOME/tmux.conf"
    else
      __cp_rf "$CASJAYSDEVDIR/templates/tmux/simple.conf" "$NOTES_HOME/tmux.conf"
    fi
  fi
  if [ ! -f "$NOTES_PREV_FILE" ]; then
    printf '## Notes for %s created on %s  ##\n\n\n' "$(date --date="1 Month Ago" +%B)" "$(date --date="1 Month Ago" +"%D at %H:%M")" >"$NOTES_PREV_FILE"
  fi
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Previous month
  if [ ! -f "$NOTES_PATH" ]; then
    if [ -s "$NOTES_PATH" ]; then
      printf_red "Refusing to import old notes into an none empty file"
      printf_green "You can do it manually by running $APPNAME --import"
    else
      printf_green "Assuming its a new month or new install"
      printf '## Notes for %s created on on %s ##  \n\n\n' "$(date +%B)" "$(date +"%D at %H:%M")" >"${NOTES_PATH}"
      __import "$NOTES_PREV_FILE"
    fi
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__kill_server() {
  if netstatg "$NOTES_SERVER_PORT" &>/dev/null; then
    printf_red "Starting shutdown"
    shift 1
    touch "$NOTES_TEMP_DIR/kill_notes"
    __netcat_kill_server "$NOTES_SERVER_PORT" "printf_green" "printf_red"
    exitCode=$?
    # kill -s 9 "$(netstatg $NOTES_SERVER_PORT | awk '{print $7}' | head -n 1 | sed 's#/.*##g')" || true
  else
    printf_red "Server is not running"
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__git_head() { [ -d "$NOTES_HOME/.git" ] && git -C "$NOTES_HOME" status --porcelain 2>&1 | grep -q '^' || return 1; }
__git_commit() { if __git_status; then gitcommit "$NOTES_HOME" todo; else return 0; fi; }
__git_status() { __git_head || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined variables/import external variables

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Application Folders
NOTES_CONFIG_FILE="${NOTES_CONFIG_FILE:-settings.conf}"
NOTES_CONFIG_DIR="${NOTES_CONFIG_DIR:-$HOME/.config/myscripts/notes}"
NOTES_CONFIG_BACKUP_DIR="${NOTES_CONFIG_BACKUP_DIR:-$HOME/.local/share/myscripts/notes/backups}"
NOTES_LOG_DIR="${NOTES_LOG_DIR:-$HOME/.local/log/notes}"
NOTES_TEMP_DIR="${NOTES_TEMP_DIR:-$HOME/.local/tmp/system_scripts/notes}"
NOTES_CACHE_DIR="${NOTES_CACHE_DIR:-$HOME/.cache/notes}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
NOTES_OUTPUT_COLOR_1="${NOTES_OUTPUT_COLOR_1:-33}"
NOTES_OUTPUT_COLOR_2="${NOTES_OUTPUT_COLOR_2:-5}"
NOTES_OUTPUT_COLOR_GOOD="${NOTES_OUTPUT_COLOR_GOOD:-2}"
NOTES_OUTPUT_COLOR_ERROR="${NOTES_OUTPUT_COLOR_ERROR:-1}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
NOTES_NOTIFY_ENABLED="${NOTES_NOTIFY_ENABLED:-yes}"
NOTES_GOOD_NAME="${NOTES_GOOD_NAME:-Great:}"
NOTES_ERROR_NAME="${NOTES_ERROR_NAME:-Error:}"
NOTES_GOOD_MESSAGE="${NOTES_GOOD_MESSAGE:-No errors reported}"
NOTES_ERROR_MESSAGE="${NOTES_ERROR_MESSAGE:-Errors were reported}"
NOTES_NOTIFY_CLIENT_NAME="${NOTES_NOTIFY_CLIENT_NAME:-$APPNAME}"
NOTES_NOTIFY_CLIENT_ICON="${NOTES_NOTIFY_CLIENT_ICON:-notification-new}"
NOTES_NOTIFY_CLIENT_URGENCY="${NOTES_NOTIFY_CLIENT_URGENCY:-normal}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional Variables
NOTES_PREV_YEAR="$(date --date='1 year ago' +%Y)"
NOTES_PREV_MONTH="$(date --date="1 Month Ago" +%m)"
NOTES_NOTIFY_ENABLED="${NOTES_NOTIFY_ENABLED:-yes}"
NOTES_FOLDER="${NOTES_FOLDER:-$(date +%Y)}"
NOTES_FILE="${NOTES_FILE:-$(date +%m).txt}"
NOTES_HOME="${NOTES_HOME:-"$HOME/.local/share/editors/notes"}"
NOTES_EDITOR="${NOTES_EDITOR:-vim}"
NOTES_SERVER_NAME="${NOTES_SERVER_NAME:-localhost}"
NOTES_SERVER_PORT="${NOTES_SERVER_PORT:-65000}"
NOTES_SERVER_DIRECTORY="${NOTES_SERVER_DIRECTORY:-$NOTES_HOME}"
NOTES_SERVER_TIMEOUT="${NOTES_SERVER_TIMEOUT:-600}"
NOTES_LOG_FILE="${NOTES_LOG_FILE:-$NOTES_TEMP_DIR/notes_server.log}"
NOTES_PATH="${NOTES_PATH:-$NOTES_HOME/$NOTES_FOLDER/$NOTES_FILE}"
NOTES_SERVER_PATH="${NOTES_SERVER_PATH:-$NOTES_SERVER_DIRECTORY/$NOTES_FOLDER/$NOTES_FILE}"
NOTES_DEDUP_NOTIFY="${NOTES_DEDUP_NOTIFY:-no}"
NOTES_GIT_ENABLED="${NOTES_GIT_ENABLED:-enabled}"
if [ "$NOTES_PREV_MONTH" = '12' ]; then
  NOTES_PREV_FILE="${NOTES_PREV_FILE:-$NOTES_SERVER_DIRECTORY/$NOTES_PREV_YEAR/$NOTES_PREV_MONTH.txt}"
else
  NOTES_PREV_FILE="${NOTES_PREV_FILE:-$NOTES_SERVER_DIRECTORY/$NOTES_FOLDER/$NOTES_PREV_MONTH.txt}"
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Generate config files
[ -f "$NOTES_CONFIG_DIR/$NOTES_CONFIG_FILE" ] || [ "$*" = "--config" ] || INIT_CONFIG="${INIT_CONFIG:-TRUE}" __gen_config ${SETARGS:-$@}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Import config
[ -f "$NOTES_CONFIG_DIR/$NOTES_CONFIG_FILE" ] && . "$NOTES_CONFIG_DIR/$NOTES_CONFIG_FILE"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Ensure Directories exist
[ -d "$NOTES_LOG_DIR" ] || mkdir -p "$NOTES_LOG_DIR" |& __devnull
[ -d "$NOTES_TEMP_DIR" ] || mkdir -p "$NOTES_TEMP_DIR" |& __devnull
[ -d "$NOTES_CACHE_DIR" ] || mkdir -p "$NOTES_CACHE_DIR" |& __devnull
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
NOTES_TEMP_FILE="${NOTES_TEMP_FILE:-$(mktemp $NOTES_TEMP_DIR/XXXXXX 2>/dev/null)}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup trap to remove temp file
trap '__trap_exit' EXIT
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup notification function
__notifications() {
  __cmd_exists notifications || return
  [ "$NOTES_NOTIFY_ENABLED" = "yes" ] || return
  [ "$SEND_NOTIFICATION" = "no" ] && return
  (
    export SCRIPT_OPTS="" _DEBUG=""
    export NOTIFY_GOOD_MESSAGE="${NOTIFY_GOOD_MESSAGE:-$NOTES_GOOD_MESSAGE}"
    export NOTIFY_ERROR_MESSAGE="${NOTIFY_ERROR_MESSAGE:-$NOTES_ERROR_MESSAGE}"
    export NOTIFY_CLIENT_ICON="${NOTIFY_CLIENT_ICON:-$NOTES_NOTIFY_CLIENT_ICON}"
    export NOTIFY_CLIENT_NAME="${NOTIFY_CLIENT_NAME:-$NOTES_NOTIFY_CLIENT_NAME}"
    export NOTIFY_CLIENT_URGENCY="${NOTIFY_CLIENT_URGENCY:-$NOTES_NOTIFY_CLIENT_URGENCY}"
    notifications "$@"
  ) |& __devnull &
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set custom actions

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Argument/Option settings
SETARGS=("$@")
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
SHORTOPTS=""
SHORTOPTS+=""
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
LONGOPTS="completions:,config,debug,dir:,help,options,raw,version,silent"
LONGOPTS+=",import,nogit,kill"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
ARRAY=""
ARRAY+=""
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
LIST=""
LIST+=""
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup application options
setopts=$(getopt -o "$SHORTOPTS" --long "$LONGOPTS" -n "$APPNAME" -- "$@" 2>/dev/null)
eval set -- "${setopts[@]}" 2>/dev/null
while :; do
  case "$1" in
  --raw)
    shift 1
    export SHOW_RAW="true"
    NC=""
    RESET=""
    BLACK=""
    RED=""
    GREEN=""
    YELLOW=""
    BLUE=""
    PURPLE=""
    CYAN=""
    WHITE=""
    ORANGE=""
    LIGHTRED=""
    BG_GREEN=""
    BG_RED=""
    ICON_INFO="[ info ]"
    ICON_GOOD="[ ok ]"
    ICON_WARN="[ warn ]"
    ICON_ERROR="[ error ]"
    ICON_QUESTION="[ ? ]"
    printf_column() { tee | grep '^'; }
    printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
    ;;
  --debug)
    shift 1
    set -xo pipefail
    export SCRIPT_OPTS="--debug"
    export _DEBUG="on"
    __devnull() { tee || return 1; }
    __devnull2() { eval "$@" |& tee -p || return 1; }
    ;;
  --completions)
    if [ "$2" = "short" ]; then
      printf '%s\n' "-$SHORTOPTS" | sed 's|"||g;s|:||g;s|,|,-|g' | tr ',' '\n'
    elif [ "$2" = "long" ]; then
      printf '%s\n' "--$LONGOPTS" | sed 's|"||g;s|:||g;s|,|,--|g' | tr ',' '\n'
    elif [ "$2" = "array" ]; then
      printf '%s\n' "$ARRAY" | sed 's|"||g;s|:||g' | tr ',' '\n'
    elif [ "$2" = "list" ]; then
      printf '%s\n' "$LIST" | sed 's|"||g;s|:||g' | tr ',' '\n'
    else
      exit 1
    fi
    shift 2
    exit $?
    ;;
  --options)
    shift 1
    printf_blue "Current options for ${PROG:-$APPNAME}"
    [ -z "$SHORTOPTS" ] || __list_options "Short Options" "-${SHORTOPTS}" ',' '-' 4
    [ -z "$LONGOPTS" ] || __list_options "Long Options" "--${LONGOPTS}" ',' '--' 4
    [ -z "$ARRAY" ] || __list_options "Base Options" "${ARRAY}" ',' '' 4
    [ -z "$LIST" ] || __list_options "LIST Options" "${LIST}" ',' '' 4
    exit $?
    ;;
  --version)
    shift 1
    __version
    exit $?
    ;;
  --help)
    shift 1
    __help
    exit $?
    ;;
  --config)
    shift 1
    __gen_config
    exit $?
    ;;
  --silent)
    shift 1
    NOTES_SILENT="true"
    ;;
  --dir)
    CWD_IS_SET="TRUE"
    NOTES_CWD="$2"
    [ -d "$NOTES_CWD" ] || mkdir -p "$NOTES_CWD" |& __devnull
    shift 2
    ;;
  --import)
    shift 1
    __import "$NOTES_PREV_FILE"
    exit $?
    ;;
  --nogit)
    shift 1
    NOTES_GIT_ENABLED="disabled"
    ;;
  --kill)
    shift 1
    __kill_server
    ;;
  --)
    shift 1
    break
    ;;
  esac
done
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Get directory from args
# set -- "$@"
# for arg in "$@"; do
# if [ -d "$arg" ]; then
# NOTES_CWD="$arg" && shift 1 && SET_NEW_ARGS=("$@") && break
# elif [ -f "$arg" ]; then
# NOTES_CWD="$(dirname "$arg" 2>/dev/null)" && shift 1 && SET_NEW_ARGS=("$@") && break
# else
# SET_NEW_ARGS+=("$arg")
# fi
# done
# set -- "${SET_NEW_ARGS[@]}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set directory to first argument
# [ -d "$1" ] && __is_an_option "$1" && NOTES_CWD="$1" && shift 1 || NOTES_CWD="${NOTES_CWD:-$PWD}"
NOTES_CWD="$(realpath "${NOTES_CWD:-$PWD}" 2>/dev/null)"
# if [ -d "$NOTES_CWD" ] && cd "$NOTES_CWD"; then
# if [ "$NOTES_SILENT" != "true" ] && [ "$CWD_SILENCE" != "true" ]; then
# printf_cyan "Setting working dir to $NOTES_CWD"
# fi
# else
# printf_exit "ðŸ’” $NOTES_CWD does not exist ðŸ’”"
# fi
export NOTES_CWD
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set actions based on variables

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for required applications/Network check
#requiresudo "$0" "$@" || exit 2     # exit 2 if errors
#cmd_exists --error --ask bash || exit 3 # exit 3 if not found
#am_i_online --error || exit 4           # exit 4 if no internet
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# APP Variables overrides

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions based on env
__initialize_app
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute functions

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute commands

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# begin main app
case "${1:-$OPTS}" in
server | service)
  shift 1
  if [ "$1" = "help" ]; then shift 1 && printf_help 'Usage: notes server  |  Start the server'; fi
  if [ "$1" = "status" ]; then
    shift 1
    if netstatg "$NOTES_SERVER_PORT" &>/dev/null; then
      printf_green "The server is up and running on $NOTES_SERVER_PORT"
      __notifications "NoteServer" "The server is up and running on $NOTES_SERVER_PORT"
    else printf_exit 1 1 "$ICON_ERROR The notes server is not running"; fi
    exit $?
  fi
  if [ "$1" = "kill" ]; then
    __kill_server
    exit $?
  fi

  case "$2" in # begin systemd 2 deep
  systemd)
    shift 1
    case $2 in
    install)
      shift 2
      NOTES_HOME="$NOTES_SERVER_DIRECTORY"
      systemd_service "/etc/systemd/system/notes_server.service" &&
        __devnull sudo systemctl daemon-reload &&
        __devnull sudo systemctl start notes_server &&
        __devnull sudo systemctl enable -f notes_server && printf_green "Service has been created" || printf_red "Failed to create service"
      ;;
    remove)
      shift 2
      __system_service_exists notes_server.service || printf_exit 1 0 "Notes server is not installed"
      __devnull sudo systemctl disable -f notes_server &&
        __devnull sudo systemctl daemon-reload &&
        __rm_rf /etc/systemd/system/notes_server.service && printf_green "Service has been deleted" || printf_red "Failed to delete service"
      ;;
    start)
      shift 2
      __system_service_exists notes_server.service || printf_exit 2 0 "Notes server is not installed"
      __devnull sudo systemctl start notes_server && printf_green "Service has been started" || printf_red "Failed to start service"
      ;;
    stop)
      shift 2
      __system_service_exists notes_server.service || printf_exit 2 0 "Notes server is not installed"
      __devnull sudo systemctl stop notes_server && printf_green "Service has been stopped" || printf_red "Failed to stop service"
      ;;
    restart)
      shift 2
      __system_service_exists notes_server.service || printf_exit 2 0 "Notes server is not installed"
      __devnull sudo systemctl restart notes_server && printf_green "Service has been restarted" || printf_red "Failed to restart service"
      ;;
    run) # SystemD run
      case $3 in
      *vars)
        shift 3
        __system_service_exists notes_server.service && printf_exit 2 0 "Notes server is not installed"
        export NOTES_NOTIFY_ENABLED NOTES_FOLDER NOTES_FILE NOTES_TEMP_DIR NOTES_HOME NOTES_EDITOR NOTES_PATH
        export NOTES_SERVER_NAME NOTES_SERVER_PORT NOTES_SERVER_DIRECTORY NOTES_LOG_FILE NOTES_TEMP_FILE NOTES_SERVER_PATH
        ;;
      stop)
        shift 3
        __system_service_exists notes_server.service && printf_exit 2 0 "Notes server is not installed"
        touch "$NOTES_TEMP_DIR/kill_notes"
        __netcat_kill_server "$NOTES_SERVER_PORT"
        ;;
      start)
        shift 3
        __system_service_exists notes_server.service && printf_exit 2 0 "Notes server is not installed"
        if [ "$1" = "loop" ]; then
          shift 1
          NOTES_SERVER_LOOP="yes"
        fi
        opts="$*"
        __run_service "$opts" 2>>"$NOTES_LOG_FILE"
        ;;
      restart)
        __system_service_exists notes_server.service && printf_exit 2 0 "Notes server is not installed"
        shift 3
        opts="$*"
        touch "$NOTES_TEMP_DIR/kill_notes"
        __netcat_kill_server "$NOTES_SERVER_PORT"
        __run_service "$opts" 2>>"$NOTES_LOG_FILE"
        ;;
      *)
        __system_service_exists notes_server.service && printf_exit 2 0 "Notes server is not installed"
        shift 2
        opts="$*"
        __run_service "$opts" 2>>"$NOTES_LOG_FILE"
        ;;
      esac
      ;;
    status | *)
      shift 2
      __system_service_exists notes_server.service || printf_exit 2 0 "Notes server is not installed"
      sudo systemctl status notes_server | printf_readline "$NOTES_OUTPUT_COLOR_1"
      ;;
    esac
    ;;
  # End Systemd

  start)
    shift 2
    if [ "$1" = "loop" ]; then
      NOTES_SERVER_LOOP=yes
      __notifications "Notes Server" "Launching server on port $NOTES_SERVER_PORT"
      shift 1
    else
      printf_green "Starting notes server for $USER"
      printf_newline
    fi
    __server "$@" &>/dev/null
    sleep 3
    ;;

  enable)
    shift 2
    __server_enable
    ;;

  disable)
    shift 2
    __server_disable
    ;;

  edit)
    shift 2
    if [ "$1" = "prev" ]; then
      ssh -qt "$NOTES_SERVER_NAME" notes open "$NOTES_PREV_FILE"
    elif [ "$1" = "all" ]; then
      ssh -qt "$NOTES_SERVER_NAME" notes all
    else ssh -qt "$NOTES_SERVER_NAME" notes; fi
    __run_sync
    exit ${exitCode:-0}
    ;;

  *)
    shift 1
    opts="$*"
    __server "$opts" 2>>"$NOTES_LOG_FILE"
    ;;
  esac
  ;;

client)
  shift 1
  [ "$1" = "help" ] && printf_help 'Usage: notes client "my message"  |  Send your notes to the server'
  [ -n "$NOTES_SERVER_NAME" ] || printf_help "Please set NOTES_SERVER_NAME variable to your server"
  if [ ${#} -eq 0 ]; then
    if [ $# -eq 0 ] && [ -p "/dev/stdin" ]; then
      message="$(cat -)"
    fi
  else
    message="$*"
  fi
  __client "$message" 2>/dev/null
  ;;

all)
  shift 1
  __sync_all "${NOTES_PATH}" "${NOTES_HOME}/all.txt"
  __notes "${NOTES_HOME}/all.txt"
  __run_sync
  exit ${exitCode:-0}
  exit $?
  ;;

sync)
  shift 1
  [ "$1" = show ] && show=true && shift 1 || show=""
  [ "$1" = all ] && all="true" && shift 1 || all=""
  __sync_all "${NOTES_PATH}" "${NOTES_HOME}/all.txt"
  __run_sync
  exit ${exitCode:-0}
  exit $?
  ;;

show)
  shift 1
  if [ -f "$NOTES_PATH" ]; then
    MESSAGE="$(grep -sh '^## ' "$NOTES_PATH" | sed 's|^## ||g;s| ##$||g' | grep -v '$^' | grep '^' || echo 'Found the the following notes')"
    printf '\n'
    printf_yellow "${MESSAGE}"
    grep -vs '^## ' "$NOTES_PATH" 2>/dev/null | printf_readline "$NOTES_OUTPUT_COLOR_2"
    printf '\n'
  else
    printf_exit ""
  fi
  ;;

list)
  shift 1
  __list_all
  exit $?
  ;;

search)
  shift 1
  search_results="$(cat "$NOTES_HOME/all.txt" "$NOTES_PREV_FILE" "$NOTES_PATH" | grep -shi "$1" 2>/dev/null)"
  if [ -n "$search_results" ]; then
    printf_green "Search results: "
    echo "$search_results" | printf_readline "$NOTES_OUTPUT_COLOR_2"
    exitCode=0
  else
    printf_red "No results found"
    exitCode=1
  fi
  exit $exitCode
  ;;

open)
  shift 1
  if [ "$1" = list ] || [ $# = 0 ]; then
    __list_all
  else
    if [[ "$1" = */all* ]] || [ "$1" = "$NOTES_HOME/all.txt" ] || [ "$1" = all ]; then
      filename="$NOTES_HOME/all.txt"
    elif [ "$1" = prev ]; then
      filename="$NOTES_PREV_FILE"
    elif [ "$1" = cur ]; then
      filename="$NOTES_PATH"
    else
      filepath="$(__get_full_file "$1")"
      filename="$NOTES_HOME/${1//$NOTES_HOME/$filename}"
    fi
    __notes "$filename" 2>/dev/null
  fi
  __run_sync
  exit ${exitCode:-0}
  ;;

stdin | -)
  shift 1
  if [ ${#} -eq 0 ]; then
    if [ $# -eq 0 ] && [ -p "/dev/stdin" ]; then
      message="$(</dev/stdin)"
      __update_notes "$message" "${NOTES_PATH}"
    else
      echo "Type your note, hit control-d when done"
      message="$(</dev/stdin)"
      __update_notes "$message" "${NOTES_PATH}"
    fi
  else
    message="$*"
    __update_notes "$message" "${NOTES_PATH}"
  fi
  __run_sync
  exit ${exitCode:-0}
  ;;

*)
  if [ ${#} -eq 0 ]; then
    # if [ $# -eq 0 ] && [ -p "/dev/stdin" ]; then
    # message="$(</dev/stdin)"
    # __update_notes "$message" "${NOTES_PATH}"
    # else
    __notes
    # fi
  else
    message="$*"
    __update_notes "$message" "${NOTES_PATH}"
  fi
  __run_sync
  exit ${exitCode:-0}
  ;;
esac
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set exit code
exitCode="${exitCode:-0}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# End application
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# lets exit with code
exit ${exitCode:-0}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# ex: ts=2 sw=2 et filetype=sh
