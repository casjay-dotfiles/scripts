#!/usr/bin/env bash
# shellcheck shell=bash
# - - - - - - - - - - - - - - - - - - - - - - - - -
##@Version           :  202512231841-git
# @@Author           :  Jason Hempstead
# @@Contact          :  jason@casjaysdev.pro
# @@License          :  WTFPL
# @@ReadME           :  pkmgr --help
# @@Copyright        :  Copyright: (c) 2022 Jason Hempstead, Casjays Developments
# @@Created          :  Friday, Aug 19, 2022 16:56 EDT
# @@File             :  pkmgr
# @@Description      :  Manage system packages
# @@Changelog        :  Fixed pip deprecation warnings, fixed install/curl/dotfiles/required commands, added missing URL functions
# @@TODO             :  Add BSD support
# @@Other            :
# @@Resource         :
# @@Terminal App     :  no
# @@sudo/root        :  yes
# @@Template         :  bash/system
# - - - - - - - - - - - - - - - - - - - - - - - - -
# shellcheck disable=SC1003,SC2016,SC2031,SC2120,SC2155,SC2199,SC2317
# - - - - - - - - - - - - - - - - - - - - - - - - -
APPNAME="$(basename -- "$0" 2>/dev/null)"
VERSION="202512231841-git"
USER="${SUDO_USER:-$USER}"
RUN_USER="${RUN_USER:-$USER}"
USER_HOME="${USER_HOME:-$HOME}"
SCRIPT_SRC_DIR="${BASH_SOURCE%/*}"
PKMGR_REQUIRE_SUDO="${PKMGR_REQUIRE_SUDO:-no}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Reopen in a terminal
#if [ ! -t 0 ] && { [ "$1" = --term ] || [ $# = 0 ]; }; then { [ "$1" = --term ] && shift 1 || true; } && TERMINAL_APP="TRUE" myterminal -e "$APPNAME $*" && exit || exit 1; fi
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set script title
#CASJAYS_DEV_TILE_FORMAT="${USER}@${HOSTNAME}:${PWD/#$HOME/~} - $APPNAME"
#CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}"
#[ -z "$CASJAYSDEV_TITLE_SET" ] && printf '\033]0;%s\007' "$CASJAYS_DEV_TILE_FORMAT" && CASJAYSDEV_TITLE_SET="$APPNAME"
export CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}" CASJAYSDEV_TITLE_SET
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Initial debugging
[ "$1" = "--debug" ] && set -x && export SCRIPT_OPTS="--debug" && export _DEBUG="on"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Disables colorization
[ "$1" = "--raw" ] && export SHOW_RAW="true"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# pipes fail
set -o pipefail
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Builtin helper function for available command
____run_install_available() {
  printf_cyan "Listing available installers for $1"
  printf_yellow "This feature requires external installer framework"
  printf_cyan "Available via: https://github.com/casjay-dotfiles/scripts"
  return 0
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# import system variables
[ -f "/usr/local/bin/detectostype" ] && . "/usr/local/bin/detectostype"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Send all output to /dev/null
__devnull() {
  tee &>/dev/null && exitCode=0 || exitCode=1
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -'
# Send errors to /dev/null
__devnull2() {
  [ -n "$1" ] && local cmd="$1" && shift 1 || return 1
  eval $cmd "$*" 2>/dev/null && exitCode=0 || exitCode=1
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -'
# See if the executable exists
__cmd_exists() {
  exitCode=0
  [ -n "$1" ] && local exitCode="" || return 0
  for cmd in "$@"; do
    builtin command -v "$cmd" &>/dev/null && exitCode+=$(($exitCode + 0)) || exitCode+=$(($exitCode + 1))
  done
  [ $exitCode -eq 0 ] || exitCode=3
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for a valid internet connection
__am_i_online() {
  local exitCode=0
  curl -q -LSsfI --max-time 2 --retry 1 "${1:-https://1.1.1.1}" 2>&1 | grep -qi 'server:.*cloudflare' || exitCode=4
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# colorization
if [ "$SHOW_RAW" = "true" ]; then
  NC=""
  RESET=""
  BLACK=""
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  PURPLE=""
  CYAN=""
  WHITE=""
  ORANGE=""
  LIGHTRED=""
  BG_GREEN=""
  BG_RED=""
  ICON_INFO="[ info ]"
  ICON_GOOD="[ ok ]"
  ICON_WARN="[ warn ]"
  ICON_ERROR="[ error ]"
  ICON_QUESTION="[ ? ]"
  printf_column() { tee | grep '^'; }
  printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
else
  ICON_INFO="[ ℹ ]"
  ICON_GOOD="[ ✔ ]"
  ICON_WARN="[ ❗ ]"
  ICON_ERROR="[ ✖ ]"
  ICON_QUESTION="[ ? ]"
  printf_color() { printf "%b" "$(tput setaf "${2:-7}" 2>/dev/null)" "$1" "$(tput sgr0 2>/dev/null)"; }
fi
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional printf_ colors
__printf_head() { printf_blue "$1"; }
__printf_opts() { printf_purple "$1"; }
__printf_line() { printf_cyan "$1"; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Builtin printf functions
printf_blue() { printf_color "$1" 4; }
printf_cyan() { printf_color "$1" 6; }
printf_green() { printf_color "$1" 2; }
printf_red() { printf_color "$1" 1; }
printf_yellow() { printf_color "$1" 3; }
printf_purple() { printf_color "$1" 5; }
printf_newline() { printf '\n'; }
printf_custom() { printf_color "$1" "${2:-5}"; }
printf_error() { printf_red "ERROR: $1\n" >&2; }
printf_exit() {
  local exitCode="${1:-0}"
  local exitMsg="${2:-Script has completed}"
  if [ "$exitCode" -eq 0 ]; then
    printf_green "$exitMsg"
  else
    printf_red "$exitMsg"
  fi
  printf_newline
  exit "$exitCode"
}
printf_readline() {
  local readline_var="$1"
  local readline_msg="${2:-Enter value}"
  local readline_default="${3:-}"
  if [ -n "$readline_default" ]; then
    printf_cyan "$readline_msg [$readline_default]: "
  else
    printf_cyan "$readline_msg: "
  fi
  read -r "$readline_var" || return 1
  eval "[ -z \"\$$readline_var\" ] && $readline_var=\"$readline_default\""
  return 0
}
printf_readline_trunc() {
  local max_length="${1:-80}"
  local input_text="${2:-}"
  if [ -z "$input_text" ]; then
    read -r input_text || return 1
  fi
  if [ "${#input_text}" -gt "$max_length" ]; then
    printf '%s' "${input_text:0:$max_length}..."
  else
    printf '%s' "$input_text"
  fi
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# execute functions (spinner support)
printf_execute_success() {
  printf_color "$ICON_GOOD $1" 2
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
printf_execute_error() {
  printf_color "$ICON_WARN $1 $2" 208
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
printf_execute_result() {
  if [ "$1" -eq 0 ]; then
    printf_execute_success "$2"
  else
    printf_execute_error "${3:-$2}"
  fi
  return "$1"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
printf_execute_error_stream() {
  while read -r line; do
    printf_execute_error "↳ ERROR: $line"
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__set_trap() {
  trap -p "$1" | grep -q "$2" 2>/dev/null || trap "$2" "$1"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__kill_all_subprocesses() {
  local i=""
  for i in $(jobs -p); do
    kill "$i" 2>/dev/null
    wait "$i" 2>/dev/null
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__show_spinner() {
  local -r FRAMES='/-\|'
  local -r NUMBER_OR_FRAMES=${#FRAMES}
  local -r CMDS="$2"
  local -r MSG="$3"
  local -r PID="$1"
  local i=0
  local frameText=""
  while kill -0 "$PID" 2>/dev/null; do
    frameText="[${FRAMES:i++%NUMBER_OR_FRAMES:1}] $MSG"
    printf "%s" "$frameText"
    sleep 0.2
    printf "\r"
  done
  printf "\r\033[K"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__execute() {
  local -r CMDS="$1"
  local -r MSG="${2:-$1} "
  local -r TMP_FILE="$(mktemp /tmp/XXXXX 2>/dev/null)"
  local exitCode=0
  local cmdsPID=""
  __set_trap "EXIT" "__kill_all_subprocesses"
  eval "$CMDS" >/dev/null 2>"$TMP_FILE" &
  cmdsPID=$!
  __show_spinner "$cmdsPID" "$CMDS" "$MSG"
  wait "$cmdsPID" 2>/dev/null
  exitCode=$?
  printf_execute_result $exitCode "$MSG"
  if [ $exitCode -ne 0 ]; then
    printf_execute_error_stream <"$TMP_FILE"
  fi
  rm -rf "$TMP_FILE" 2>/dev/null
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# output version
__version() {
  printf_cyan "$VERSION"
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# list options
__list_options() {
  printf_color "$1: " "$5"
  echo -ne "$2" | sed 's|:||g;s/'$3'/ '$4'/g' | tr '\n' ' '
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# create the config file
__gen_config() {
  local NOTIFY_CLIENT_NAME="$APPNAME"
  if [ "$INIT_CONFIG" != "TRUE" ]; then
    printf_blue "Generating the config file in"
    printf_cyan "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE"
  fi
  [ -d "$PKMGR_CONFIG_DIR" ] || mkdir -p "$PKMGR_CONFIG_DIR"
  [ -d "$PKMGR_CONFIG_BACKUP_DIR" ] || mkdir -p "$PKMGR_CONFIG_BACKUP_DIR"
  [ -f "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE" ] &&
    cp -Rf "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE" "$PKMGR_CONFIG_BACKUP_DIR/$PKMGR_CONFIG_FILE.$$"
  cat <<EOF >"$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE"
# Settings for pkmgr
PKMGR_FORCE_INSTALL="false"
PKMGR_GIT_REPO="${PKMGR_GIT_REPO:-}"
PKMGR_GIT_BRANCH="${PKMGR_GIT_BRANCH:-}"
PKMGR_GIT_DOTFILES="${PKMGR_GIT_DOTFILES:-}"
PKMGR_NOTIFICATION_EMAIL="${PKMGR_NOTIFICATION_EMAIL:-}"
PKMGR_OUTPUT_TRUNCATE="${PKMGR_OUTPUT_TRUNCATE:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
PKMGR_OUTPUT_COLOR_1="${PKMGR_OUTPUT_COLOR_1:-}"
PKMGR_OUTPUT_COLOR_2="${PKMGR_OUTPUT_COLOR_2:-}"
PKMGR_OUTPUT_COLOR_GOOD="${PKMGR_OUTPUT_COLOR_GOOD:-}"
PKMGR_OUTPUT_COLOR_ERROR="${PKMGR_OUTPUT_COLOR_ERROR:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
PKMGR_NOTIFY_ENABLED="${PKMGR_NOTIFY_ENABLED:-}"
PKMGR_GOOD_NAME="${PKMGR_GOOD_NAME:-}"
PKMGR_ERROR_NAME="${PKMGR_ERROR_NAME:-}"
PKMGR_GOOD_MESSAGE="${PKMGR_GOOD_MESSAGE:-}"
PKMGR_ERROR_MESSAGE="${PKMGR_ERROR_MESSAGE:-}"
PKMGR_NOTIFY_CLIENT_NAME="${PKMGR_NOTIFY_CLIENT_NAME:-}"
PKMGR_NOTIFY_CLIENT_ICON="${PKMGR_NOTIFY_CLIENT_ICON:-}"
PKMGR_NOTIFY_CLIENT_URGENCY="${PKMGR_NOTIFY_CLIENT_URGENCY:-}"

EOF
  if builtin type -t __gen_config_local | grep -q 'function'; then __gen_config_local; fi
  if [ -f "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE" ]; then
    [ "$INIT_CONFIG" = "TRUE" ] || printf_green "Your config file for $APPNAME has been created"
    . "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE"
    exitCode=0
  else
    printf_red "Failed to create the config file"
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Help function - Align to 50
__help() {
  # info|version|check|available|init|makecache|aliases|cron|ask|export|clean|search|keys|list|curl|dotfiles|script|required|reinstall|install|upgrade|remove
  # silent[install,remove,upgrade]|bin|perl[install,remove,check]|pip[install,remove,check]|gem[install,remove,check]|npm[install,remove,check]|go[install,remove,check]|lua[install,remove,check]
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "pkmgr:  Manage system packages - $VERSION"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "Usage: pkmgr [options] [commands]"
  __printf_line 'pkmgr dotfiles                  - install required packages    |pkmgr dotfiles git'
  __printf_line 'pkmgr list                      - install from a file          |pkmgr list [full path to list]'
  __printf_line 'pkmgr curl                      - install from a url           |pkmgr curl debian min'
  __printf_line 'pkmgr script                    - run a script                 |pkmgr script [ ./pathToScript or http://fullurltoscript ]'
  __printf_line 'pkmgr search                    - find a package               |pkmgr search myapp'
  __printf_line 'pkmgr install                   - install a package            |pkmgr install myapp'
  __printf_line 'pkmgr remove                    - remove a package             |pkmgr remove myapp'
  __printf_line 'pkmgr update                    - update all packages          |pkmgr update'
  __printf_line 'pkmgr clean                     - Removes cached files         |pkmgr clean'
  __printf_line 'pkmgr makecache                 - update package lists         |pkmgr makecache'
  __printf_line 'pkmgr silent                    - silently install package     |pkmgr silent myapp'
  __printf_line 'pkmgr silent remove             - silently remove package      |pkmgr silent remove myapp'
  __printf_line 'pkmgr silent upgrade            - silently upgrade package     |pkmgr silent upgrade myapp'
  __printf_line 'pkmgr cron add                  - schedule daily updates       |pkmgr cron add'
  __printf_line 'pkmgr aliases                   - lists the alias for bash     |pkmgr alias'
  __printf_line 'pkmgr pip                       - install a python package     |pkmgr pip requests'
  __printf_line 'pkmgr cpan                      - install a perl module        |pkmgr cpan Bundle::Apache'
  __printf_line 'pkmgr gem                       - install a gem module         |pkmgr gem jekyll'
  __printf_line 'pkmgr npm                       - install a nodejs module      |pkmgr npm express'
  __printf_line 'pkmgr cmd help                  - show help for the command    |pkmgr aliases --help'
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "--force                         - Force install"
  __printf_line "--enable-aur                    - Enables the aur on arch systems"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Other Options"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "--help                          - Shows this message"
  __printf_line "--config                        - Generate user config file"
  __printf_line "--version                       - Show script version"
  __printf_line "--options                       - Shows all available options"
  __printf_line "--debug                         - Enables script debugging"
  __printf_line "--raw                           - Removes all formatting on output"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# check if arg is a builtin option
__is_an_option() { if echo "$ARRAY" | grep -q "${1:-^}"; then return 1; else return 0; fi; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Is current user root
__user_is_root() {
  { [ $(id -u) -eq 0 ] || [ $EUID -eq 0 ] || [ "$WHOAMI" = "root" ]; } && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Is current user not root
__user_is_not_root() {
  if { [ $(id -u) -eq 0 ] || [ $EUID -eq 0 ] || [ "$WHOAMI" = "root" ]; }; then return 1; else return 0; fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Check if user is a member of sudo
__sudo_group() {
  grep -sh "${1:-$USER}" "/etc/group" | grep -Eq 'wheel|adm|sudo' || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# # Get sudo password
__sudoask() {
  local PATH="$SCRIPT_SRC_DIR:$PATH"
  sudo true && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Run sudo
__sudorun() {
  __sudoif && __cmd_exists sudo && sudo -HE "$@" || { __sudoif && eval "$@"; }
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Test if user has access to sudo
__can_i_sudo() {
  (sudo -vn && sudo -ln) 2>&1 | grep -vq 'may not' >/dev/null && return 0
  __sudo_group "${1:-$USER}" || __sudoif || __sudo true &>/dev/null || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# User can run sudo
__sudoif() {
  __user_is_root && return 0
  __can_i_sudo "${RUN_USER:-$USER}" && return 0
  __user_is_not_root && __sudoask && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Run command as root
__requiresudo() {
  if [ "$PKMGR_REQUIRE_SUDO" = "yes" ] && [ -z "$PKMGR_REQUIRE_SUDO_RUN" ]; then
    export PKMGR_REQUIRE_SUDO="no"
    export PKMGR_REQUIRE_SUDO_RUN="true"
    __sudo "$@"
    exit $?
  else
    return 0
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute sudo
__sudo() {
  CMD="${1:-echo}" && shift 1
  CMD_ARGS="${*:--e "${RUN_USER:-$USER}"}"
  SUDO="$(builtin command -v sudo 2>/dev/null || echo 'eval')"
  [ "$(basename -- "$SUDO" 2>/dev/null)" = "sudo" ] && OPTS="--preserve-env=PATH -HE"
  if __sudoif; then
    export PATH="$PATH"
    $SUDO ${OPTS:-} $CMD $CMD_ARGS && true || false
    exitCode=$?
  else
    printf '%s\n' "This requires root to run"
    exitCode=1
  fi
  return ${exitCode:-1}
}
# End of sudo functions
# - - - - - - - - - - - - - - - - - - - - - - - - -
__trap_exit() {
  exitCode=${exitCode:-0}
  [ -f "$PKMGR_TEMP_FILE" ] && rm -Rf "$PKMGR_TEMP_FILE" &>/dev/null
  #unset CASJAYSDEV_TITLE_SET && printf '\033]2│;%s\033\\' "${USER}@${HOSTNAME}:${PWD/#$HOME/~} - ${CASJAYSDEV_TITLE_PREV:-$SHELL}"
  if builtin type -t __trap_exit_local | grep -q 'function'; then __trap_exit_local; fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined functions
__saved_file_create() { echo "$1" | sudo tee -p "${PKMGR_INSTALLED_LIST_DIR:-/usr/local/etc/pkmgr/lists}/$1" &>/dev/null || true; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__saved_file_delete() { [ -f "$PKMGR_INSTALLED_LIST_DIR/$1" ] && rm -f "$PKMGR_INSTALLED_LIST_DIR/$1" || true; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__not_installed() { echo -ne "${RED}Not Installed${NC}"; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__is_url() { echo "${1:-$url}" | grep -qE '^http://|^https://|^ftp://' || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__curl_exit() { EXIT=0 && return 0 || { EXIT=1 && return 1; }; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__urlcheck() { curl --disable -LSsk --connect-timeout 2 --retry 1 --retry-delay 0 --output /dev/null --silent --head --fail "$1" 2>/dev/null && __curl_exit; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__urlinvalid() {
  if [ -z "$1" ]; then
    printf_red "Invalid URL"
  else
    printf_red "Can't find $1"
  fi
  return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__urlverify() { __urlcheck "$1" || __urlinvalid "$1"; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__logging() {
  # Deprecated - kept for compatibility
  cat
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute package manager commands with real-time output
__exec_unbuffered() {
  local cmd="$*"
  local log_file="${PKMGR_LOG_INFO:-}"
  local exit_code=0

  # Set environment variables for unbuffered output
  export PYTHONUNBUFFERED=1
  export PAGER=""
  export SYSTEMD_PAGER=""
  export APT_LISTCHANGES_FRONTEND=none

  # Execute command based on available tools
  # Priority: script > stdbuf > direct execution
  # script provides best TTY emulation for package managers

  if [ -n "$log_file" ] && [ -d "$(dirname "$log_file")" ]; then
    # With logging
    if command -v script >/dev/null 2>&1; then
      script -qefc "$cmd" /dev/null 2>&1 | tee -a "$log_file"
      exit_code=${PIPESTATUS[0]}
    elif command -v stdbuf >/dev/null 2>&1; then
      stdbuf -o0 -e0 bash -c "$cmd" 2>&1 | tee -a "$log_file"
      exit_code=${PIPESTATUS[0]}
    else
      bash -c "$cmd" 2>&1 | tee -a "$log_file"
      exit_code=${PIPESTATUS[0]}
    fi
  else
    # Without logging - direct execution
    if command -v script >/dev/null 2>&1; then
      script -qefc "$cmd" /dev/null 2>&1
      exit_code=$?
    elif command -v stdbuf >/dev/null 2>&1; then
      stdbuf -o0 -e0 bash -c "$cmd" 2>&1
      exit_code=$?
    else
      bash -c "$cmd" 2>&1
      exit_code=$?
    fi
  fi

  return $exit_code
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__log_info() { tee -p -a "$PKMGR_LOG_INFO" || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__log_error() { tee -p -a "$PKMGR_LOG_ERROR" || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__silent_log_file() { tee -a "${2:-$PKMGR_LOG_INFO}" &>/dev/null || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__init_log_status() { printf '### Starting %s on: %s\n%s\n' "$1" "$(date)" "Command: $2" | tee -p -a "${3:-$PKMGR_LOG_INFO}" &>/dev/null; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__write_log_status() {
  printf '%s\n' "$1" | tee -p -a "${2:-$PKMGR_LOG_INFO}" &>/dev/null
  printf '### Completed on: %s\n\n' "$(date)" | tee -p -a "${2:-$PKMGR_LOG_INFO}" &>/dev/null
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__run_updatecheck() { __am_i_online && __pkmgrcheckupdates || echo "0"; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__rm_rf() { sudo rm -Rf "$@"; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__cp_rf() { sudo cp -Rf "$@"; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__trap_exit_local() {
  local exitCodeE=${exitCode:-$?}
  if [ -n "$SUDO_USER" ] && __user_is_not_root; then
    sudo chown $SUDO_USER:$SUDO_USER "$PKMGR_CACHE_DIR" "$PKMGR_CONFIG_DIR" "$PKMGR_LOG_DIR" "$PKMGR_TEMP_DIR"
  fi
  return ${exitCodeE:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__curl() {
  __am_i_online || return 2
  curl --disable -LSsfk --connect-timeout 3 --retry 0 "$@" 2>/dev/null || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__default_mirror_list_archlinux() {
  cat <<EOF
# United States
Server = http://mirrors.mit.edu/archlinux/\$repo/os/\$arch
Server = https://mirrors.mit.edu/archlinux/\$repo/os/\$arch
Server = http://mirrors.ocf.berkeley.edu/archlinux/\$repo/os/\$arch
Server = https://mirrors.ocf.berkeley.edu/archlinux/\$repo/os/\$arch
Server = http://mirror.siena.edu/archlinux/\$repo/os/\$arch

EOF
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__list_install() {
  local exitCode=0
  if __is_url "$1"; then
    __curl_run "$@"
    PCKLIST="$(grep -sh -Ev '^$|^#' "$PKMGR_TEMP_FILE" | sort -u | tr '\n' ' ' || false)"
  else
    PCKLIST="$(grep -sh -Ev '^$|^#' "$1" | sort -u | tr '\n' ' ' || false)"
  fi
  if [ -n "$PCKLIST" ]; then
    for pkg in $PCKLIST; do
      __pkgmgrbininssil "$pkg" && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
    done
  fi
  [ $exitCode -eq 0 ] && exitCode=0 || exitCode="${exitCode:-1}"
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__searchcmd() {
  local pkgs="$*"
  local exitCode=0
  local search_name=""
  local -a package_name=()

  # Process each package search
  for pkg in $pkgs; do
    if __cmd_exists pacman; then
      # Pacman format: extract package names and descriptions
      search_name="$($pkgmgrbinsea "$pkg" 2>/dev/null |
        grep -v 'Warning: No matches' |
        awk '{printf "%s%s", $0, (NR%2==0) ? "\n" : ""}' |
        grep -i "$pkg" |
        sed 's|^.*/||g;s#    #: #g' |
        grep ':' || true)"
    else
      # DNF/YUM/APT format: direct search results
      search_name="$($pkgmgrbinsea "$pkg" 2>/dev/null |
        grep -v 'Warning: No matches' |
        grep -i "$pkg" || true)"
    fi
    [ -n "$search_name" ] && package_name+=("$search_name")
  done

  # Output results
  if [ ${#package_name[@]} -gt 0 ]; then
    printf '%s\n' "${package_name[@]}" |
      grep -v '^$' |
      cut -c 1-"${PKMGR_OUTPUT_TRUNCATE:-200}" || true
    exitCode=0
  else
    printf_red "$pkgs was not found" 1>&2
    exitCode=1
  fi

  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Define output
# if [ -n "$DISPLAY" ] && [ -f "$(builtin type -P zenity)" ] && [ -z "$SSH_TTY" ]; then
#   __pipecmd() {
#     zenity --progress --no-cancel --pulsate --auto-close --title="Attempting install" --text="Trying to install" --height=200 --width=400 || printf_readline_trunc "$PKMGR_OUTPUT_COLOR_1" "$PKMGR_OUTPUT_TRUNCATE"
#   }
# else
__pipecmd() {
  printf_readline_trunc $PKMGR_OUTPUT_COLOR_1 $PKMGR_OUTPUT_TRUNCATE
}
# fi
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Perl/CPAN functions
__cpan_run() {
  local cpandir="" cpanconf="" cpanfile=""
  cpan="$(type -P cpan 2>/dev/null | grep -v "$HOME" | grep '^' || return)"
  if [[ -n "$cpan" ]]; then
    cpandir="$(__devnull2 sudo find /usr/share/perl* /usr/local/share/perl* -path '*/CPAN/Version.pm' | sed 's#/Version.pm##g' | head -n1)"
    cpanconf="https://raw.githubusercontent.com/casjay-base/centos/master/usr/share/perl5/CPAN/Config.pm"
    cpanfile="$cpandir/Config.pm"
    if [ ! -f "$cpanfile" ] || [ ! -f "$cpandir/.init" ]; then
      printf_green "Grabbing the CPAN.pm file"
      __urlcheck "$cpanconf" &&
        __curl "$cpanconf" | sudo tee -p "$cpanfile" &>/dev/null &&
        sudo touch "$cpandir/.init" || exit 1
    fi
    sudo bash -c "$cpan notest install $*" 2>/dev/null || return 1
  fi
}
__cpan_remove() {
  cpan="$(type -P cpan 2>/dev/null | grep -v "$HOME" | grep '^' || return)"
  if [[ -n "$cpan" ]]; then
    sudo bash -c "$cpan --uninstall $*" 2>/dev/null || return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Python/PIP functions
__pip_run() {
  local packages="$*"
  local pip_opts=""
  pip3="$(ls /usr/bin/pip*3* 2>/dev/null | head -n 1)"
  py_bin="$(type -P python3 || type -P python2 || type -P python || return)"
  py_version="$($py_bin --version | sed 's|[pP]ython ||g' | awk -F '.' '{print $1$2}' | grep '[0-9]' || echo "0")"
  PKMGR_TEMP_FILE="${PKMGR_TEMP_FILE:-$(mktemp $PKMGR_TEMP_DIR/XXXXXX 2>/dev/null)}"
  [ -n "$py_bin" ] || printf_exit "python is not installed" >&2
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME pip install [package]" >&2
  pip="$(type -P $pip3 || type -P pip || echo "$py_bin -m pip")"
  cat <<EOF >"$PKMGR_TEMP_FILE"
pip="$pip"
pip_opts=""
[ "$py_version" -gt "310" ] && pip_opts="--break-system-packages"
[ -n "\$pip" ] && exitStatus=0 || { echo "pip is not installed" >&2 && exit 1; }
[ -f "/etc/profile.d/pyenv.sh" ] && . /etc/profile.d/pyenv.sh
echo "Running as: $SUDO_USER"
for pkg_name in $packages; do
  name="\${pkg_name// /}"
  sudo -HE -u $SUDO_USER \$pip install --upgrade --user \$pip_opts "\$name" 2>/dev/null || exitStatus=\$((exitStatus + 1))
done
exit \$exitStatus
EOF
  if [ -f "$PKMGR_TEMP_FILE" ]; then
    chmod 755 "$PKMGR_TEMP_FILE" && sudo -H bash -c "$PKMGR_TEMP_FILE"
  else
    printf_red "Failed to create $PKMGR_TEMP_FILE" && return 1
  fi
  return $?
}
#
__pip_remove() {
  local packages="$*"
  local pip_opts=""
  pip3="$(ls /usr/bin/pip*3* 2>/dev/null | head -n 1)"
  py_bin="$(type -P python3 || type -P python2 || type -P python || return)"
  py_version="$($py_bin --version | sed 's|[pP]ython ||g' | awk -F '.' '{print $1$2}' | grep '[0-9]' || echo "0")"
  PKMGR_TEMP_FILE="${PKMGR_TEMP_FILE:-$(mktemp $PKMGR_TEMP_DIR/XXXXXX 2>/dev/null)}"
  [ -n "$py_bin" ] || printf_exit "python is not installed" >&2
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME pip remove [package]" >&2
  pip="$(type -P $pip3 || type -P pip || echo "$py_bin -m pip")"
  cat <<EOF >"$PKMGR_TEMP_FILE"
pip="$pip"
pip_opts=""
[ "$py_version" -gt "310" ] && pip_opts="--break-system-packages"
[ -f "/etc/profile.d/pyenv.sh" ] && . /etc/profile.d/pyenv.sh
[ -n "\$pip" ] && exitStatus=0 || { echo "pip is not installed" >&2 && exit 1; }
echo "Running as: $SUDO_USER"
for file in $packages; do
  name="\${file// /}"
  sudo -HE -u $SUDO_USER \$pip uninstall --yes \$pip_opts "\$name" || exitStatus=\$((exitStatus + 1))
  if [ -f "/usr/local/bin/\$name" ]; then
    rm -Rf "/usr/local/bin/\$name"
  fi
done
exit \$exitStatus
EOF
  if [ -f "$PKMGR_TEMP_FILE" ]; then
    chmod 755 "$PKMGR_TEMP_FILE" && sudo -H bash -c "$PKMGR_TEMP_FILE"
  else
    printf_red "Failed to create $PKMGR_TEMP_FILE" && return 1
  fi
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Ruby/GEM functions
__gem_run() {
  local packages="$*"
  gem="$(type -P gem 2>/dev/null | grep -v "$HOME" | grep '^' || return)"
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME gem install [package]" >&2
  if [ -n "$packages" ] && [ -n "$gem" ]; then
    sudo $gem install --no-user-install $packages 2>/dev/null || return 1
  fi
}
__gem_remove() {
  local packages="$*"
  gem="$(type -P gem 2>/dev/null | grep -v "$HOME" | grep '^' || return)"
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME gem remove [package]" >&2
  if [ -n "$gem" ]; then
    sudo $gem uninstall --no-user-install --force -aIx $packages 2>/dev/null || return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# NODE/Yarn/NPM functions
__npm_run() {
  local packages="$*"
  local NODE_PATH="" PATH="${PATH}"
  NODE_PATH="$(echo "$PATH" | tr ':' '\n' | grep 'node' | grep '/bin' || return)"
  PATH="$NODE_PATH:$PATH"
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME node install [package]" >&2
  if __cmd_exists fnm; then
    eval $(fnm env)
    fnm use default &>/dev/null
    npm i -g $packages 2>/dev/null | grep -v '^$' || return 1
  elif __cmd_exists npm; then
    npm install -g $packages 2>/dev/null | grep -v '^$' || return 1
  elif __cmd_exists yarn; then
    if [ "$USER" = "root" ]; then
      yarn global add $packages --prefix "/usr/local/bin"
    else
      yarn global add $packages --prefix "$HOME/.local/bin"
    fi
  else
    printf_exit "Neither npm or yarn seem to be installed"
  fi
}
__npm_remove() {
  local packages="$*"
  local NODE_PATH="" PATH="${PATH}"
  NODE_PATH="$(echo "$PATH" | tr ':' '\n' | grep 'node' | grep '/bin' || return)"
  PATH="$NODE_PATH:$PATH"
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME node remove [package]" >&2
  if __cmd_exists fnm; then
    eval $(fnm env)
    fnm use default &>/dev/null
    npm remove -g $packages 2>/dev/null | grep -v '^$' || return 1
  elif __cmd_exists npm; then
    npm remove -g $packages 2>/dev/null | grep -v '^$' || return 1
  elif __cmd_exists yarn; then
    if [ "$USER" = "root" ]; then
      yarn global remove "$*" --prefix "/usr/local/bin"
    else
      yarn global remove "$*" --prefix "$HOME/.local/bin"
    fi
  else
    printf_exit "Neither npm or yarn seem to be installed"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Lua/Rocks functions
__lua_run() {
  local packages="$*"
  __cmd_exists lua && __cmd_exists luarocks || return 1
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME lua install [package]" >&2
  luarocks install --local $packages
}
__lua_remove() {
  local packages="$*"
  __cmd_exists lua && __cmd_exists luarocks || return 1
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME lua remove [package]" >&2
  luarocks remove --local $packages
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Go functions
__go_run() {
  local packages="$*"
  __cmd_exists go || return 1
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME go install [package]" >&2
  export GOPATH="${GOPATH:-$HOME/.local/share/go}"
  for pack in $packages; do
    go install -v "$pack@latest"
  done
}
__go_remove() {
  local packages="$*"
  __cmd_exists go || return 1
  local pkg="" ost="" cnt="" scr=""
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME go remove [package]" >&2
  export GOPATH="${GOPATH:-$HOME/.local/share/go}"
  # Clean removes object files from package source directories (ignore error)
  for pkg in $packages; do
    go clean -i $pkg &>/dev/null
    # Set local variables
    [[ "$(uname -m)" == "x86_64" ]] && ost="$(uname)"
    ost="${ost,,}_amd64" && cnt="${pkg//[^\/]/}"
    # Delete the source directory and compiled package directory(ies)
    if (("${#cnt}" == "2")); then
      rm -rf "${GOPATH%%:*}/src/${pkg%/*}"
      rm -rf "${GOPATH%%:*}/pkg/${ost}/${pkg%/*}"
    elif (("${#cnt}" > "2")); then
      rm -rf "${GOPATH%%:*}/src/${pkg%/*/*}"
      rm -rf "${GOPATH%%:*}/pkg/${ost}/${pkg%/*/*}"
    fi
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Curl functions
__curl_run() {
  local os="" distro="" distroid="" url=""
  [ -z $1 ] && printf_exit 1 0 "Usage: pkmgr curl OS filename or pkmgr curl fullurltolist "
  url="$1"
  os="$(echo $OS | tr '[:upper:]' '[:lower:]')"
  distro="$(echo $DISTRO | tr '[:upper:]' '[:lower:]')"
  distroid="$(echo $DISTROID | tr '[:upper:]' '[:lower:]')"
  if __is_url "$url"; then
    __urlverify "$url" && __curl "$url" -o "$PKMGR_TEMP_FILE" &>/dev/null || return 1
  else
    url="$PKMGR_GIT_REPO/$1/raw/$PKMGR_GIT_BRANCH/lists/$2.list"
    shift "$#"
    __urlverify "$url" && __curl "$url" -o "$PKMGR_TEMP_FILE" &>/dev/null || return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Remote script execution functions
__script_run_if_is_url() {
  [ -z "$1" ] && printf_exit 1 0 "Usage: pkmgr script filename or url "
  if [[ "$1" =~ https?://.* ]] || [[ "$1" =~ ftp?://.* ]]; then
    __urlverify "$1" && __curl "$1" | tee -p "$PKMGR_TEMP_FILE" &>/dev/null || return 1
  else
    __cp_rf "$1" "$PKMGR_TEMP_FILE"
  fi
  if [ -f "$PKMGR_TEMP_FILE" ]; then
    chmod 755 "$PKMGR_TEMP_FILE"
  else
    printf_red "Error file does not exit"
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Script execution
__script_run() {
  if [ "$1" = "--script" ]; then
    shift 1
    __script_run_if_is_url "$1"
    __execute "$PKMGR_TEMP_FILE" "executing the script"
  elif [ "$1" = "--line" ]; then
    shift 1
    __script_run_if_is_url "$1"
    while read -r line; do __execute "$line" "$line"; done <"$PKMGR_TEMP_FILE"
  else
    __script_run_if_is_url "$1"
    "$PKMGR_TEMP_FILE"
  fi
  __rm_rf "$PKMGR_TEMP_FILE"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__schedule() {
  local logfile="" loggerfile="" file="" tmpfile="" mailadmin="" sleepcmd="" date="" cronjob=""
  logfile="/var/log/pkmgr/cron.log"
  loggerfile="/var/log/pkmgr/cron.err"
  file="/etc/cron.d/pkmgr_update"
  tmpfile="$PKMGR_TEMP_DIR/pkmgr_cron"
  mailadmin="${PKMGR_NOTIFICATION_EMAIL:-root}"
  sleepcmd=$((RANDOM / 300))
  date="$(date +"%m-%d-%Y %H:%M")"
  cronjob="0 4 * * * root sleep ${sleepcmd} ; pkmgr cron run"
  sudo mkdir -p "/var/log/pkmgr"
  case "$1" in
  remove)
    shift 1
    printf_green "Removing pkmgr schedule"
    __rm_rf "$file" ||
      printf_error "Failed to remove $file"
    ;;
  add)
    shift 1
    printf_green "Adding pkmgr to run daily at 4am with random sleep of $sleepcmd seconds"
    echo "MAILTO=$mailadmin" >"$tmpfile"
    echo "$cronjob" >"$tmpfile"
    sudo chown -f root:root "$tmpfile"
    sudo chmod -f 600 "$tmpfile"
    sudo mv -f $tmpfile $file ||
      printf_error "Failed to install $tmpfile to $file"
    ;;
  run)
    shift 1
    echo -e "###########\n$date\n###########\n" | sudo tee -p -a "$logfile" &>/dev/null
    echo -e "###########\n$date\n###########\n" | sudo tee -p -a "$loggerfile" &>/dev/null
    $pkgmgrbinupdcron 2>>"$loggerfile.tmp" | sudo tee -p -a "$logfile" &>/dev/null
    if [ -s "$loggerfile.tmp" ] && [ -f "$loggerfile.tmp" ] && grep -q '[^[:space:]]' "$loggerfile.tmp" &>/dev/null; then
      if __cmd_exists mail; then
        MAILMESS="$(echo -e "Errors were reported and they are as follows:\n""$(cat $loggerfile.tmp)\n")"
        echo $MAILMESS | mail -r "$mailadmin" -s "pkmgr failed" "$mailadmin"
      fi
    fi
    [ ! -f "$loggerfile.tmp" ] || sudo cat "$loggerfile.tmp" sudo | tee -p -a "$loggerfile" && __rm_rf "$loggerfile.tmp"
    ;;
  *)
    [ -f "$file" ] && pkmgr cron remove || pkmgr cron add
    ;;
  esac
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__dotfiles_run() {
  local file="" f="" url=""
  [ -n "$1" ] || printf_exit "Usage: pkmgr dotfiles name"
  f=""
  file=("$@")
  echo >"$PKMGR_TEMP_FILE"
  for f in "${file[@]}"; do
    if [ -n "$f" ]; then
      url="$dotfilesrepo_raw/$f.list"
      __urlverify "$url" && __curl "$url" | tee -p -a "$PKMGR_TEMP_FILE" &>/dev/null || return 1
    fi
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__aliases() {
  cat <<EOF
  alias apt='$APPNAME '
  alias apt-get='$APPNAME '
  alias dnf='$APPNAME '
  alias yum='$APPNAME '
  alias pacman='$APPNAME '
  alias brew='$APPNAME '
  alias yay='$APPNAME '
EOF
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__show_info() {
  local col=""
  local truncate="$1"
  [ -n "$COLUMNS" ] && col=$(($COLUMNS - 30)) || col=80
  printf_red "System info for $(hostname -f)         "
  printf_blue "Distribution:               $DISTRO_NAME"
  if [ -n "$CODE_NAME" ] && [ "$CODE_NAME" != "N/A" ]; then
    printf_yellow "Codename:                   $CODE_NAME"
  fi
  printf_blue "Distro Version:             $DISTRO_VERSION"
  printf_yellow "Kernel version              $KERNEL_VERSION"
  if [ "$truncate" = "truncate" ] || [ $col -le 80 ]; then
    truncate="true"
    printf_cyan "Repo:                       ${dotfilesrepo_url:0:$col}"
    printf_cyan "Repo Raw:                   ${dotfilesrepo_raw:0:$col}"
    printf_cyan "system package manager:     ${pkgmgrbin:0:$col}"
    printf_cyan "Install cmd:                ${pkgmgrbinins:0:$col}"
    printf_cyan "Install silent cmd:         ${pkgmgrbininssil:0:$col}"
    printf_cyan "Remove cmd:                 ${pkgmgrbindel:0:$col}"
    printf_cyan "Remove silent cmd:          ${pkgmgrbinremsil:0:$col}"
    printf_cyan "Update cmd:                 ${pkgmgrbinupd:0:$col}"
    printf_cyan "Update silent cmd:          ${pkgmgrbinupdsil:0:$col}"
    printf_cyan "Search cmd:                 ${pkgmgrbinsea:0:$col}"
    printf_cyan "Clean cache cmd:            ${pkgmgrbincle:0:$col}"
    printf_cyan "Make cache cmd:             ${pkgmgrbincac:0:$col}"
  else
    truncate="false"
    printf_cyan "Repo:                       ${dotfilesrepo_url}"
    printf_cyan "Repo:                       ${dotfilesrepo_raw}"
    printf_cyan "system package manager:     ${pkgmgrbin}"
    printf_cyan "Install cmd:                ${pkgmgrbinins}"
    printf_cyan "Install silent cmd:         ${pkgmgrbininssil}"
    printf_cyan "Remove cmd:                 ${pkgmgrbindel}"
    printf_cyan "Remove silent cmd:          ${pkgmgrbinremsil}"
    printf_cyan "Update cmd:                 ${pkgmgrbinupd}"
    printf_cyan "Update silent cmd:          ${pkgmgrbinupdsil}"
    printf_cyan "Search cmd:                 ${pkgmgrbinsea}"
    printf_cyan "Clean cache cmd:            ${pkgmgrbincle}"
    printf_cyan "Make cache cmd:             ${pkgmgrbincac}"
  fi
  printf_blue "Node:                       $(builtin type -P node || __not_installed)"
  printf_blue "NPM:                        $(builtin type -P npm || builtin type -P yarn || __not_installed)"
  printf_purple "Python:                     $(builtin type -P python3 || builtin type -P python2 || __not_installed)"
  printf_purple "PIP:                        $(builtin type -P pip3 || builtin type -P pip || __not_installed)"
  printf_blue "Perl:                       $(builtin type -P perl || __not_installed)"
  printf_blue "CPAN:                       $(builtin type -P cpan || __not_installed)"
  printf_purple "Ruby:                       $(builtin type -P ruby || __not_installed)"
  printf_purple "Gem:                        $(builtin type -P gem || __not_installed)"
  printf_blue "Lua                         $(builtin type -P lua || __not_installed)"
  printf_blue "Luarocks                    $(builtin type -P luarocks || __not_installed)"
  if [ "$truncate" = "true" ]; then
    printf_newline && printf_yellow "Results may have been truncated to $col characters add notruncate for no truncation"
  fi
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__exportpkg() {
  local pkgdir="" pkglist=""
  local distro="$(printf '%s\n' "$DISTRO" | sed 's|[0-9]||g')"
  case "$(uname -s)" in
  Darwin*) distro="MacOS" ;;
  ^MING* | WIN* | MSYS*) distro="Windows" ;;
  esac
  pkgdir="$PKMGR_TEMP_DIR/${distro:-}"
  pkglist="$pkgdir/$(hostname -s).list"
  mkdir -p "$pkgdir"
  printf_green "Exporting package list to:"
  printf_green "$pkglist"
  __pkgmgrexport >"$pkglist"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__update_mirrors() {
  __cmd_exists pacman || return 0
  sudo pacman -S --noconfirm --needed reflector &>/dev/null
  __cmd_exists reflector || return
  (
    sudo reflector --protocol 'https' --ipv4 --latest 100 \
      --country us --fastest 20 --sort rate --threads 5 \
      --download-timeout 1 --connection-timeout 1 --save "$PKMGR_TEMP_DIR/mirrorlist.new"
    rankmirrors -n 0 "$PKMGR_TEMP_DIR/mirrorlist.new" >"$PKMGR_TEMP_DIR/mirrorlist"
  ) |& tee -p &>/dev/null
  if [ -f "$PKMGR_TEMP_DIR/mirrorlist" ] && [ -s "$PKMGR_TEMP_DIR/mirrorlist" ]; then
    sudo mv -f "$PKMGR_TEMP_DIR/mirrorlist" "/etc/pacman.d/mirrorlist" &>/dev/null
    sudo rm -Rf "$PKMGR_TEMP_DIR/mirrorlist" "$PKMGR_TEMP_DIR/mirrorlist.new" &>/dev/null
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__initialize_variables() {
  PKMGR_OS_NAME="$(uname -s | tr '[:upper:]' '[:lower:]')"
  export SUDO_USER RUN_USER
  if [[ "$(__devnull2 python3 -V)" =~ "Python 3" ]]; then
    PYTHONVER="python3"
    PIP="pip3"
    PATH="${PATH}:$(python3 -c 'import site; print(site.USER_BASE)')/bin"
  elif [[ "$(__devnull2 python2 -V)" =~ "Python 2" ]]; then
    PYTHONVER="python"
    PIP="pip"
    PATH="${PATH}:$(python -c 'import site; print(site.USER_BASE)')/bin"
  fi
  if __cmd_exists pacman; then
    PYTHONVER="python"
    PIP="pip3"
  fi
  [ -f "$PKMGR_TEMP_FILE" ] && __rm_rf "$PKMGR_TEMP_FILE"
  case "$PKMGR_OS_NAME" in
  linux)
    # apt-get debian based setup
    if [ -f "$(builtin type -P apt-get 2>/dev/null)" ]; then                                                                      #
      pkmgrcheckbin_opts="-q -y --ignore-hold --allow-change-held-packages --allow-unauthenticated -s dist-upgrade"               #
      export DEBIAN_FRONTEND=noninteractive                                                                                       #
      export APT_OPTS='-o Dpkg::Options::='--force-confdef' -o Dpkg::Options::='--force-confold''                                 #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                      #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/apt"                                                              #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/apt-get"                                                                       #
      pkgmgrbinsea="sudo --preserve-env=PATH /usr/bin/apt-cache search"                                                           #
      pkmgrcheckbin="$(builtin type -P apt 2>/dev/null)"                                                                          #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin $pkmgrcheckbin_opts 2>/dev/null | grep '^Inst' | wc -l; } #
      __pkgmgrexport() { dpkg -l | grep ^ii | awk '{print $2}' | sed "s#:.*##g" | sort -u; }                                      #
      __pkgmr_reinstall() { for pkg in $(__pkgmgrexport); do $pkgmgrbin install --reinstall "$pkg" 2>/dev/null || $pkgmgrbin install "$pkg" 2>/dev/null || true; done; return 0; }                                                             #
      __pkgmgrbinins() { $pkgmgrbin install "$@" || return 1; }
      __pkgmgrbininssil() { $pkgmgrbin install $APT_OPTS --ignore-missing -yy -q --allow-unauthenticated --assume-yes "$@" || return 1; }
      __pkgmgrbinremsil() { $pkgmgrbin remove -yy -q --assume-yes --purge "$@" || return 1; }
      __pkgmgrbinupdsil() { $pkgmgrbin dist-upgrade $APT_OPTS --ignore-missing -yy -q --allow-unauthenticated --assume-yes || return 1; }
      __pkgmgrbinupdcron() { $pkgmgrbin dist-upgrade $APT_OPTS --ignore-missing -yy --allow-unauthenticated --assume-yes || return 1; }
      __pkgmgrbindel() { $pkgmgrbin remove --purge "$@" || return 1; }
      __pkgmgrbinupd() { $pkgmgrbin dist-upgrade "$@" || return 1; }
      __pkgmgrbincle() { $pkgmgrbin clean || return 1; }
      __pkgmgrbincac() { $pkgmgrbin update || return 1; }
      __pkgmgrbinins() { __pkgmgrbinins "$@" || return 1; }
      __pkgmgrbininssil() { __pkgmgrbininssil "$@" || return 1; }
      __pkgmgrbinremsil() { __pkgmgrbinremsil "$@" || return 1; }
      __pkgmgrbinupdsil() { __pkgmgrbinupdsil || return 1; }
      __pkgmgrbinupdcron() { __pkgmgrbinupdcron || return 1; }
      __pkgmgrbindel() { __pkgmgrbindel "$@" || return 1; }
      __pkgmgrbinupd() { __pkgmgrbinupd "$@" || return 1; }
      __pkgmgrbincle() { __pkgmgrbincle || return 1; }
      __pkgmgrbincac() { __pkgmgrbincac || return 1; }
      __pkgmgr_update_keys() {
        local all_keyrings="debian-archive-keyring debian-keyring ubuntu-keyring ubuntu-advantage-tools ca-certificates gnupg gnupg2 ubuntu-minimal ubuntu-standard debian-ports-archive-keyring kali-archive-keyring raspbian-archive-keyring pop-keyring elementary-keyring linuxmint-keyring pureos-keyring trisquel-keyring"
        local installed_keyrings=""
        for pkg in $all_keyrings; do
          if dpkg -l "$pkg" 2>/dev/null | grep -q '^ii'; then
            installed_keyrings+="$pkg "
          fi
        done
        if [ -n "$installed_keyrings" ]; then
          $pkgmgrbin install --only-upgrade $APT_OPTS -yy -q $installed_keyrings 2>/dev/null || return 0
        fi
      }

    # apt-get debian based setup
    elif [ -f "$(builtin type -P apt 2>/dev/null)" ]; then                                                                        #
      pkmgrcheckbin_opts="-q -y --ignore-hold --allow-change-held-packages --allow-unauthenticated -s dist-upgrade"               #
      export DEBIAN_FRONTEND=noninteractive                                                                                       #
      export APT_OPTS="-o Dpkg::Options::='--force-confdef' -o Dpkg::Options::='--force-confold'"                                 #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                      #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/apt"                                                              #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/apt"                                                                           #
      __pkgmgrbinins() { $pkgmgrbin install "$@" || return 1; }
      __pkgmgrbininssil() { $pkgmgrbin install $APT_OPTS --ignore-missing -yy -q --allow-unauthenticated --assume-yes "$@" || return 1; }
      __pkgmgrbinremsil() { $pkgmgrbin remove -yy -q --assume-yes --purge "$@" || return 1; }
      __pkgmgrbinupdsil() { $pkgmgrbin dist-upgrade $APT_OPTS --ignore-missing -yy -q --allow-unauthenticated --assume-yes || return 1; }
      __pkgmgrbinupdcron() { $pkgmgrbin dist-upgrade $APT_OPTS --ignore-missing -yy --allow-unauthenticated --assume-yes || return 1; }
      __pkgmgrbindel() { $pkgmgrbin remove --purge "$@" || return 1; }
      pkgmgrbinsea="sudo --preserve-env=PATH /usr/bin/apt-cache search"                                                           #
      __pkgmgrbinupd() { $pkgmgrbin dist-upgrade "$@" || return 1; }
      __pkgmgrbincle() { $pkgmgrbin clean || return 1; }
      __pkgmgrbincac() { $pkgmgrbin update || return 1; }
      pkmgrcheckbin="$(builtin type -P apt 2>/dev/null)"                                                                          #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin $pkmgrcheckbin_opts 2>/dev/null | grep '^Inst' | wc -l; } #
__pkgmgrexport() { dpkg -l | grep ^ii | awk '{print $2}' | sed "s#:.*##g" | sort -u; }                                        #
__pkgmr_reinstall() { for pkg in $(__pkgmgrexport); do $pkgmgrbin install --reinstall "$pkg" 2>/dev/null || $pkgmgrbin install "$pkg" 2>/dev/null || true; done; return 0; }                                                               #
__pkgmgr_update_keys() {
        local all_keyrings="debian-archive-keyring debian-keyring ubuntu-keyring ubuntu-advantage-tools ca-certificates gnupg gnupg2 ubuntu-minimal ubuntu-standard debian-ports-archive-keyring kali-archive-keyring raspbian-archive-keyring pop-keyring elementary-keyring linuxmint-keyring pureos-keyring trisquel-keyring"
        local installed_keyrings=""
        for pkg in $all_keyrings; do
          if dpkg -l "$pkg" 2>/dev/null | grep -q '^ii'; then
            installed_keyrings+="$pkg "
          fi
        done
        if [ -n "$installed_keyrings" ]; then
          $pkgmgrbin install --only-upgrade $APT_OPTS -yy -q $installed_keyrings 2>/dev/null || return 0
        fi
      }

    # pacman archlinux based setup
    elif [ -f "$(builtin type -P pacman 2>/dev/null)" ]; then                                                                                                               #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                                                                #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/pacman"                                                                                                     #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/pacman"                                                                                                                  #
      __pkgmgrbinins() { $pkgmgrbin -S --noconfirm --overwrite='*' "$@" || return 1; }
      __pkgmgrbininssil() { $pkgmgrbin -Sy --noconfirm --needed --overwrite='*'  "$@" || return 1; }
      __pkgmgrbinremsil() { $pkgmgrbin -Ry --noconfirm "$@" || return 1; }
      __pkgmgrbinupdsil() { $pkgmgrbin -Syyu --noconfirm || return 1; }
      __pkgmgrbinupdcron() { $pkgmgrbin -Syyu --noconfirm || return 1; }
      __pkgmgrbindel() { $pkgmgrbin -R "$@" || return 1; }
      pkgmgrbinsea="$pkgmgrbin -Ss --noconfirm"                                                                                                                             #
      __pkgmgrbinupd() { $pkgmgrbin -Syyu --needed --overwrite='*' "$@" || return 1; }
      __pkgmgrbincle() { yes | $pkgmgrbin -Scc --noconfirm || return 1; }
      __pkgmgrbincac() { $pkgmgrbin -Syy || return 1; }
      pkmgrcheckbin="$(builtin type -P pacman 2>/dev/null)"                                                                                                                 #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin -Qu 2>/dev/null | wc -l; }                                                                          #
__pkgmgrexport() { (pacman -Qqe | grep -v "$(pacman -Qqm)" && pacman -Qqet | grep -v "$(pacman -Qqm)") | sort -u; }                                                     #
__pkgmr_reinstall() { for pkg in $(pacman -Q | cut -d' ' -f1); do __execute "pacman -S --noconfirm $pkg" "Reinstalling package: $pkg"; done && return 0 || return $?; } #
__pkgmgr_update_keys() {
        local all_keyrings="archlinux-keyring chaotic-keyring endeavouros-keyring manjaro-keyring artix-keyring arcolinux-keyring cachyos-keyring garuda-keyring"
        local installed_keyrings=""
        for pkg in $all_keyrings; do
          if pacman -Q "$pkg" &>/dev/null; then
            installed_keyrings+="$pkg "
          fi
        done
        if [ -n "$installed_keyrings" ]; then
          $pkgmgrbin -Sy --noconfirm --needed $installed_keyrings 2>/dev/null || return 0
        fi
      }
    # pamac archlinux based setup
    elif [ -f "$(builtin type -P pamac 2>/dev/null)" ]; then                                                                                                      #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                                                      #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/pacman"                                                                                           #
      pkgmgrbin="sudo /usr/bin/pamac"                                                                                                                             #
      __pkgmgrbinins() { $pkgmgrbin install --noconfirm "$@" || return 1; }
      __pkgmgrbininssil() { $pkgmgrbin install --noconfirm "$@" || return 1; }
      __pkgmgrbinremsil() { $pkgmgrbin remove --noconfirm "$@" || return 1; }
      __pkgmgrbinupdsil() { $pkgmgrbin upgrade -a || return 1; }
      __pkgmgrbinupdcron() { $pkgmgrbin upgrade -a || return 1; }
      __pkgmgrbindel() { $pkgmgrbin remove "$@" || return 1; }
      pkgmgrbinsea="$pkgmgrbin search -a"                                                                                                                         #
      __pkgmgrbinupd() { $pkgmgrbin upgrade -a "$@" || return 1; }
      __pkgmgrbincle() { $pkgmgrbin clean || return 1; }
      __pkgmgrbincac() { $pkgmgrbin checkupdates || return 1; }
      pkmgrcheckbin="$(builtin type -P pamac 2>/dev/null)"                                                                                                        #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin checkupdates -a 2>/dev/null | wc -l; }                                                    #
__pkgmgrexport() { pamac list ${1:--e} | grep -E 'extra|community|core' | awk '{print $1}' | sort -u; }                                                       #
__pkgmr_reinstall() { for pkg in $(__pkgmgrexport -i); do __execute "pacman -S --noconfirm $pkg" "Reinstalling package: $pkg"; done && return 0 || return $?; } #
__pkgmgr_update_keys() {
        local all_keyrings="archlinux-keyring chaotic-keyring endeavouros-keyring manjaro-keyring artix-keyring arcolinux-keyring cachyos-keyring garuda-keyring"
        local installed_keyrings=""
        for pkg in $all_keyrings; do
          if pamac list -i | grep -q "^$pkg "; then
            installed_keyrings+="$pkg "
          fi
        done
        if [ -n "$installed_keyrings" ]; then
          $pkgmgrbin install --noconfirm --upgrade $installed_keyrings 2>/dev/null || return 0
        fi
      }
    # dnf fedora based setup
    elif [ -f "$(builtin type -P dnf 2>/dev/null)" ]; then                                                                        #
      execute_pkg_check="true"                                                                                                    #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                      #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/yum"                                                              #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/dnf"                                                                           #
      __pkgmgrbinins() { $pkgmgrbin install -y "$@" || return 1; }
      __pkgmgrbininssil() { $pkgmgrbin install --skip-broken -y "$@" || return 1; }
      __pkgmgrbinremsil() { $pkgmgrbin remove -y "$@" || return 1; }
      __pkgmgrbinupdsil() { $pkgmgrbin update -y || return 1; }
      __pkgmgrbinupdcron() { $pkgmgrbin update -y || return 1; }
      __pkgmgrbindel() { $pkgmgrbin remove -y "$@" || return 1; }
      pkgmgrbinsea="$pkgmgrbin search"                                                                                            #
      __pkgmgrbinupd() { $pkgmgrbin update "$@" || return 1; }
      __pkgmgrbincle() { $pkgmgrbin clean || return 1; }
      __pkgmgrbincac() { $pkgmgrbin makecache || return 1; }
      pkmgrcheckbin="$(builtin type -P dnf 2>/dev/null)"                                                                          #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin -q check-update 2>/dev/null | grep -v Security | wc -l; } #
__pkgmgrexport() { rpm -qa --qf '%{name}\n' | grep -v gpg-pubkey | sort -u; }                                                 #
__pkgmr_reinstall() { for pkg in $(__pkgmgrexport); do $pkgmgrbin install --reinstall "$pkg" 2>/dev/null || $pkgmgrbin install "$pkg" 2>/dev/null || true; done; return 0; }                                                               #
      execute_pkg_check() { __cmd_exists "$1" || rpm -qi "$1" &>/dev/null || return 1; }                                          #
__pkgmgr_update_keys() {
        local all_keyrings="fedora-gpg-keys centos-gpg-keys redhat-release epel-release distribution-gpg-keys almalinux-release rocky-release oraclelinux-release"
        local installed_keyrings=""
        for pkg in $all_keyrings; do
          if rpm -q "$pkg" &>/dev/null; then
            installed_keyrings+="$pkg "
          fi
        done
        if [ -n "$installed_keyrings" ]; then
          $pkgmgrbin update --skip-broken -y $installed_keyrings 2>/dev/null || return 0
        fi
      }
    # yum fedora based setup
    elif [ -f "$(builtin type -P yum 2>/dev/null)" ]; then                                                                        #
      execute_pkg_check="true"                                                                                                    #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                      #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/yum"                                                              #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/yum"                                                                           #
      __pkgmgrbinins() { $pkgmgrbin install -y "$@" || return 1; }
      __pkgmgrbininssil() { $pkgmgrbin install --skip-broken -y "$@" || return 1; }
      __pkgmgrbinremsil() { $pkgmgrbin remove -y "$@" || return 1; }
      __pkgmgrbinupdsil() { $pkgmgrbin update -y || return 1; }
      __pkgmgrbinupdcron() { $pkgmgrbin update -y || return 1; }
      __pkgmgrbindel() { $pkgmgrbin remove -y "$@" || return 1; }
      pkgmgrbinsea="$pkgmgrbin search"                                                                                            #
      __pkgmgrbinupd() { $pkgmgrbin update "$@" || return 1; }
      __pkgmgrbincle() { $pkgmgrbin clean || return 1; }
      __pkgmgrbincac() { $pkgmgrbin makecache || return 1; }
      pkmgrcheckbin="$(builtin type -P yum 2>/dev/null)"                                                                          #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin -q check-update 2>/dev/null | grep -v Security | wc -l; } #
__pkgmgrexport() { rpm -qa --qf '%{name}\n' | grep -v gpg-pubkey | sort -u; }                                                 #
__pkgmr_reinstall() { for pkg in $(__pkgmgrexport); do $pkgmgrbin install --reinstall "$pkg" 2>/dev/null || $pkgmgrbin install "$pkg" 2>/dev/null || true; done; return 0; }                                                               #
      execute_pkg_check() { __cmd_exists "$1" || rpm -qi "$1" &>/dev/null || return 1; }                                          #
__pkgmgr_update_keys() {
        local all_keyrings="fedora-gpg-keys centos-gpg-keys redhat-release epel-release distribution-gpg-keys almalinux-release rocky-release oraclelinux-release"
        local installed_keyrings=""
        for pkg in $all_keyrings; do
          if rpm -q "$pkg" &>/dev/null; then
            installed_keyrings+="$pkg "
          fi
        done
        if [ -n "$installed_keyrings" ]; then
          $pkgmgrbin update --skip-broken -y $installed_keyrings 2>/dev/null || return 0
        fi
      }
      # tdnf photon based setup
    elif [ -f "$(builtin type -P tdnf 2>/dev/null)" ]; then                                                                         #
      execute_pkg_check="true"                                                                                                      #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                        #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/tdnf"                                                               #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/tdnf"                                                                            #
      __pkgmgrbinins() { $pkgmgrbin install "$@" || return 1; }
      __pkgmgrbininssil() { $pkgmgrbin install -y "$@" || return 1; }
      __pkgmgrbinremsil() { $pkgmgrbin remove -y "$@" || return 1; }
      __pkgmgrbinupdsil() { $pkgmgrbin update -y || return 1; }
      __pkgmgrbinupdcron() { $pkgmgrbin update -y || return 1; }
      __pkgmgrbindel() { $pkgmgrbin remove "$@" || return 1; }
      pkgmgrbinsea="$pkgmgrbin search"                                                                                              #
      __pkgmgrbinupd() { $pkgmgrbin update "$@" || return 1; }
      __pkgmgrbincle() { $pkgmgrbin clean || return 1; }
      __pkgmgrbincac() { $pkgmgrbin makecache || return 1; }
      pkmgrcheckbin="$(builtin type -P tdnf 2>/dev/null)"                                                                           #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin -q check-update 2>/dev/null | grep -v 'Security' | wc -l; } #
__pkgmgrexport() { rpm -qa --qf '%{name}\n' | grep -v gpg-pubkey | sort -u; }                                                   #
__pkgmr_reinstall() { for pkg in $(__pkgmgrexport); do $pkgmgrbin install --reinstall "$pkg" 2>/dev/null || $pkgmgrbin install "$pkg" 2>/dev/null || true; done; return 0; }                                                                 #
      execute_pkg_check() { __cmd_exists "$1" || rpm -qi "$1" &>/dev/null || return 1; }                                            #
__pkgmgr_update_keys() {
        local all_keyrings="photon-release photon-repos"
        local installed_keyrings=""
        for pkg in $all_keyrings; do
          if rpm -q "$pkg" &>/dev/null; then
            installed_keyrings+="$pkg "
          fi
        done
        if [ -n "$installed_keyrings" ]; then
          $pkgmgrbin update -y $installed_keyrings 2>/dev/null || return 0
        fi
      }
      # apk alpine based setup
    elif [ -f "$(builtin type -P apk 2>/dev/null)" ]; then                   #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                 #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/apk"         #
      pkgmgrbin="$(builtin type -P apk 2>/dev/null)"                         #
      __pkgmgrbinins() { $pkgmgrbin -U add "$@" || return 1; }
      __pkgmgrbininssil() { $pkgmgrbin -U add >/dev/null "$@" || return 1; }
      __pkgmgrbinremsil() { $pkgmgrbin del -f "$@" || return 1; }
      __pkgmgrbinupdsil() { $pkgmgrbin -U upgrade >/dev/null || return 1; }
      __pkgmgrbinupdcron() { $pkgmgrbin -U upgrade >/dev/null || return 1; }
      __pkgmgrbindel() { $pkgmgrbin del "$@" || return 1; }
      pkgmgrbinsea="$pkgmgrbin search | sed 's|-[0-9].*\.[0-9]\.[0-9].*||g'" #
      __pkgmgrbinupd() { $pkgmgrbin -U upgrade "$@" || return 1; }
      __pkgmgrbincle() { $pkgmgrbin cache clean && rm -rf /var/lib/apk/ || return 1; }
      __pkgmgrbincac() { $pkgmgrbin update || return 1; }
      pkmgrcheckbin="$(builtin type -P apk 2>/dev/null)"                     #
      __pkmgrcheckupdates() { $pkmgrcheckbin -u list | wc -l; }              #
__pkgmgrexport() { $pkgmgrbin info | grep -ve '-doc$' | sort -u; }       #
__pkgmr_reinstall() { apk info | xargs apk fix || return 1; }            #
__pkgmgr_update_keys() {
        local all_keyrings="alpine-keys alpine-base"
        local installed_keyrings=""
        for pkg in $all_keyrings; do
          if apk info -e "$pkg" &>/dev/null; then
            installed_keyrings+="$pkg "
          fi
        done
        if [ -n "$installed_keyrings" ]; then
          $pkgmgrbin -U upgrade $installed_keyrings 2>/dev/null || return 0
        fi
      }
    # xbps-* voidlinux based setup
    elif [ -f "$(builtin type -P xbps-install 2>/dev/null)" ]; then                            #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                   #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/xbps"                          #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/xbps-install"                               #
      __pkgmgrbinins() { $pkgmgrbin -S "$@" || return 1; }
      __pkgmgrbininssil() { $pkgmgrbin -Sy "$@" || return 1; }
      __pkgmgrbinremsil() { sudo --preserve-env=PATH /usr/bin/xbps-remove -y "$@" || return 1; }
      __pkgmgrbinupdsil() { $pkgmgrbin -Syu || return 1; }
      __pkgmgrbinupdcron() { $pkgmgrbin -Syu || return 1; }
      __pkgmgrbindel() { sudo --preserve-env=PATH /usr/bin/xbps-remove "$@" || return 1; }
      pkgmgrbinsea="sudo --preserve-env=PATH /usr/bin/xbps-query -Rs"                          #
      __pkgmgrbinupd() { $pkgmgrbin -Syu  "$@" || return 1; }
      __pkgmgrbincle() { sudo --preserve-env=PATH /usr/bin/xbps-remove -O || return 1; }
      __pkgmgrbincac() { $pkgmgrbin -S || return 1; }
      pkmgrcheckbin="$(builtin type -P xbps-install 2>/dev/null)"                              #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin 2>/dev/null | wc -l; } #
__pkgmgrexport() { xbps-query -l; }                                                        #
__pkgmr_reinstall() { for pkg in $(__pkgmgrexport); do $pkgmgrbin install --reinstall "$pkg" 2>/dev/null || $pkgmgrbin install "$pkg" 2>/dev/null || true; done; return 0; }                            #
__pkgmgr_update_keys() {
        local all_keyrings="void-repo-keys void-release"
        local installed_keyrings=""
        for pkg in $all_keyrings; do
          if xbps-query -l | grep -q "^ii $pkg"; then
            installed_keyrings+="$pkg "
          fi
        done
        if [ -n "$installed_keyrings" ]; then
          $pkgmgrbin -Syu $installed_keyrings 2>/dev/null || return 0
        fi
      }
    fi                                                                                         #
    ;;                                                                                         #
    # MacOS brew
  darwin)                                                                                               #
    if [ -n "$(builtin type -P brew 2>/dev/null)" ]; then                                               #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                            #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/brew"                                   #
      if [ "$1" = "--cask" ]; then                                                                      #
        pkgmgrbin="sudo --preserve-env=PATH -u $RUN_USER brew --cask"                                   #
      else                                                                                              #
        pkgmgrbin="sudo --preserve-env=PATH -u $RUN_USER brew"                                          #
      fi                                                                                                #
      __pkgmgrbinins() { $pkgmgrbin install "$@" || return 1; }
      __pkgmgrbininssil() { $pkgmgrbin install -f "$@" || return 1; }
      __pkgmgrbinremsil() { $pkgmgrbin remove -f "$@" || return 1; }
      __pkgmgrbinupdsil() { $pkgmgrbin upgrade -f || return 1; }
      __pkgmgrbinupdcron() { $pkgmgrbin upgrade -f || return 1; }
      __pkgmgrbindel() { $pkgmgrbin remove "$@" || return 1; }
      pkgmgrbinsea="$pkgmgrbin search"                                                                  #
      __pkgmgrbinupd() { $pkgmgrbin upgrade "$@" || return 1; }
      __pkgmgrbincle() { $pkgmgrbin cleanup || return 1; }
      __pkgmgrbincac() { $pkgmgrbin update || return 1; }
      pkmgrcheckbin="$(builtin type -P brew 2>/dev/null)"                                               #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin outdated 2>/dev/null | wc -l; } #
__pkgmgrexport() { $pkgmgrbin list --cask && $pkgmgrbin list --formula | sort -u; }                 #
__pkgmr_reinstall() { for pkg in $(__pkgmgrexport); do $pkgmgrbin install --reinstall "$pkg" 2>/dev/null || $pkgmgrbin install "$pkg" 2>/dev/null || true; done; return 0; }                                     #
__pkgmgr_update_keys() { return 0; }
    fi                                                                                                  #
    ;;                                                                                                  #
    # Windows chocolatey based setup
  cygwin* | mingw* | msys*)                                                                  #
    dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                   #
    dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/win"                           #
    pkgmgrbin="choco"                                                                        #
    pkgmgrbinins="choco install"                                                             #
    pkgmgrbininssil="choco install -yf"                                                      #
    pkgmgrbinremsil="choco remove -f"                                                        #
    pkgmgrbinupdsil="choco update -yf"                                                       #
    pkgmgrbinupdcron="choco update -yf"                                                      #
    pkgmgrbindel="choco remove"                                                              #
    pkgmgrbinsea="choco search"                                                              #
    pkgmgrbinupd="choco update"                                                              #
    pkgmgrbincle="choco cleanup"                                                             #
    pkmgrcheckbin="$(builtin type -P false 2>/dev/null)"                                     #
    __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin 2>/dev/null | wc -l; } #
    __pkgmgrexport() { echo not enabled; }                                                     #
    __pkgmr_reinstall() { for pkg in $(__pkgmgrexport); do $pkgmgrbin install --reinstall "$pkg" 2>/dev/null || $pkgmgrbin install "$pkg" 2>/dev/null || true; done; return 0; }                            #
    __pkgmgr_update_keys() { return 0; }
    ;;                                                                                       #
  *)                                                                                         #
    printf_exit "Unknown OS or OS not supported"                                             #
    ;;                                                                                       #
  esac                                                                                       #
  #
  if [ -n "$(builtin type -P yay 2>/dev/null)" ] && [ "$ENABLE_AUR" = "true" ]; then   #
    dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                             #
    dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/pacman"                  #
    pkgmgrbin="sudo --preserve-env=PATH -u $RUN_USER /usr/bin/yay"                     #
    pkgmgrbinins="$pkgmgrbin -S --cleanafter --overwrite='*'"                          #
    pkgmgrbininssil="$pkgmgrbin -Sy --needed --noconfirm --cleanafter --overwrite='*'" #
    pkgmgrbinremsil="$pkgmgrbin -Ry --noconfirm --needed --noconfirm"                  #
    pkgmgrbindel="$pkgmgrbin -R"                                                       #
    pkgmgrbinsea="$pkgmgrbin -Ss"                                                      #
    pkgmgrbincle="yes | $pkgmgrbin -Scc --noconfirm"                                   #
    pkgmgrbincac="$pkgmgrbin -Syy"                                                     #
    pkmgrcheckbin="$(builtin type -P yay 2>/dev/null)"                                 #
    __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && yay -Qum 2>/dev/null | wc -l; } #
    __pkgmgrexport() { pacman -Qqet | grep -v "$(pacman -Qqm)" | sort -u; }              #
    __pkgmr_reinstall() { for pkg in $(__pkgmgrexport); do $pkgmgrbin install --reinstall "$pkg" 2>/dev/null || $pkgmgrbin install "$pkg" 2>/dev/null || true; done; return 0; }                      #
    __pkgmgrbinupdsil() {
      sudo pacman -Syyu --noconfirm || return 1
      $pkgmgrbin -Syua --noconfirm || return 1
    }
    __pkgmgrbinupdcron() {
      sudo pacman -Syyu --noconfirm || return 1
      $pkgmgrbin -Syua --noconfirm || return 1
    }
    __pkgmgrbinupd() {
      sudo pacman -Syyu --needed --overwrite='*' "$@" || return 1
      $pkgmgrbin -Syua --needed --overwrite='*' "$@" || return 1
    }
    pkgmgrbinupdsil="__pkgmgrbinupdsil"                                                #
    pkgmgrbinupdcron="__pkgmgrbinupdcron"                                              #
    pkgmgrbinupd="__pkgmgrbinupd"                                                      #
    __pkgmgr_update_keys() {
      local all_keyrings="archlinux-keyring chaotic-keyring endeavouros-keyring manjaro-keyring artix-keyring arcolinux-keyring cachyos-keyring garuda-keyring"
      local installed_keyrings=""
      for pkg in $all_keyrings; do
        if pacman -Q "$pkg" &>/dev/null; then
          installed_keyrings+="$pkg "
        fi
      done
      if [ -n "$installed_keyrings" ]; then
        sudo pacman -Sy --noconfirm --needed $installed_keyrings 2>/dev/null || return 0
      fi
    }
  fi                                                                                   #
  if __cmd_exists yay pacman; then                                                     #
    __pkmgrcheckupdates() {                                                            #
      pacman_count="$(pacman -Qu 2>/dev/null | wc -l | grep '^')"                      #
      yay_count="$(yay -Qum 2>/dev/null | wc -l)"                                      #
      updates=$((pacman_count + yay_count)) || updates="0"                             #
      printf '%s\n' "$updates"                                                         #
    }
  fi
  pkginit="$pkgmgrbincle ; $pkgmgrbincac ; $pkgmgrbinupdsil"
  [ -d "$PKMGR_INSTALLED_LIST_DIR" ] || { sudo mkdir -p "$PKMGR_INSTALLED_LIST_DIR" && sudo chmod 777 "$PKMGR_INSTALLED_LIST_DIR"; }

}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__execute_pkmgr() {
  case "$1" in
  check) # Check for updates
    shift 1
    if [ "$1" = "force" ] || [ "$FORCE_INSTALL" = "yes" ]; then
      __rm_rf "$CHECK_FOR_UPDATES_CACHE_DIR/update_check"
    elif ! __find_mtime "$CHECK_FOR_UPDATES_CACHE_DIR/update_check" "1800"; then
      __rm_rf "$CHECK_FOR_UPDATES_CACHE_DIR/update_check"
    fi
    if [ ! -f "$CHECK_FOR_UPDATES_CACHE_DIR/update_check" ]; then
      $pkgmgrbincac &>/dev/null
      __run_updatecheck >"$CHECK_FOR_UPDATES_CACHE_DIR/update_check"
    fi
    if [ -f "$CHECK_FOR_UPDATES_CACHE_DIR/update_check" ]; then
      cat "$CHECK_FOR_UPDATES_CACHE_DIR/update_check"
    else
      echo "0"
    fi
    exit ${exitCode:-0}
    ;;

  available) # List
    shift 1
    __run_install_available "$APPNAME"
    exit ${exitCode:-0}
    ;;

  init) # Update package manager and upgrade system
    shift 1
    [ "$1" = "help" ] && printf_exit 2 0 "Initialize the system by making the cache and updating"
    __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
    printf_blue "Updating keyring packages"
    __pkgmgr_update_keys
    __execute "$pkginit" "Initializing System" && exitCode=0 || exitCode=1
    exit ${exitCode:-0}
    ;;

  makecache) # Create the package manage cache file
    shift 1
    [ "$1" = "help" ] && printf_exit 2 0 "Create the cache for the package manager"
    printf_blue "Updating the package manager cache files - May take a while"
    __update_mirrors
    __pkgmgrbincac |& __devnull && exitCode=0 || exitCode=1
    exit ${exitCode:-0}
    ;;

  aliases) # Generate aliases
    shift 1
    if [ -d "$HOME/.config/bash/local" ] && grep -q userbashprofilelocal "$HOME/.bashrc" &>/dev/null; then
      ALIASFILE="$HOME/.config/bash/local/pkmgr.bash"
    else
      ALIASFILE="$HOME/.bash_profile"
    fi
    [ "$1" = "help" ] && printf_exit 2 0 "Print to terminal or --save to export to bash_profile"
    if [ "$1" = "--save" ]; then
      printf_green "Saving the aliases to your bash profile"
      if grep -vq "# pkmgr aliases" "$ALIASFILE"; then
        echo "# pkmgr aliases - Do not remove this line" >>"$ALIASFILE"
        __aliases >>"$ALIASFILE"
        printf_custom "5" "$ALIASFILE"
      fi
    else
      __aliases | printf_readline "2"
      printf_custom "3" "add --save to save this to the alias file"
      printf_custom "5" "$ALIASFILE"
      exit ${exitCode:-0}
    fi
    ;;

  cron) # run via cron
    shift 1
    exitCode=0
    [ "$1" = "help" ] && printf_exit 2 0 "Options are add, remove, or run"
    [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "cron" "__schedule $*"
    __schedule "$@" || exitCode=$((exitCode + 1))
    [ $exitCode -eq 0 ] && __write_log_status "cron ran successfully" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  ask) # Ask user to install missing
    shift 1
    if [ -n "$DISPLAY" ]; then
      __attemp_install_menus "$@"
    else
      __check_app "$@" && printf_green "Installed: $*" || printf_exit 1 1 "Install of $* failed"
    fi
    echo
    ;;

  export) # Export installed packages
    shift 1
    [ "$1" = "help" ] && printf_exit 2 0 "Export installed packages to a list"
    __exportpkg
    ;;

  clean) # Clean package manager files
    shift 1
    exitCode=0
    [ "$1" = "help" ] && printf_exit 2 0 "Clean up package manager files"
    [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "clean" "$pkgmgrbincle $*"
    __pkgmgrbincle || exitCode=1
    [ $exitCode -eq 0 ] && __write_log_status "clean ran successfully" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  search) # Search for packages
    shift 1
    [ $# = 0 ] && printf_exit 2 0 "Search for a package"
    [ "$1" = "help" ] && printf_exit 2 0 "Search for a package"
    # Handle search options properly
    if [ "$1" == "show-raw" ] || [ "$1" == "raw" ]; then
      export SHOW_RAW="true"
      shift 1
      printf_readline() { tee; }
      printf_red() { echo "$*"; }
    fi

    declare -a LISTARRAY=("$@")
    __searchcmd "${LISTARRAY[*]}"
    exit $?
    ;;

  mirrors)
    shift 1

    exit $?
    ;;

  keys) # reinitialize pacman keys
    shift 1
    exitCode=0
    if __cmd_exists pacman-key; then
      [ "$1" = "help" ] && printf_exit 2 0 "Usage: $APPNAME keys [broken] [arch,manjaro,arcolinux,cachyos,all] - Manage arch keys"
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "keys" "pacman-key $*"
      [ "$1" = "broken" ] && PKMGR_FIX_BROKEN="true" && shift 1 && printf_yellow "Updating mirrors file and deleting gpg keys"
      local keyrings_to_populate="${1:-archlinux}"
      if [ "$keyrings_to_populate" = "all" ]; then
        if [ -f "/etc/os-release" ]; then
          . /etc/os-release
          case "${ID,,}" in
          cachyos) keyrings_to_populate="archlinux cachyos" ;;
          manjaro) keyrings_to_populate="archlinux manjaro" ;;
          arcolinux) keyrings_to_populate="archlinux arcolinux" ;;
          endeavouros) keyrings_to_populate="archlinux endeavouros" ;;
          garuda) keyrings_to_populate="archlinux garuda chaotic" ;;
          artix) keyrings_to_populate="artix" ;;
          *) keyrings_to_populate="archlinux" ;;
          esac
        else
          keyrings_to_populate="archlinux"
        fi
      fi
      (
        __default_mirror_list_archlinux | sudo tee -p /etc/pacman.d/mirrorlist &>/dev/null
        sudo rm -Rf "/root/.gnupg/" "/etc/pacman.d/gnupg/" &>/dev/null
        if [ "$PKMGR_FIX_BROKEN" = "true" ]; then
          if [ -f "/etc/pacman.conf" ]; then
            sudo cp -Rf "/etc/pacman.conf" "$PKMGR_TEMP_DIR/pacman.conf"
            sudo sed -i "s|SigLevel.*=.*|SigLevel = Optional TrustAll|g" "/etc/pacman.conf"
          fi
          __execute "sudo reflector -f 30 -l 30 --number 10 --verbose --save /etc/pacman.d/mirrorlist 2>/dev/null >&1" "${CYAN}Updating the mirrors"
          printf_cyan "Attempting to fix pacman signatures"
        fi
        sudo gpg --refresh-keys >/dev/null 2>&1
        __execute "sudo pacman-key --init >/dev/null 2>&1" "Initializing pacman key"
        for keyring in $keyrings_to_populate; do
          __execute "sudo pacman-key --populate $keyring >/dev/null 2>&1" "Populating $keyring keys"
        done
        __execute "sudo pacman-key --refresh-keys >/dev/null 2>&1" "Refreshing the keys"
        __execute "sudo pacman -Syyu --noconfirm >/dev/null 2>&1" "${YELLOW}Updating packages"
        if [ -f "$PKMGR_TEMP_DIR/pacman.conf" ]; then
          [ "$PKMGR_FIX_BROKEN" = "true" ] && sudo cp -Rf "$PKMGR_TEMP_DIR/pacman.conf" "/etc/pacman.broken.conf" || cp -Rf "$PKMGR_TEMP_DIR/pacman.conf" "/etc/pacman.conf"
        fi
      ) || exitCode=$((exitCode + 1))
    else
      printf_error "This is only supported on Arch based distros"
      exitCode=1
    fi
    [ $exitCode -eq 0 ] && __write_log_status "keys ran successfully" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  import) # Install packages from export
    shift 1
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Install package via a list: pkmgr list ./listToInstall"
    __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
    __list_install "$@"
    exit $?
    ;;

  list) # Install package in a list file
    shift 1
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Install package via a list: pkmgr list ./listToInstall"
    __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
    __list_install "$@"
    exit $?
    ;;

  curl) # Download a list file and install
    shift 1
    exitCode=0
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "pkmgr curl arch min or pkmgr curl fullURLtoList"
    __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
    __curl_run "$@"
    PCKLIST="$(grep -sh -Ev '^$|^#' "$PKMGR_TEMP_FILE" | sort -u | tr '\n' ' ' && echo '')"
    if [ -n "$PCKLIST" ]; then
      for pkg in $PCKLIST; do
        if [ -n "$pkg" ]; then
          __pkgmgrbininssil "$pkg" && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
        fi
      done
    else
      printf_exit "Error: No packages were defined"
    fi
    [ -n "$VDEBUG" ] || __rm_rf "$PKMGR_TEMP_FILE"
    [ $exitCode -eq 0 ] && exitCode=0 || exitCode="${exitCode:-1}"
    exit ${exitCode:-0}
    ;;

  dotfiles) # Install dfmgr packages
    shift 1
    exitCode=0
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "pkmgr dotfiles git"
    __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
    __dotfiles_run "$@"
    PCKLIST="$(grep -Ev '^$|^#' "$PKMGR_TEMP_FILE" | sort -u | tr '\n' ' ' && echo '')"
    if [ -n "$PCKLIST" ]; then
      for pkg in $PCKLIST; do
        if [ -n "$pkg" ]; then
          __pkgmgrbininssil "$pkg" && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
        fi
      done
    else
      printf_red "Error: No packages were defined" >&2
      exitCode=2
    fi
    [ -n "$VDEBUG" ] || __rm_rf "$PKMGR_TEMP_FILE"
    [ $exitCode -eq 0 ] && exitCode=0 || exitCode="${exitCode:-1}"
    exit ${exitCode:-0}
    ;;

  script) # Execute a script
    shift 1
    exitCode=0
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "pkmgr script ./myScript or fullURLtoScript"
    __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
    __script_run "$@" || exitCode=$((exitCode + 1))
    [ $exitCode -eq 0 ] && exitCode=0 || exitCode="${exitCode:-1}"
    exit ${exitCode:-0}
    ;;

  required) # Install required files
    shift 1
    exitCode=0
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Install required packages"
    __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
    declare -a LISTARRAY=("$@")
    for pkg in "${LISTARRAY[@]}"; do
      __pkgmgrbininssil "$pkg" && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
    done
    [ $exitCode -eq 0 ] && exitCode=0 || exitCode="${exitCode:-1}"
    exit ${exitCode:-0}
    ;;

  reinstall) # reinstall all packages
    shift 1
    [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "reinstall" "__pkgmr_reinstall $*"
    __pkgmr_reinstall || exitCode=1
    [ $exitCode -eq 0 ] && __write_log_status "reinstall ran successfully" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  install) # Install packages
    shift 1
    exitCode=0
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Install a package"
    __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
    declare -a LISTARRAY=("$@")
    __init_log_status "install" "__pkgmgrbinins ${LISTARRAY[*]}"
    for pkg in "${LISTARRAY[@]}"; do
      __pkgmgrbinins "$pkg" && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
    done
    [ $exitCode -eq 0 ] && __write_log_status "install was successful" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  upgrade | update) # Update packages
    shift 1
    exitCode=0
    [ "$1" = "help" ] && printf_exit 2 0 "Update your system"
    __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
    __init_log_status "update" "$pkgmgrbinupd $*"
    if __cmd_exists systemmgr; then
      systemmgr update installer || exitCode=$((exitCode + 1))
    fi
    if builtin type -t __pkgmgr_update_keys | grep -q 'function'; then
      printf_cyan "Updating keyrings first..."
      if ! __pkgmgr_update_keys; then
        printf_yellow "Keyring update failed - attempting automatic fix"
        printf_cyan "Running: pkmgr keys broken all"
        if "$0" keys broken all; then
          printf_green "Keyring fix successful - continuing with update"
        else
          printf_red "Keyring fix failed - cannot continue safely"
          exitCode=1
          [ $exitCode -eq 0 ] && __write_log_status "upgrade was successful" || __write_log_status "Failed with status: $exitCode"
          exit ${exitCode:-0}
        fi
      fi
    fi
    printf_cyan "Updating system packages"
    __pkgmgrbinupd "$@" || exitCode=$((exitCode + 1))
    [ $exitCode -eq 0 ] && __write_log_status "upgrade was successful" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  remove) # Remove packages
    shift 1
    exitCode=0
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Remove a package"
    declare -a LISTARRAY=("$@")
    __init_log_status "remove" "$pkgmgrbindel ${LISTARRAY[*]}"
    for pkg in "${LISTARRAY[@]}"; do
      __pkgmgrbindel "$pkg" && __saved_file_delete "$pkg" || exitCode=$((exitCode + 1))
    done
    [ $exitCode -eq 0 ] && __write_log_status "upgrade was successful" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  silent) # Silent
    case "$2" in
    install) # Silently install packages
      shift 2
      exitCode=0
      { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Silently install packages"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      __init_log_status "silent install" "$pkgmgrbininssil ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __pkgmgrbininssil "$pkg" |& __silent_log_file && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
        [ "$execute_pkg_check" = "true" ] && { execute_pkg_check "$pkg" || exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "upgrade was successful" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # Silently remove packages
      shift 2
      exitCode=0
      { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Silently remove packages"
      declare -a LISTARRAY=("$@")
      __init_log_status "silent remove" "$pkgmgrbinremsil ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __pkgmgrbinremsil "*$pkg*" |& __silent_log_file && __saved_file_delete "$pkg" || exitCode=$((exitCode + 1))
        [ "$execute_pkg_check" = "true" ] && { execute_pkg_check "$pkg" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "package was removal was successful" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    upgrade) # Silently update packages
      shift 2
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Silently upgrade your system"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      __init_log_status "silent update" "$pkgmgrbinupdsil $*"
      __pkgmgr_update_keys |& __silent_log_file
      if __cmd_exists systemmgr; then
        systemmgr --raw update installer |& __silent_log_file
      fi
      __pkgmgrbinupdsil |& __silent_log_file || false
      [ $exitCode -eq 0 ] && __write_log_status "upgrade was successful" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    *) # Silently update packages
      shift 1
      exitCode=0
      { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Silently install packages | defaults to a silent update"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      __init_log_status "silent update" "$pkgmgrbininssil ${LISTARRAY[*]}"
      if [ -z "$1" ]; then
        __pkgmgrbinupdsil |& __silent_log_file || exitCode=$((exitCode + 1))
      else
        for pkg in "${LISTARRAY[@]}"; do
          __pkgmgrbininssil "$pkg" |& __silent_log_file && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
        done
      fi
      [ $exitCode -eq 0 ] && __write_log_status "upgrade was successful" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  cpan | perl) # perl CPAN modules
    shift 1
    case $1 in
    install) # Install perl modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "install perl modules via cpan"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "cpan" "__cpan_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __cpan_run "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "cpan install ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # Remove perl modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove perl modules via cpan"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "cpan" "__cpan_remove ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __cpan_remove "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "cpan remove ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    check) # Check to see if perl modules are installed
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Check for cpan module"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "cpan" "__perl_exists ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __perl_exists --sudo "$pkg" || { printf_red "CPAN module $pkg is missing" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "cpan check" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    *) # Install perl modules
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "install perl modules via cpan"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "cpan" "__cpan_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __cpan_run "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "cpan ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  pip | python) # Python modules
    shift 1
    case $1 in
    install) # Install python modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install python modules via pip"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "pip" "__cpan_run ${LISTARRAY[*]}"
      __cpan_run "${LISTARRAY[*]}" || exitCode=$((exitCode + 1))
      [ $exitCode -eq 0 ] && __write_log_status "pip install ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # Remove python modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove python modules via pip"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "pip" "__pip_remove ${LISTARRAY[*]}"
      __pip_remove "${LISTARRAY[*]}" || exitCode=$((exitCode + 1))
      [ $exitCode -eq 0 ] && __write_log_status "pip remove ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    check) # Check to see if python module is installed
      shift 1
      exitCode
      [ "$1" = "help" ] && printf_exit 2 0 "Check for pip module"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "pip" "__python_exists ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __python_exists --sudo "$pkg" || { printf_red "PIP module $pkg is missing" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "pip chack ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  gem | ruby) # ruby modules
    shift 1
    case $1 in
    install) # Install ruby modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install ruby modules via rubygems"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "gem" "__gem_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __gem_run "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "gem install ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # remove ruby modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove ruby modules via rubygems"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "gem" "__gem_remove ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __gem_remove "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "gem remove ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    check) # Check to see if ruby module is installed
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove ruby modules via rubygems"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "gem" "__gem_exists ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __gem_exists --sudo "$pkg" || { printf_red "GEM module $pkg is missing" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "gem check ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    *) # Install ruby modules
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install ruby modules via rubygems"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "gem" "__gem_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __gem_run "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "gem ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  npm | node) # node modules
    shift 1
    case $1 in
    install) # Install node modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install node package via npm"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "npm" "__npm_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __npm_run "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "npm install ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # Remove node modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove node package via npm"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "npm" "__npm_remove ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __npm_remove "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "npm remove ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    check) # Check to see if node module is installed
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Check npm module"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "npm" "__npm_exists ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __npm_exists --sudo "$pkg" || { printf_red "NPM module $pkg is missing" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "npm check ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    *) # Install node modules
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install node package via npm"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "npm" "__npm_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __npm_run "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "npm ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  go) # GO modules
    shift 1
    case $1 in
    install) # Install GO modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install go modules"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "go" "__go_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __go_run "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "go install ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # Remove GO modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove go modules"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "go" "__go_remove ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __go_remove "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "go remove ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    check) # Check to see if GO module is installed
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Check for go module"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "go" "__go_exists ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __go_exists "$pkg" || { printf_red "go module $pkg is missing" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "go check ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    *) # Install GO modules
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install go modules via"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "go" "__go_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __go_run "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "go ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  lua) # LUA modules
    shift 1
    case $1 in
    install) # Install lua modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install lua modules via luarocks"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "lua" "__lua_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __lua_run "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "lua install ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # Remove lua modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove lua modules via luarocks"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "lua" "__lua_remove ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __lua_remove "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "lua remove ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    check) # Check to see if lua module is installed
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Check for lua module"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "lua" "__lua_exists ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __lua_exists "$pkg" || { printf_red "lua module $pkg is missing" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "lua check ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    *) # Install lua modules
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install lua modules via luarocks"
      __am_i_online || { printf_red "ERROR: No internet connection detected"; exit 1; }
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "lua" "__lua_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __lua_run "$pkg" || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "lua ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  info) # Show system info
    shift 1
    [ "$1" = "help" ] && printf_exit 2 0 "Show info about your system"
    __show_info "${1:-notruncate}"
    ;;

  version) # Show version
    shift 1
    run_install_version "$@"
    exit
    ;;

  bin) # pass everything to $pkgmgrbin
    shift 1
    $pkgmgrbin "$@"
    ;;

  *) # Help
    __help
    ;;
  esac
}

# - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined variables/import external variables

# - - - - - - - - - - - - - - - - - - - - - - - - -
# Application Folders
PKMGR_CONFIG_FILE="${PKMGR_CONFIG_FILE:-settings.conf}"
PKMGR_CONFIG_DIR="${PKMGR_CONFIG_DIR:-$HOME/.config/myscripts/pkmgr}"
PKMGR_CONFIG_BACKUP_DIR="${PKMGR_CONFIG_BACKUP_DIR:-$HOME/.local/share/myscripts/pkmgr/backups}"
PKMGR_LOG_DIR="${PKMGR_LOG_DIR:-$HOME/.local/log/pkmgr}"
PKMGR_TEMP_DIR="${PKMGR_TEMP_DIR:-$HOME/.local/tmp/system_scripts/pkmgr}"
PKMGR_CACHE_DIR="${PKMGR_CACHE_DIR:-$HOME/.cache/pkmgr}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
PKMGR_OUTPUT_COLOR_1="${PKMGR_OUTPUT_COLOR_1:-33}"
PKMGR_OUTPUT_COLOR_2="${PKMGR_OUTPUT_COLOR_2:-5}"
PKMGR_OUTPUT_COLOR_GOOD="${PKMGR_OUTPUT_COLOR_GOOD:-2}"
PKMGR_OUTPUT_COLOR_ERROR="${PKMGR_OUTPUT_COLOR_ERROR:-1}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
PKMGR_NOTIFY_ENABLED="${PKMGR_NOTIFY_ENABLED:-yes}"
PKMGR_GOOD_NAME="${PKMGR_GOOD_NAME:-Great:}"
PKMGR_ERROR_NAME="${PKMGR_ERROR_NAME:-Error:}"
PKMGR_GOOD_MESSAGE="${PKMGR_GOOD_MESSAGE:-No errors reported}"
PKMGR_ERROR_MESSAGE="${PKMGR_ERROR_MESSAGE:-Errors were reported}"
PKMGR_NOTIFY_CLIENT_NAME="${PKMGR_NOTIFY_CLIENT_NAME:-$APPNAME}"
PKMGR_NOTIFY_CLIENT_ICON="${PKMGR_NOTIFY_CLIENT_ICON:-notification-new}"
PKMGR_NOTIFY_CLIENT_URGENCY="${PKMGR_NOTIFY_CLIENT_URGENCY:-normal}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional Variables
CHECK_FOR_UPDATES_CACHE_DIR="${CHECK_FOR_UPDATES_CACHE_DIR:-$HOME/.cache/check-for-updates}"
PKMGR_FORCE_INSTALL="${PKMGR_FORCE_INSTALL:-false}"
PKMGR_NOTIFICATION_EMAIL="${PKMGR_NOTIFICATION_EMAIL:-root}"
PKMGR_OUTPUT_TRUNCATE="${PKMGR_OUTPUT_TRUNCATE:-110}"
PKMGR_LOG_ERROR="${INSTALLER_LOG_ERR:-$PKMGR_LOG_DIR/$APPNAME.err.log}"
PKMGR_LOG_INFO="${INSTALLER_LOG_FILE:-$PKMGR_LOG_DIR/$APPNAME.log}"
PKMGR_GIT_REPO="${PKMGR_GIT_REPO:-$PKMGRREPO}"
PKMGR_GIT_BRANCH="${PKMGR_GIT_BRANCH:-main}"
PKMGR_GIT_DOTFILES="${PKMGR_GIT_DOTFILES:-dotfiles}"
PKMGR_INSTALLED_LIST_DIR="/usr/local/etc/pkmgr/lists"
# - - - - - - - - - - - - - - - - - - - - - - - - -
[ -n "$PKMGR_GIT_REPO" ] || PKMGR_GIT_REPO="${PKMGRREPO:-https://github.com/pkmgr}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Generate config files
[ -f "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE" ] || [ "$*" = "--config" ] || INIT_CONFIG="${INIT_CONFIG:-TRUE}" __gen_config ${SETARGS:-$@}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Import config
[ -f "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE" ] && . "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Ensure Directories exist
[ -d "$PKMGR_LOG_DIR" ] || mkdir -p "$PKMGR_LOG_DIR" |& __devnull
[ -d "$PKMGR_TEMP_DIR" ] || mkdir -p "$PKMGR_TEMP_DIR" |& __devnull
[ -d "$PKMGR_CACHE_DIR" ] || mkdir -p "$PKMGR_CACHE_DIR" |& __devnull
# - - - - - - - - - - - - - - - - - - - - - - - - -
PKMGR_TEMP_FILE="${PKMGR_TEMP_FILE:-$(mktemp $PKMGR_TEMP_DIR/XXXXXX 2>/dev/null)}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup trap to remove temp file
trap '__trap_exit' EXIT
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup notification function
__notifications() {
  __cmd_exists notifications || return
  [ "$PKMGR_NOTIFY_ENABLED" = "yes" ] || return
  [ "$SEND_NOTIFICATION" = "no" ] && return
  (
    export SCRIPT_OPTS="" _DEBUG=""
    export NOTIFY_GOOD_MESSAGE="${NOTIFY_GOOD_MESSAGE:-$PKMGR_GOOD_MESSAGE}"
    export NOTIFY_ERROR_MESSAGE="${NOTIFY_ERROR_MESSAGE:-$PKMGR_ERROR_MESSAGE}"
    export NOTIFY_CLIENT_ICON="${NOTIFY_CLIENT_ICON:-$PKMGR_NOTIFY_CLIENT_ICON}"
    export NOTIFY_CLIENT_NAME="${NOTIFY_CLIENT_NAME:-$PKMGR_NOTIFY_CLIENT_NAME}"
    export NOTIFY_CLIENT_URGENCY="${NOTIFY_CLIENT_URGENCY:-$PKMGR_NOTIFY_CLIENT_URGENCY}"
    notifications "$@"
  ) |& __devnull &
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set custom actions

# - - - - - - - - - - - - - - - - - - - - - - - - -
# Argument/Option settings
SETARGS=("$@")
# - - - - - - - - - - - - - - - - - - - - - - - - -
SHORTOPTS="f"
SHORTOPTS+=""
# - - - - - - - - - - - - - - - - - - - - - - - - -
LONGOPTS="completions:,config,debug,dir:,help,options,raw,version,silent"
LONGOPTS+=",force,enable-aur,raw,enable-log"
# - - - - - - - - - - - - - - - - - - - - - - - - -
ARRAY="check alias available install remove list curl script dotfiles upgrade export import clean "
ARRAY+="init makecache search required silent cpan pip gem npm info version bin lua go"
# - - - - - - - - - - - - - - - - - - - - - - - - -
LIST=""
LIST+=""
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup application options
setopts=$(getopt -o "$SHORTOPTS" --long "$LONGOPTS" -n "$APPNAME" -- "$@" 2>/dev/null)
eval set -- "${setopts[@]}" 2>/dev/null
while :; do
  case "$1" in
  --raw)
    shift 1
    export SHOW_RAW="true"
    NC=""
    RESET=""
    BLACK=""
    RED=""
    GREEN=""
    YELLOW=""
    BLUE=""
    PURPLE=""
    CYAN=""
    WHITE=""
    ORANGE=""
    LIGHTRED=""
    BG_GREEN=""
    BG_RED=""
    ICON_INFO="[ info ]"
    ICON_GOOD="[ ok ]"
    ICON_WARN="[ warn ]"
    ICON_ERROR="[ error ]"
    ICON_QUESTION="[ ? ]"
    printf_column() { tee | grep '^'; }
    printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
    ;;
  --debug)
    shift 1
    set -xo pipefail
    export SCRIPT_OPTS="--debug"
    export _DEBUG="on"
    __devnull() { tee || return 1; }
    __devnull2() { eval "$@" |& tee -p || return 1; }
    ;;
  --completions)
    if [ "$2" = "short" ]; then
      printf '%s\n' "-$SHORTOPTS" | sed 's|"||g;s|:||g;s|,|,-|g' | tr ',' '\n'
    elif [ "$2" = "long" ]; then
      printf '%s\n' "--$LONGOPTS" | sed 's|"||g;s|:||g;s|,|,--|g' | tr ',' '\n'
    elif [ "$2" = "array" ]; then
      printf '%s\n' "$ARRAY" | sed 's|"||g;s|:||g' | tr ',' '\n'
    elif [ "$2" = "list" ]; then
      printf '%s\n' "$LIST" | sed 's|"||g;s|:||g' | tr ',' '\n'
    else
      exit 1
    fi
    shift 2
    exit $?
    ;;
  --options)
    shift 1
    printf_blue "Current options for ${PROG:-$APPNAME}"
    [ -z "$SHORTOPTS" ] || __list_options "Short Options" "-${SHORTOPTS}" ',' '-' 4
    [ -z "$LONGOPTS" ] || __list_options "Long Options" "--${LONGOPTS}" ',' '--' 4
    [ -z "$ARRAY" ] || __list_options "Base Options" "${ARRAY}" ',' '' 4
    [ -z "$LIST" ] || __list_options "LIST Options" "${LIST}" ',' '' 4
    exit $?
    ;;
  --version)
    shift 1
    __version
    exit $?
    ;;
  --help)
    shift 1
    __help
    exit $?
    ;;
  --config)
    shift 1
    __gen_config
    exit $?
    ;;
  --silent)
    shift 1
    PKMGR_SILENT="true"
    ;;
  --dir)
    CWD_IS_SET="TRUE"
    PKMGR_CWD="$2"
    #[ -d "$PKMGR_CWD" ] || mkdir -p "$PKMGR_CWD" |& __devnull
    shift 2
    ;;
  -f | --force)
    shift 1
    export FORCE_INSTALL="true"
    ;;
  --enable-aur)
    shift 1
    ENABLE_AUR="true"
    ;;
  -a | --all)
    shift 1
    INSTALL_ALL="true"
    ;;
  --enable-log)
    shift 1
    PKMGR_LOG_ENABLED="true"
    __logging() { tee -a "$PKMGR_LOG_INFO" || false; }
    __devnull2() { eval "$@" 2>>"$PKMGR_LOG_ERROR" || false; }
    __devnull() { tee -a "$PKMGR_LOG_INFO" "$PKMGR_LOG_ERROR" || false; }
    ;;
  --)
    shift 1
    break
    ;;
  esac
done
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Get directory from args
# set -- "$@"
# for arg in "$@"; do
# if [ -d "$arg" ]; then
# PKMGR_CWD="$arg" && shift 1 && SET_NEW_ARGS=("$@") && break
# elif [ -f "$arg" ]; then
# PKMGR_CWD="$(dirname "$arg" 2>/dev/null)" && shift 1 && SET_NEW_ARGS=("$@") && break
# else
# SET_NEW_ARGS+=("$arg")
# fi
# done
# set -- "${SET_NEW_ARGS[@]}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set directory to first argument
# [ -d "$1" ] && __is_an_option "$1" && PKMGR_CWD="$1" && shift 1 || PKMGR_CWD="${PKMGR_CWD:-$PWD}"
PKMGR_CWD="$(realpath "${PKMGR_CWD:-$PWD}" 2>/dev/null)"
# if [ -d "$PKMGR_CWD" ] && cd "$PKMGR_CWD"; then
# if [ "$PKMGR_SILENT" != true ]; then
# printf_cyan "Setting working dir to $PKMGR_CWD"
# fi
# else
# printf_exit "💔 $PKMGR_CWD does not exist 💔"
# fi
export PKMGR_CWD
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set actions based on variables
[ -d "$CHECK_FOR_UPDATES_CACHE_DIR" ] || mkdir -p "$CHECK_FOR_UPDATES_CACHE_DIR"

# - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for required applications/Network check
#__requiresudo "$0" "$@" || exit 2     # exit 2 if errors
#cmd_exists --error --ask bash || exit 3 # exit 3 if not found
#am_i_online --error || exit 4           # exit 4 if no internet
# - - - - - - - - - - - - - - - - - - - - - - - - -
# APP Variables overrides
exitCode=0
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions based on env
if __user_is_not_root; then
  __sudoif && __sudoask || printf_exit "This requires sudo privileges"
fi
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute functions

# - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute commands

# - - - - - - - - - - - - - - - - - - - - - - - - -
# begin main app
__initialize_variables "$@"
__execute_pkmgr "$@"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set exit code
exitCode="${exitCode:-0}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# End application
# - - - - - - - - - - - - - - - - - - - - - - - - -
# lets exit with code
exit ${exitCode:-0}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# ex: ts=2 sw=2 et filetype=sh
