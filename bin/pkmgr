#!/usr/bin/env bash
# shellcheck shell=bash
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
##@Version           :  202409241530-git
# @@Author           :  Jason Hempstead
# @@Contact          :  jason@casjaysdev.pro
# @@License          :  WTFPL
# @@ReadME           :  pkmgr --help
# @@Copyright        :  Copyright: (c) 2022 Jason Hempstead, Casjays Developments
# @@Created          :  Friday, Aug 19, 2022 16:56 EDT
# @@File             :  pkmgr
# @@Description      :  Manage system packages
# @@Changelog        :  Fixed buffering issues with enhanced unbuffered output for real-time package installation status
# @@TODO             :  Better progress indicators and status displays
# @@Other            :
# @@Resource         :
# @@Terminal App     :  no
# @@sudo/root        :  yes
# @@Template         :  bash/system
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# shellcheck disable=SC1001,SC1003,SC2001,SC2003,SC2016,SC2031,SC2120,SC2155,SC2199,SC2317,SC2329
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
APPNAME="$(basename -- "$0" 2>/dev/null)"
VERSION="202409241530-git"
USER="${SUDO_USER:-$USER}"
RUN_USER="${RUN_USER:-$USER}"
USER_HOME="${USER_HOME:-$HOME}"
SCRIPT_SRC_DIR="${BASH_SOURCE%/*}"
PKMGR_REQUIRE_SUDO="${PKMGR_REQUIRE_SUDO:-no}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Reopen in a terminal
#if [ ! -t 0 ] && { [ "$1" = --term ] || [ $# = 0 ]; }; then { [ "$1" = --term ] && shift 1 || true; } && TERMINAL_APP="TRUE" myterminal -e "$APPNAME $*" && exit || exit 1; fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set script title
#CASJAYS_DEV_TILE_FORMAT="${USER}@${HOSTNAME}:${PWD//$HOME/\~} - $APPNAME"
#CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}"
#[ -z "$CASJAYSDEV_TITLE_SET" ] && printf '\033]2│;%s\033\\' "$CASJAYS_DEV_TILE_FORMAT" && CASJAYSDEV_TITLE_SET="$APPNAME"
export CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}" CASJAYSDEV_TITLE_SET
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Initial debugging
[ "$1" = "--debug" ] && set -x && export SCRIPT_OPTS="--debug" && export _DEBUG="on"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Disables colorization
[ "$1" = "--raw" ] && export SHOW_RAW="true"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# pipes fail
set -o pipefail
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Import functions
CASJAYSDEVDIR="${CASJAYSDEVDIR:-/usr/local/share/CasjaysDev/scripts}"
SCRIPTSFUNCTDIR="${CASJAYSDEVDIR:-/usr/local/share/CasjaysDev/scripts}/functions"
SCRIPTSFUNCTFILE="${SCRIPTSAPPFUNCTFILE:-testing.bash}"
SCRIPTSFUNCTURL="${SCRIPTSAPPFUNCTURL:-https://github.com/dfmgr/installer/raw/main/functions}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
if [ -f "$PWD/$SCRIPTSFUNCTFILE" ]; then
  . "$PWD/$SCRIPTSFUNCTFILE"
elif [ -f "$SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE" ]; then
  . "$SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE"
else
  echo "Can not load the functions file: $SCRIPTSFUNCTDIR/$SCRIPTSFUNCTFILE" 1>&2
  exit 1
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Options are: *_install
# system user desktopmgr devenvmgr dfmgr dockermgr fontmgr iconmgr pkmgr systemmgr thememgr wallpapermgr
user_install && __options "$@"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# import system variables
[ -f "/usr/local/bin/detectostype" ] && . "/usr/local/bin/detectostype"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Send all output to /dev/null
__devnull() {
  tee &>/dev/null && exitCode=0 || exitCode=1
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'
# Send errors to /dev/null
__devnull2() {
  [ -n "$1" ] && local cmd="$1" && shift 1 || return 1
  eval $cmd "$*" 2>/dev/null && exitCode=0 || exitCode=1
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'
# See if the executable exists
__cmd_exists() {
  local exitCode=0
  [ -n "$1" ] || return 0
  for cmd in "$@"; do
    if builtin command -v "$cmd" &>/dev/null; then
      exitCode=$((exitCode + 0))
    else
      exitCode=$((exitCode + 1))
    fi
  done
  [ $exitCode -eq 0 ] || exitCode=3
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for a valid internet connection
__am_i_online() {
  local exitCode=0
  curl -q -LSsfI --max-time 2 --retry 1 "${1:-https://1.1.1.1}" 2>&1 | grep -qi 'server:.*cloudflare' || exitCode=4
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# colorization
if [ "$SHOW_RAW" = "true" ]; then
  NC=""
  RESET=""
  BLACK=""
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  PURPLE=""
  CYAN=""
  WHITE=""
  ORANGE=""
  LIGHTRED=""
  BG_GREEN=""
  BG_RED=""
  ICON_INFO="[ info ]"
  ICON_GOOD="[ ok ]"
  ICON_WARN="[ warn ]"
  ICON_ERROR="[ error ]"
  ICON_QUESTION="[ ? ]"
  printf_column() { tee | grep --line-buffered '^'; }
  printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
else
  printf_color() { printf "%b" "$(tput setaf "${2:-7}" 2>/dev/null)" "$1" "$(tput sgr0 2>/dev/null)"; }
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional printf_ colors
__printf_head() { printf_blue "$1"; }
__printf_opts() { printf_purple "$1"; }
__printf_line() { printf_cyan "$1"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# output version
__version() { printf_cyan "$VERSION"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# list options
__list_options() {
  printf_color "$1: " "$5"
  echo -ne "$2" | sed 's|:||g;s/'$3'/ '$4'/g' | tr '\n' ' '
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# create the config file
__gen_config() {
  local NOTIFY_CLIENT_NAME="$APPNAME"
  if [ "$INIT_CONFIG" != "TRUE" ]; then
    printf_blue "Generating the config file in"
    printf_cyan "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE"
  fi
  [ -d "$PKMGR_CONFIG_DIR" ] || mkdir -p "$PKMGR_CONFIG_DIR"
  [ -d "$PKMGR_CONFIG_BACKUP_DIR" ] || mkdir -p "$PKMGR_CONFIG_BACKUP_DIR"
  [ -f "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE" ] &&
    cp -Rf "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE" "$PKMGR_CONFIG_BACKUP_DIR/$PKMGR_CONFIG_FILE.$$"
  cat <<EOF >"$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE"
# Settings for pkmgr
PKMGR_FORCE_INSTALL="false"
PKMGR_GIT_REPO="${PKMGR_GIT_REPO:-}"
PKMGR_GIT_BRANCH="${PKMGR_GIT_BRANCH:-}"
PKMGR_GIT_DOTFILES="${PKMGR_GIT_DOTFILES:-}"
PKMGR_NOTIFICATION_EMAIL="${PKMGR_NOTIFICATION_EMAIL:-}"
PKMGR_OUTPUT_TRUNCATE="${PKMGR_OUTPUT_TRUNCATE:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
PKMGR_OUTPUT_COLOR_1="${PKMGR_OUTPUT_COLOR_1:-}"
PKMGR_OUTPUT_COLOR_2="${PKMGR_OUTPUT_COLOR_2:-}"
PKMGR_OUTPUT_COLOR_GOOD="${PKMGR_OUTPUT_COLOR_GOOD:-}"
PKMGR_OUTPUT_COLOR_ERROR="${PKMGR_OUTPUT_COLOR_ERROR:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
PKMGR_NOTIFY_ENABLED="${PKMGR_NOTIFY_ENABLED:-}"
PKMGR_GOOD_NAME="${PKMGR_GOOD_NAME:-}"
PKMGR_ERROR_NAME="${PKMGR_ERROR_NAME:-}"
PKMGR_GOOD_MESSAGE="${PKMGR_GOOD_MESSAGE:-}"
PKMGR_ERROR_MESSAGE="${PKMGR_ERROR_MESSAGE:-}"
PKMGR_NOTIFY_CLIENT_NAME="${PKMGR_NOTIFY_CLIENT_NAME:-}"
PKMGR_NOTIFY_CLIENT_ICON="${PKMGR_NOTIFY_CLIENT_ICON:-}"
PKMGR_NOTIFY_CLIENT_URGENCY="${PKMGR_NOTIFY_CLIENT_URGENCY:-}"

EOF
  if builtin type -t __gen_config_local | grep -q 'function'; then __gen_config_local; fi
  if [ -f "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE" ]; then
    [ "$INIT_CONFIG" = "TRUE" ] || printf_green "Your config file for $APPNAME has been created"
    . "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE"
    exitCode=0
  else
    printf_red "Failed to create the config file"
    exitCode=1
  fi
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Help function - Align to 50
__help() {
  # info|version|check|available|init|makecache|aliases|cron|ask|export|clean|search|keys|list|curl|dotfiles|script|required|reinstall|install|upgrade|remove
  # silent[install,remove,upgrade]|bin|perl[install,remove,check]|pip[install,remove,check]|gem[install,remove,check]|npm[install,remove,check]|go[install,remove,check]|lua[install,remove,check]
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "pkmgr:  Manage system packages - $VERSION"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "Usage: pkmgr [options] [commands]"
  __printf_line 'pkmgr dotfiles                  - install required packages    |pkmgr dotfiles git'
  __printf_line 'pkmgr list                      - install from a file          |pkmgr list [full path to list]'
  __printf_line 'pkmgr curl                      - install from a url           |pkmgr curl debian min'
  __printf_line 'pkmgr script                    - run a script                 |pkmgr script [ ./pathToScript or http://fullurltoscript ]'
  __printf_line 'pkmgr search                    - find a package               |pkmgr search myapp'
  __printf_line 'pkmgr search -i                 - interactive package search    |pkmgr search -i vim'
  __printf_line 'pkmgr install                   - install a package            |pkmgr install myapp'
  __printf_line 'pkmgr install -i                - interactive package install   |pkmgr install -i'
  __printf_line 'pkmgr remove                    - remove a package             |pkmgr remove myapp'
  __printf_line 'pkmgr remove -i                 - interactive package removal   |pkmgr remove -i'
  __printf_line 'pkmgr update                    - update all packages          |pkmgr update'
  __printf_line 'pkmgr clean                     - Removes cached files         |pkmgr clean'
  __printf_line 'pkmgr makecache                 - update package lists         |pkmgr makecache'
  __printf_line 'pkmgr silent                    - silently install package     |pkmgr silent myapp'
  __printf_line 'pkmgr silent remove             - silently remove package      |pkmgr silent remove myapp'
  __printf_line 'pkmgr silent upgrade            - silently upgrade package     |pkmgr silent upgrade myapp'
  __printf_line 'pkmgr cron add                  - schedule daily updates       |pkmgr cron add'
  __printf_line 'pkmgr aliases                   - lists the alias for bash     |pkmgr alias'
  __printf_line 'pkmgr pip                       - install a python package     |pkmgr pip requests'
  __printf_line 'pkmgr cpan                      - install a perl module        |pkmgr cpan Bundle::Apache'
  __printf_line 'pkmgr gem                       - install a gem module         |pkmgr gem jekyll'
  __printf_line 'pkmgr npm                       - install a nodejs module      |pkmgr npm express'
  __printf_line 'pkmgr cmd help                  - show help for the command    |pkmgr aliases --help'
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "--force                         - Force install"
  __printf_line "--enable-aur                    - Enables the aur on arch systems"
  __printf_line "--interactive, -i               - Interactive mode with fzf/dialog"
  __printf_line "PKMGR_SHOW_PROGRESS=true        - Enable progress indicators"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Other Options"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "--help                          - Shows this message"
  __printf_line "--config                        - Generate user config file"
  __printf_line "--version                       - Show script version"
  __printf_line "--options                       - Shows all available options"
  __printf_line "--debug                         - Enables script debugging"
  __printf_line "--raw                           - Removes all formatting on output"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# check if arg is a builtin option
__is_an_option() { if echo "$ARRAY" | grep -q "${1:-^}"; then return 1; else return 0; fi; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Is current user root
__user_is_root() {
  { [ $(id -u) -eq 0 ] || [ $EUID -eq 0 ] || [ "$WHOAMI" = "root" ]; } && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Is current user not root
__user_is_not_root() {
  if { [ $(id -u) -eq 0 ] || [ $EUID -eq 0 ] || [ "$WHOAMI" = "root" ]; }; then return 1; else return 0; fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check if user is a member of sudo
__sudo_group() {
  grep -sh "${1:-$USER}" "/etc/group" | grep -Eq 'wheel|adm|sudo' || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# # Get sudo password
__sudoask() {
  local PATH="$SCRIPT_SRC_DIR:$PATH"
  sudo true && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run sudo
__sudorun() {
  __sudoif && __cmd_exists sudo && sudo -HE "$@" || { __sudoif && eval "$@"; }
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Test if user has access to sudo
__can_i_sudo() {
  (sudo -vn && sudo -ln) 2>&1 | grep -vq 'may not' >/dev/null && return 0
  __sudo_group "${1:-$USER}" || __sudoif || __sudo true &>/dev/null || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User can run sudo
__sudoif() {
  __user_is_root && return 0
  __can_i_sudo "${RUN_USER:-$USER}" && return 0
  __user_is_not_root && __sudoask && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Run command as root
__requiresudo() {
  if [ "$PKMGR_REQUIRE_SUDO" = "yes" ] && [ -z "$PKMGR_REQUIRE_SUDO_RUN" ]; then
    export PKMGR_REQUIRE_SUDO="no"
    export PKMGR_REQUIRE_SUDO_RUN="true"
    __sudo "$@"
    exit $?
  else
    return 0
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute sudo
__sudo() {
  CMD="${1:-echo}" && shift 1
  CMD_ARGS="${*:--e "${RUN_USER:-$USER}"}"
  SUDO="$(builtin command -v sudo 2>/dev/null || echo 'eval')"
  [ "$(basename -- "$SUDO" 2>/dev/null)" = "sudo" ] && OPTS="--preserve-env=PATH -HE"
  if __sudoif; then
    export PATH="$PATH"
    $SUDO ${OPTS:-} $CMD $CMD_ARGS && true || false
    exitCode=$?
  else
    printf '%s\n' "This requires root to run"
    exitCode=1
  fi
  return ${exitCode:-1}
}
# End of sudo functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__trap_exit() {
  exitCode=${exitCode:-0}
  [ -f "$PKMGR_TEMP_FILE" ] && rm -Rf "$PKMGR_TEMP_FILE" &>/dev/null
  #unset CASJAYSDEV_TITLE_SET && printf '\033]2│;%s\033\\' "${USER}@${HOSTNAME}:${PWD//$HOME/\~} - ${CASJAYSDEV_TITLE_PREV:-$SHELL}"
  if builtin type -t __trap_exit_local | grep -q 'function'; then __trap_exit_local; fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute command with unbuffered output  
__exec_unbuffered() {
  # Force unbuffered output for package managers with environment variables
  local cmd="$*"
  
  # Set environment variables to force unbuffered output
  export PYTHONUNBUFFERED=1
  export PAGER=""
  export SYSTEMD_PAGER=""
  export APT_LISTCHANGES_FRONTEND=none
  
  if command -v unbuffer >/dev/null 2>&1; then
    # Use unbuffer (from expect) for full unbuffering - best option
    unbuffer bash -c "$cmd"
  elif command -v stdbuf >/dev/null 2>&1; then
    # Use stdbuf with immediate flush and TTY simulation
    stdbuf -o0 -e0 bash -c "exec 2>&1; $cmd"
  elif command -v script >/dev/null 2>&1; then
    # Use script command to force TTY mode for pacman
    script -qefc "$cmd" /dev/null
  else
    # Last resort - direct execution with forced output
    bash -c "exec 2>&1; $cmd"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined functions
__saved_file_create() { echo "$1" | sudo tee "${PKMGR_INSTALLED_LIST_DIR:-/usr/local/etc/pkmgr/lists}/$1" &>/dev/null || true; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__saved_file_delete() { [ -f "$PKMGR_INSTALLED_LIST_DIR/$1" ] && rm -f "$PKMGR_INSTALLED_LIST_DIR/$1" || true; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__not_installed() { echo -ne "${RED}Not Installed${NC}"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__is_url() { echo "${1:-$url}" | grep -qE '^http://|^https://|^ftp://' || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__logging() {
  # Pass through output immediately without buffering
  # Only log to files if they are defined
  if [ -n "$PKMGR_LOG_INFO" ] && [ -f "$PKMGR_LOG_INFO" -o -w "$(dirname "$PKMGR_LOG_INFO" 2>/dev/null)" ]; then
    # Log file is defined and writable, use tee
    if command -v stdbuf >/dev/null 2>&1; then
      # Force line buffering for real-time output
      stdbuf -oL -eL tee -a "$PKMGR_LOG_INFO"
    else
      tee -a "$PKMGR_LOG_INFO"
    fi
  else
    # No logging, just pass through with cat
    cat
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__log_info() { 
  if command -v stdbuf >/dev/null 2>&1; then
    stdbuf -oL -eL tee -a "$PKMGR_LOG_INFO" || tee -a "$PKMGR_LOG_INFO" || return 1
  else
    tee -a "$PKMGR_LOG_INFO" || return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__log_error() { 
  if command -v stdbuf >/dev/null 2>&1; then
    stdbuf -oL -eL tee -a "$PKMGR_LOG_ERROR" || tee -a "$PKMGR_LOG_ERROR" || return 1
  else
    tee -a "$PKMGR_LOG_ERROR" || return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__silent_log_file() { tee -a "${2:-$PKMGR_LOG_INFO}" &>/dev/null || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__init_log_status() { printf '### Starting %s on: %s\n%s\n' "$1" "$(date)" "Command: $2" | tee -a "${3:-$PKMGR_LOG_INFO}" &>/dev/null; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__write_log_status() {
  printf '%s\n' "$1" | tee -a "${2:-$PKMGR_LOG_INFO}" &>/dev/null
  printf '### Completed on: %s\n\n' "$(date)" | tee -a "${2:-$PKMGR_LOG_INFO}" &>/dev/null
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__run_updatecheck() { __am_i_online && __pkmgrcheckupdates || echo "0"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__rm_rf() { sudo rm -Rf "$@"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__cp_rf() { sudo cp -Rf "$@"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__trap_exit_local() {
  local exitCodeE=${exitCode:-$?}
  if [ -n "$SUDO_USER" ] && __user_is_not_root; then
    sudo chown $SUDO_USER:$SUDO_USER "$PKMGR_CACHE_DIR" "$PKMGR_CONFIG_DIR" "$PKMGR_LOG_DIR" "$PKMGR_TEMP_DIR"
  fi
  return ${exitCodeE:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__curl() {
  __am_i_online || return 2
  curl --disable -LSsfk --connect-timeout 3 --retry 0 "$@" 2>/dev/null || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__default_mirror_list_archlinux() {
  cat <<EOF
# United States
Server = http://mirrors.mit.edu/archlinux/\$repo/os/\$arch
Server = https://mirrors.mit.edu/archlinux/\$repo/os/\$arch
Server = http://mirrors.ocf.berkeley.edu/archlinux/\$repo/os/\$arch
Server = https://mirrors.ocf.berkeley.edu/archlinux/\$repo/os/\$arch
Server = http://mirror.siena.edu/archlinux/\$repo/os/\$arch

EOF
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__list_install() {
  local exitCode=0
  if __is_url "$1"; then
    __curl_run "$@"
    PCKLIST="$(grep -sh -Ev '^$|^#' "$PKMGR_TEMP_FILE" | sort -u | tr '\n' ' ' || false)"
  else
    PCKLIST="$(grep -sh -Ev '^$|^#' "$1" | sort -u | tr '\n' ' ' || false)"
  fi
  if [ -n "$PCKLIST" ]; then
    for pkg in $PCKLIST; do
      __execute "$pkgmgrbininssil $pkg" "Installing $pkg" && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
    done
  fi
  [ $exitCode -eq 0 ] && exitCode=0 || exitCode="${exitCode:-1}"
  return ${exitCode:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__searchcmd() {
  local pkgs="$*"
  local exitCode=0
  local search_name=""
  local -a package_name=()
  local found_packages=false
  
  for pkg in $pkgs; do
    if __cmd_exists pacman; then
      search_name="$($pkgmgrbinsea "$pkg" 2>&1 | grep -v 'Warning: No matches' | awk '{printf (NR%2==0) ? $0 "\n" : $0}' 2>/dev/null |& grep -i $pkg 2>/dev/null | sed 's|^.*/||g' | sed 's#    #: #g' | grep ':' | grep '^')"
    else
      search_name="$($pkgmgrbinsea "$pkg" 2>&1 | grep -v 'Warning: No matches' |& grep -i $pkg 2>/dev/null | grep '^' 2>/dev/null || echo '')"
    fi
    
    if [ -n "$search_name" ] && [ "$search_name" != "" ]; then
      package_name+=("$search_name")
      found_packages=true
    fi
  done
  
  if [ "$found_packages" = "true" ] && [ ${#package_name[@]} -gt 0 ]; then
    printf '%s\n' "${package_name[@]}" |& grep --line-buffered -v '^$' | cut -c 1-${PKMGR_OUTPUT_TRUNCATE:-200} | grep --line-buffered '^'
    exitCode=0
  else
    printf_red "No packages found matching: $pkgs" 1>&2
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Interactive package selection using fzf, dialog, or fallback
__interactive_select() {
  local title="${1:-Select Packages}"
  local multi="${2:-true}"  # Allow multiple selections by default
  local -a items=("${@:3}")
  local selected=""
  
  if [ ${#items[@]} -eq 0 ]; then
    printf_red "No items to select from"
    return 1
  fi
  
  # Try fzf first (most modern and user-friendly)
  if __cmd_exists fzf && [ -t 0 ]; then
    if [ "$multi" = "true" ]; then
      selected=$(printf '%s\n' "${items[@]}" | fzf --multi --height=40% --reverse --header="$title (Tab to select, Enter to confirm)" --prompt="Search: ")
    else
      selected=$(printf '%s\n' "${items[@]}" | fzf --height=40% --reverse --header="$title" --prompt="Search: ")
    fi
  # Try dialog
  elif __cmd_exists dialog && [ -t 0 ]; then
    local -a dialog_items=()
    for item in "${items[@]}"; do
      dialog_items+=("$item" "" "off")
    done
    if [ "$multi" = "true" ]; then
      selected=$(dialog --title "$title" --checklist "Select packages (Space to select):" 20 60 10 "${dialog_items[@]}" 2>&1 >/dev/tty)
    else
      selected=$(dialog --title "$title" --radiolist "Select package:" 20 60 10 "${dialog_items[@]}" 2>&1 >/dev/tty)
    fi
  # Try whiptail
  elif __cmd_exists whiptail && [ -t 0 ]; then
    local -a whiptail_items=()
    for item in "${items[@]}"; do
      whiptail_items+=("$item" "" "OFF")
    done
    if [ "$multi" = "true" ]; then
      selected=$(whiptail --title "$title" --checklist "Select packages (Space to select):" 20 60 10 "${whiptail_items[@]}" 3>&1 1>&2 2>&3)
    else
      selected=$(whiptail --title "$title" --radiolist "Select package:" 20 60 10 "${whiptail_items[@]}" 3>&1 1>&2 2>&3)
    fi
  # Fallback to numbered list
  else
    printf_cyan "$title\n"
    printf_cyan "════════════════════════════════════════\n"
    local i=1
    for item in "${items[@]}"; do
      printf "%3d) %s\n" "$i" "$item"
      ((i++))
    done
    printf_cyan "════════════════════════════════════════\n"
    if [ "$multi" = "true" ]; then
      printf_green "Enter numbers separated by spaces (e.g., 1 3 5) or 'all' for all: "
      read -r selection
      if [ "$selection" = "all" ]; then
        selected="${items[*]}"
      else
        for num in $selection; do
          if [[ "$num" =~ ^[0-9]+$ ]] && [ "$num" -ge 1 ] && [ "$num" -le "${#items[@]}" ]; then
            selected="${selected}${items[$((num-1))]} "
          fi
        done
      fi
    else
      printf_green "Enter number: "
      read -r selection
      if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -le "${#items[@]}" ]; then
        selected="${items[$((selection-1))]}"
      fi
    fi
  fi
  
  echo "$selected" | tr '\n' ' ' | sed 's/^ *//;s/ *$//'
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Progress indicators
__show_progress() {
  local pid="${1:-}"
  local message="${2:-Processing}"
  local spinner_chars='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
  local i=0
  
  if [ -z "$pid" ]; then
    return 1
  fi
  
  # Hide cursor
  printf '\033[?25l'
  
  while kill -0 "$pid" 2>/dev/null; do
    printf "\r${CYAN}[${spinner_chars:i:1}]${NC} %s... " "$message"
    i=$(( (i+1) % ${#spinner_chars} ))
    sleep 0.1
  done
  
  # Show cursor
  printf '\033[?25h'
  printf "\r${GREEN}[✓]${NC} %s... Done!    \n" "$message"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Progress bar for downloads or operations with known total
__progress_bar() {
  local current="${1:-0}"
  local total="${2:-100}"
  local width="${3:-50}"
  local title="${4:-Progress}"
  
  if [ "$total" -eq 0 ]; then
    total=1
  fi
  
  local percentage=$((current * 100 / total))
  local filled=$((percentage * width / 100))
  local empty=$((width - filled))
  
  # Build the bar
  printf "\r%s: [" "$title"
  printf "%${filled}s" | tr ' ' '█'
  printf "%${empty}s" | tr ' ' '░'
  printf "] %3d%%" "$percentage"
  
  if [ "$current" -ge "$total" ]; then
    printf "\n"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Enhanced status display with timing
__status_display() {
  local operation="${1:-Operation}"
  local status="${2:-running}"  # running, success, failed, warning
  local details="${3:-}"
  local start_time="${4:-}"
  
  local icon=""
  local color=""
  
  case "$status" in
    running) icon="⚡"; color="${YELLOW}" ;;
    success) icon="✓"; color="${GREEN}" ;;
    failed) icon="✗"; color="${RED}" ;;
    warning) icon="⚠"; color="${PURPLE}" ;;
    *) icon="•"; color="${CYAN}" ;;
  esac
  
  # Calculate elapsed time if start_time provided
  local elapsed=""
  if [ -n "$start_time" ] && [ "$start_time" -ne 0 ]; then
    local current_time=$(date +%s)
    local diff=$((current_time - start_time))
    if [ $diff -gt 0 ]; then
      elapsed=" ($(printf '%02d:%02d' $((diff/60)) $((diff%60))))"
    fi
  fi
  
  printf "${color}[%s]${NC} %s%s" "$icon" "$operation" "$elapsed"
  
  if [ -n "$details" ]; then
    printf " - %s" "$details"
  fi
  
  printf "\n"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Enhanced package operation with progress
__execute_with_progress() {
  local cmd="$1"
  local message="${2:-Executing}"
  local start_time=$(date +%s)
  
  # Start command in background
  eval "$cmd" &
  local pid=$!
  
  # Show progress spinner
  __show_progress "$pid" "$message"
  
  # Wait for command to finish and get exit code
  wait "$pid"
  local exitCode=$?
  
  # Show final status
  if [ $exitCode -eq 0 ]; then
    __status_display "$message" "success" "Completed successfully" "$start_time"
  else
    __status_display "$message" "failed" "Failed with exit code $exitCode" "$start_time"
  fi
  
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Define output
# Enhanced with progress support
__pipecmd() {
  if [ -n "$PKMGR_SHOW_PROGRESS" ] && [ "$PKMGR_SHOW_PROGRESS" = "true" ]; then
    # Use progress indicator for operations
    while IFS= read -r line; do
      printf_readline_trunc $PKMGR_OUTPUT_COLOR_1 $PKMGR_OUTPUT_TRUNCATE <<< "$line"
    done
  else
    printf_readline_trunc $PKMGR_OUTPUT_COLOR_1 $PKMGR_OUTPUT_TRUNCATE
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Perl/CPAN functions
__cpan_run() {
  local cpandir="" cpanconf="" cpanfile="" local_config=""
  local packages="$*"

  # Check if cpan is installed, if not try to install it
  cpan="$(type -P cpan 2>/dev/null | grep -v "$HOME" | grep '^')"
  if [[ -z "$cpan" ]]; then
    printf_yellow "CPAN not found, attempting to install..."

    # Map and install the appropriate CPAN package
    local cpan_pkg="$(__map_package_name "cpan")"
    if ! __exec_unbuffered "$pkgmgrbininssil $cpan_pkg" >/dev/null 2>&1; then
      # Try cpanminus as alternative
      cpan_pkg="$(__map_package_name "cpanminus")"
      if ! __exec_unbuffered "$pkgmgrbininssil $cpan_pkg" >/dev/null 2>&1; then
        printf_red "ERROR: Failed to install CPAN"
        return 1
      fi
    fi

    # Re-check for cpan
    cpan="$(type -P cpan 2>/dev/null | grep -v "$HOME" | grep '^')"
    if [[ -z "$cpan" ]]; then
      # Try cpanm as fallback
      cpan="$(type -P cpanm 2>/dev/null | grep -v "$HOME" | grep '^')"
      if [[ -z "$cpan" ]]; then
        printf_red "ERROR: CPAN installation failed"
        return 1
      fi
    fi
  fi
  
  # Find CPAN directory
  cpandir="$(__devnull2 find /usr/share/perl* /usr/local/share/perl* -path '*/CPAN/Version.pm' 2>/dev/null | sed 's#/Version.pm##g' | head -n1)"
  if [[ -z "$cpandir" ]]; then
    printf_red "Cannot find CPAN directory"
    return 1
  fi
  
  cpanfile="$cpandir/Config.pm"
  
  # Check for local config file first
  local_config="/home/jason/Projects/github/casjay-dotfiles/server/usr/share/perl5/CPAN/Config.pm"
  if [ -f "$local_config" ]; then
    # Use local config
    if [ ! -f "$cpanfile" ] || [ ! -f "$cpandir/.init" ]; then
      printf_green "Installing CPAN config from local file"
      sudo cp "$local_config" "$cpanfile" &&
        sudo touch "$cpandir/.init" || return 1
    fi
  else
    # Fall back to downloading
    cpanconf="https://raw.githubusercontent.com/casjay-base/centos/master/usr/share/perl5/CPAN/Config.pm"
    if [ ! -f "$cpanfile" ] || [ ! -f "$cpandir/.init" ]; then
      printf_green "Downloading CPAN config file"
      __urlcheck "$cpanconf" &&
        __curl "$cpanconf" | sudo tee "$cpanfile" &>/dev/null &&
        sudo touch "$cpandir/.init" || return 1
    fi
  fi
  
  # Install packages
  printf_cyan "Installing CPAN modules: $packages"
  if command -v stdbuf >/dev/null 2>&1; then
    stdbuf -oL -eL sudo bash -c "$cpan notest install $packages" || return 1
  else
    sudo bash -c "$cpan notest install $packages" || return 1
  fi
}
__cpan_remove() {
  local packages="$*"
  
  # Check if cpan is installed
  cpan="$(type -P cpan 2>/dev/null | grep -v "$HOME" | grep '^')"
  if [[ -z "$cpan" ]]; then
    printf_red "CPAN is not installed"
    return 1
  fi
  
  # Check if App::cpanminus is available for uninstall
  if perl -MApp::cpanminus::fatscript -e 1 2>/dev/null || __cmd_exists cpanm; then
    printf_cyan "Removing CPAN modules: $packages"
    if __cmd_exists cpanm; then
      sudo cpanm --uninstall $packages || return 1
    else
      printf_yellow "Note: CPAN uninstall may not remove all files. Consider using cpanm for better uninstall support."
      sudo bash -c "$cpan --uninstall $packages" || return 1
    fi
  else
    printf_yellow "cpanm not found, using basic CPAN uninstall (may not remove all files)"
    sudo bash -c "$cpan --uninstall $packages" || return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Python/PIP functions
__pip_run() {
  local packages="$*"
  local pip_opts=""
  local exitCode=0
  local failed_packages=""

  # Find python and pip
  py_bin="$(type -P python3 || type -P python2 || type -P python)"
  if [[ -z "$py_bin" ]]; then
    printf_red "ERROR: Python not found"
    return 1
  fi

  # Get python version
  py_version="$($py_bin --version 2>&1 | sed 's|[pP]ython ||g' | awk -F '.' '{print $1$2}' | grep '[0-9]' || echo "0")"

  # Find pip
  pip3="$(ls /usr/bin/pip*3* 2>/dev/null | head -n 1)"
  pip="$(type -P $pip3 || type -P pip3 || type -P pip || echo "$py_bin -m pip")"

  # Check if pip is actually available
  if ! $py_bin -m pip --version &>/dev/null; then
    printf_red "ERROR: pip not installed"
    return 1
  fi

  # Set pip options based on Python version
  pip_opts="--quiet --no-input --disable-pip-version-check"
  if [ "$py_version" -le "310" ]; then
    pip_opts="$pip_opts --use-pep517"
  elif [ "$py_version" -gt "310" ]; then
    pip_opts="$pip_opts --break-system-packages"
  fi

  # Determine installation location
  # Prefer user installation to avoid system directory conflicts
  local install_location=""
  if [ "$USER" = "root" ] && [ -z "$SUDO_USER" ]; then
    # Running as root without sudo - install to /usr/local
    install_location="/usr/local"
    pip_opts="$pip_opts --prefix=$install_location"
  else
    # User installation (preferred)
    pip_opts="$pip_opts --user"
  fi

  # Install packages silently
  for pkg in $packages; do
    local output_file="/tmp/pip_install_$$.log"

    if [ -n "$SUDO_USER" ] && [ "$USER" = "root" ]; then
      # Run as sudo user with their home directory
      if sudo -HE -u $SUDO_USER $pip install --upgrade $pip_opts "$pkg" >"$output_file" 2>&1; then
        # Success - no output
        :
      else
        exitCode=$((exitCode + 1))
        failed_packages="${failed_packages} $pkg"
      fi
    else
      # Run directly
      if $pip install --upgrade $pip_opts "$pkg" >"$output_file" 2>&1; then
        # Success - no output
        :
      else
        exitCode=$((exitCode + 1))
        failed_packages="${failed_packages} $pkg"
      fi
    fi

    # Clean up log file
    rm -f "$output_file"
  done

  # Report failures if any
  if [ $exitCode -ne 0 ]; then
    printf_red "ERROR: Failed to install:${failed_packages}"
    return 1
  fi

  return 0
}
#
__pip_remove() {
  local packages="$*"
  local pip_opts=""
  local exitCode=0
  local failed_packages=""

  # Find python and pip
  py_bin="$(type -P python3 || type -P python2 || type -P python)"
  if [[ -z "$py_bin" ]]; then
    printf_red "ERROR: Python not found"
    return 1
  fi

  # Get python version
  py_version="$($py_bin --version 2>&1 | sed 's|[pP]ython ||g' | awk -F '.' '{print $1$2}' | grep '[0-9]' || echo "0")"

  # Find pip
  pip3="$(ls /usr/bin/pip*3* 2>/dev/null | head -n 1)"
  pip="$(type -P $pip3 || type -P pip3 || type -P pip || echo "$py_bin -m pip")"

  # Check if pip is actually available
  if ! $py_bin -m pip --version &>/dev/null; then
    printf_red "ERROR: pip not installed"
    return 1
  fi

  # Set pip options for quiet operation
  pip_opts="--yes --quiet --disable-pip-version-check"
  if [ "$py_version" -gt "310" ]; then
    pip_opts="$pip_opts --break-system-packages"
  fi

  # Remove packages silently
  for pkg in $packages; do
    local output_file="/tmp/pip_remove_$$.log"

    if [ -n "$SUDO_USER" ] && [ "$USER" = "root" ]; then
      # Run as sudo user
      if sudo -HE -u $SUDO_USER $pip uninstall $pip_opts "$pkg" >"$output_file" 2>&1; then
        # Success - no output
        :
      else
        exitCode=$((exitCode + 1))
        failed_packages="${failed_packages} $pkg"
      fi
    else
      # Run directly
      if $pip uninstall $pip_opts "$pkg" >"$output_file" 2>&1; then
        # Success - no output
        :
      else
        exitCode=$((exitCode + 1))
        failed_packages="${failed_packages} $pkg"
      fi
    fi

    # Clean up log file
    rm -f "$output_file"
  done

  # Report failures if any
  if [ $exitCode -ne 0 ]; then
    printf_red "ERROR: Failed to remove:${failed_packages}"
    return 1
  fi

  return 0
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Ruby/GEM functions
__gem_run() {
  local packages="$*"
  local exitCode=0
  
  gem="$(type -P gem 2>/dev/null | grep -v "$HOME" | grep '^')"
  if [[ -z "$gem" ]]; then
    printf_red "Ruby gem is not installed"
    return 1
  fi
  
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME gem install [package]" >&2
  
  printf_cyan "Installing Ruby gems: $packages"
  for pkg in $packages; do
    printf_green "Installing: $pkg"
    if command -v stdbuf >/dev/null 2>&1; then
      stdbuf -oL -eL sudo $gem install --no-user-install "$pkg" || exitCode=$((exitCode + 1))
    else
      sudo $gem install --no-user-install "$pkg" || exitCode=$((exitCode + 1))
    fi
  done
  
  return $exitCode
}
__gem_remove() {
  local packages="$*"
  local exitCode=0
  
  gem="$(type -P gem 2>/dev/null | grep -v "$HOME" | grep '^')"
  if [[ -z "$gem" ]]; then
    printf_red "Ruby gem is not installed"
    return 1
  fi
  
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME gem remove [package]" >&2
  
  printf_cyan "Removing Ruby gems: $packages"
  for pkg in $packages; do
    printf_yellow "Removing: $pkg"
    if command -v stdbuf >/dev/null 2>&1; then
      stdbuf -oL -eL sudo $gem uninstall --no-user-install --all --executables --force "$pkg" || exitCode=$((exitCode + 1))
    else
      sudo $gem uninstall --no-user-install --all --executables --force "$pkg" || exitCode=$((exitCode + 1))
    fi
  done
  
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# NODE/Yarn/NPM functions
__npm_run() {
  local packages="$*"
  local exitCode=0
  local NODE_PATH="" PATH="${PATH}"
  
  # Add node to PATH if found
  NODE_PATH="$(echo "$PATH" | tr ':' '\n' | grep 'node' | grep '/bin' | head -n1)"
  [ -n "$NODE_PATH" ] && PATH="$NODE_PATH:$PATH"
  
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME npm install [package]" >&2
  
  # Use fnm if available
  if __cmd_exists fnm; then
    eval $(fnm env 2>/dev/null)
    fnm use default &>/dev/null
  fi
  
  # Check what's available
  if __cmd_exists npm; then
    printf_cyan "Installing npm packages globally: $packages"
    for pkg in $packages; do
      printf_green "Installing: $pkg"
      if command -v stdbuf >/dev/null 2>&1; then
        stdbuf -oL -eL npm install -g "$pkg" || exitCode=$((exitCode + 1))
      else
        npm install -g "$pkg" || exitCode=$((exitCode + 1))
      fi
    done
  elif __cmd_exists yarn; then
    printf_cyan "Installing packages with Yarn: $packages"
    local prefix="/usr/local"
    [ "$USER" != "root" ] && prefix="$HOME/.local"
    for pkg in $packages; do
      printf_green "Installing: $pkg"
      if command -v stdbuf >/dev/null 2>&1; then
        stdbuf -oL -eL yarn global add "$pkg" --prefix "$prefix" || exitCode=$((exitCode + 1))
      else
        yarn global add "$pkg" --prefix "$prefix" || exitCode=$((exitCode + 1))
      fi
    done
  else
    printf_red "Neither npm nor yarn is installed"
    return 1
  fi
  
  return $exitCode
}
__npm_remove() {
  local packages="$*"
  local exitCode=0
  local NODE_PATH="" PATH="${PATH}"
  
  # Add node to PATH if found
  NODE_PATH="$(echo "$PATH" | tr ':' '\n' | grep 'node' | grep '/bin' | head -n1)"
  [ -n "$NODE_PATH" ] && PATH="$NODE_PATH:$PATH"
  
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME npm remove [package]" >&2
  
  # Use fnm if available
  if __cmd_exists fnm; then
    eval $(fnm env 2>/dev/null)
    fnm use default &>/dev/null
  fi
  
  # Check what's available
  if __cmd_exists npm; then
    printf_cyan "Removing npm packages: $packages"
    for pkg in $packages; do
      printf_yellow "Removing: $pkg"
      if command -v stdbuf >/dev/null 2>&1; then
        stdbuf -oL -eL npm uninstall -g "$pkg" || exitCode=$((exitCode + 1))
      else
        npm uninstall -g "$pkg" || exitCode=$((exitCode + 1))
      fi
    done
  elif __cmd_exists yarn; then
    printf_cyan "Removing packages with Yarn: $packages"
    local prefix="/usr/local"
    [ "$USER" != "root" ] && prefix="$HOME/.local"
    for pkg in $packages; do
      printf_yellow "Removing: $pkg"
      if command -v stdbuf >/dev/null 2>&1; then
        stdbuf -oL -eL yarn global remove "$pkg" --prefix "$prefix" || exitCode=$((exitCode + 1))
      else
        yarn global remove "$pkg" --prefix "$prefix" || exitCode=$((exitCode + 1))
      fi
    done
  else
    printf_red "Neither npm nor yarn is installed"
    return 1
  fi
  
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Lua/Rocks functions
__lua_run() {
  local packages="$*"
  __cmd_exists lua && __cmd_exists luarocks || return 1
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME lua install [package]" >&2
  luarocks install --local $packages
}
__lua_remove() {
  local packages="$*"
  __cmd_exists lua && __cmd_exists luarocks || return 1
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME lua remove [package]" >&2
  luarocks remove --local $packages
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Go functions
__go_run() {
  local packages="$*"
  __cmd_exists go || return 1
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME go install [package]" >&2
  export GOPATH="${GOPATH:-$HOME/.local/share/go}"
  for pack in $packages; do
    go install -v "$pack@latest"
  done
}
__go_remove() {
  local packages="$*"
  local exitCode=0
  
  if ! __cmd_exists go; then
    printf_red "Go is not installed"
    return 1
  fi
  
  [ -n "$packages" ] || printf_exit "Usage: $APPNAME go remove [package]" >&2
  
  export GOPATH="${GOPATH:-$HOME/.local/share/go}"
  
  printf_cyan "Removing Go packages: $packages"
  for pkg in $packages; do
    printf_yellow "Removing: $pkg"
    
    # Try to clean the package first
    go clean -i $pkg &>/dev/null
    
    # Determine architecture
    local ost=""
    if [[ "$(uname -m)" == "x86_64" ]]; then
      ost="$(uname -s | tr '[:upper:]' '[:lower:]')_amd64"
    elif [[ "$(uname -m)" == "aarch64" ]]; then
      ost="$(uname -s | tr '[:upper:]' '[:lower:]')_arm64"
    else
      ost="$(uname -s | tr '[:upper:]' '[:lower:]')_$(uname -m)"
    fi
    
    # Count slashes to determine package depth
    local cnt="${pkg//[^\/]/}"
    
    # Remove source and compiled directories
    if [ "${#cnt}" -eq 2 ]; then
      rm -rf "${GOPATH%%:*}/src/${pkg%/*}"
      rm -rf "${GOPATH%%:*}/pkg/${ost}/${pkg%/*}"
    elif [ "${#cnt}" -gt 2 ]; then
      rm -rf "${GOPATH%%:*}/src/${pkg%/*/*}"
      rm -rf "${GOPATH%%:*}/pkg/${ost}/${pkg%/*/*}"
    fi
    
    # Also remove the binary if it exists
    local bin_name="$(basename "$pkg")"
    if [ -f "${GOPATH%%:*}/bin/$bin_name" ]; then
      rm -f "${GOPATH%%:*}/bin/$bin_name"
      printf_green "Removed binary: $bin_name"
    fi
  done
  
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Curl functions
__curl_run() {
  local os="" distro="" distroid="" url=""
  [ -z $1 ] && printf_exit 1 0 "Usage: pkmgr curl OS filename or pkmgr curl fullurltolist "
  url="$1"
  os="$(echo $OS | tr '[:upper:]' '[:lower:]')"
  distro="$(echo $DISTRO | tr '[:upper:]' '[:lower:]')"
  distroid="$(echo $DISTROID | tr '[:upper:]' '[:lower:]')"
  if __is_url "$url"; then
    __urlverify "$url" && __curl "$url" -o "$PKMGR_TEMP_FILE" &>/dev/null || return 1
  else
    url="$PKMGR_GIT_REPO/$1/raw/$PKMGR_GIT_BRANCH/lists/$2.list"
    shift "$#"
    __urlverify "$url" && __curl "$url" -o "$PKMGR_TEMP_FILE" &>/dev/null || return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Remote script execution functions
____script_run_if_is_url() {
  [ -z "$1" ] && printf_exit 1 0 "Usage: pkmgr script filename or url "
  if [[ "$1" =~ https?://.* ]] || [[ "$1" =~ ftp?://.* ]]; then
    __urlverify "$1" && __curl "$1" | tee "$PKMGR_TEMP_FILE" &>/dev/null || return 1
  else
    __cp_rf "$1" "$PKMGR_TEMP_FILE"
  fi
  if [ -f "$PKMGR_TEMP_FILE" ]; then
    chmod 755 "$PKMGR_TEMP_FILE"
  else
    printf_red "Error file does not exit"
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Script execution
__script_run() {
  if [ "$1" = "--script" ]; then
    shift 1
    __script_run_if_is_url "$1"
    __execute "$PKMGR_TEMP_FILE" "executing the script"
  elif [ "$1" = "--line" ]; then
    shift 1
    __script_run_if_is_url "$1"
    while read -r line; do __execute "$line" "$line"; done <"$PKMGR_TEMP_FILE"
  else
    __script_run_if_is_url "$1"
    "$PKMGR_TEMP_FILE"
  fi
  __rm_rf "$PKMGR_TEMP_FILE"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__schedule() {
  local logfile="" loggerfile="" file="" tmpfile="" mailadmin="" sleepcmd="" date="" cronjob=""
  logfile="/var/log/pkmgr/cron.log"
  loggerfile="/var/log/pkmgr/cron.err"
  file="/etc/cron.d/pkmgr_update"
  tmpfile="$PKMGR_TEMP_DIR/pkmgr_cron"
  mailadmin="${PKMGR_NOTIFICATION_EMAIL:-root}"
  sleepcmd=$((RANDOM / 300))
  date="$(date +"%m-%d-%Y %H:%M")"
  cronjob="0 4 * * * root sleep ${sleepcmd} ; pkmgr cron run"
  sudo mkdir -p "/var/log/pkmgr"
  case "$1" in
  remove)
    shift 1
    printf_green "Removing pkmgr schedule"
    __rm_rf "$file" ||
      printf_error "Failed to remove $file"
    ;;
  add)
    shift 1
    printf_green "Adding pkmgr to run daily at 4am with random sleep of $sleepcmd seconds"
    echo "MAILTO=$mailadmin" >"$tmpfile"
    echo "$cronjob" >"$tmpfile"
    sudo chown -f root:root "$tmpfile"
    sudo chmod -f 600 "$tmpfile"
    sudo mv -f $tmpfile $file ||
      printf_error "Failed to install $tmpfile to $file"
    ;;
  run)
    shift 1
    echo -e "###########\n$date\n###########\n" | sudo tee -a "$logfile" &>/dev/null
    echo -e "###########\n$date\n###########\n" | sudo tee -a "$loggerfile" &>/dev/null
    sudo $pkgmgrbinupdcron 2>>"$loggerfile.tmp" | sudo tee -a "$logfile" &>/dev/null
    if [ -s "$loggerfile.tmp" ] && [ -f "$loggerfile.tmp" ] && grep -q '[^[:space:]]' "$loggerfile.tmp" &>/dev/null; then
      if __cmd_exists mail; then
        MAILMESS="$(echo -e "Errors were reported and they are as follows:\n""$(cat $loggerfile.tmp)\n")"
        echo $MAILMESS | mail -r "$mailadmin" -s "pkmgr failed" "$mailadmin"
      fi
    fi
    [ ! -f "$loggerfile.tmp" ] || sudo cat "$loggerfile.tmp" | sudo tee -a "$loggerfile" && __rm_rf "$loggerfile.tmp"
    ;;
  *)
    [ -f "$file" ] && pkmgr cron remove || pkmgr cron add
    ;;
  esac
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__dotfiles_run() {
  local file="" f="" url=""
  [ -n "$1" ] || printf_exit "Usage: pkmgr dotfiles name"
  f=""
  file=("$@")
  echo >"$PKMGR_TEMP_FILE"
  for f in "${file[@]}"; do
    if [ -n "$f" ]; then
      url="$dotfilesrepo_raw/$f.list"
      __urlverify "$url" && __curl "$url" | tee -a "$PKMGR_TEMP_FILE" &>/dev/null || return 1
    fi
  done
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__aliases() {
  cat <<EOF
  alias apt='$APPNAME '
  alias apt-get='$APPNAME '
  alias dnf='$APPNAME '
  alias yum='$APPNAME '
  alias pacman='$APPNAME '
  alias brew='$APPNAME '
  alias yay='$APPNAME '
EOF
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__show_info() {
  local col=""
  local truncate="$1"
  [ -n "$COLUMNS" ] && col=$(($COLUMNS - 30)) || col=80
  printf_red "System info for $(hostname -f)         "
  printf_blue "Distribution:               $DISTRO_NAME"
  if [ -n "$CODE_NAME" ] && [ "$CODE_NAME" != "N/A" ]; then
    printf_yellow "Codename:                   $CODE_NAME"
  fi
  printf_blue "Distro Version:             $DISTRO_VERSION"
  printf_yellow "Kernel version              $KERNEL_VERSION"
  if [ "$truncate" = "truncate" ] || [ $col -le 80 ]; then
    truncate="true"
    printf_cyan "Repo:                       ${dotfilesrepo_url:0:$col}"
    printf_cyan "Repo Raw:                   ${dotfilesrepo_raw:0:$col}"
    printf_cyan "system package manager:     ${pkgmgrbin:0:$col}"
    printf_cyan "Install cmd:                ${pkgmgrbinins:0:$col}"
    printf_cyan "Install silent cmd:         ${pkgmgrbininssil:0:$col}"
    printf_cyan "Remove cmd:                 ${pkgmgrbindel:0:$col}"
    printf_cyan "Remove silent cmd:          ${pkgmgrbinremsil:0:$col}"
    printf_cyan "Update cmd:                 ${pkgmgrbinupd:0:$col}"
    printf_cyan "Update silent cmd:          ${pkgmgrbinupdsil:0:$col}"
    printf_cyan "Search cmd:                 ${pkgmgrbinsea:0:$col}"
    printf_cyan "Clean cache cmd:            ${pkgmgrbincle:0:$col}"
    printf_cyan "Make cache cmd:             ${pkgmgrbincac:0:$col}"
  else
    truncate="false"
    printf_cyan "Repo:                       ${dotfilesrepo_url}"
    printf_cyan "Repo:                       ${dotfilesrepo_raw}"
    printf_cyan "system package manager:     ${pkgmgrbin}"
    printf_cyan "Install cmd:                ${pkgmgrbinins}"
    printf_cyan "Install silent cmd:         ${pkgmgrbininssil}"
    printf_cyan "Remove cmd:                 ${pkgmgrbindel}"
    printf_cyan "Remove silent cmd:          ${pkgmgrbinremsil}"
    printf_cyan "Update cmd:                 ${pkgmgrbinupd}"
    printf_cyan "Update silent cmd:          ${pkgmgrbinupdsil}"
    printf_cyan "Search cmd:                 ${pkgmgrbinsea}"
    printf_cyan "Clean cache cmd:            ${pkgmgrbincle}"
    printf_cyan "Make cache cmd:             ${pkgmgrbincac}"
  fi
  printf_blue "Node:                       $(builtin type -P node || __not_installed)"
  printf_blue "NPM:                        $(builtin type -P npm || builtin type -P yarn || __not_installed)"
  printf_purple "Python:                     $(builtin type -P python3 || builtin type -P python2 || __not_installed)"
  printf_purple "PIP:                        $(builtin type -P pip3 || builtin type -P pip || __not_installed)"
  printf_blue "Perl:                       $(builtin type -P perl || __not_installed)"
  printf_blue "CPAN:                       $(builtin type -P cpan || __not_installed)"
  printf_purple "Ruby:                       $(builtin type -P ruby || __not_installed)"
  printf_purple "Gem:                        $(builtin type -P gem || __not_installed)"
  printf_blue "Lua                         $(builtin type -P lua || __not_installed)"
  printf_blue "Luarocks                    $(builtin type -P luarocks || __not_installed)"
  if [ "$truncate" = "true" ]; then
    printf_newline && printf_yellow "Results may have been truncated to $col characters add notruncate for no truncation"
  fi
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__exportpkg() {
  local pkgdir="" pkglist=""
  local distro="$(printf '%s\n' "$DISTRO" | sed 's|[0-9]||g')"
  case "$(uname -s)" in
  Darwin*) distro="MacOS" ;;
  ^MING* | WIN* | MSYS*) distro="Windows" ;;
  esac
  pkgdir="$PKMGR_TEMP_DIR/${distro:-}"
  pkglist="$pkgdir/$(hostname -s).list"
  mkdir -p "$pkgdir"
  printf_green "Exporting package list to:"
  printf_green "$pkglist"
  pkgmgrexport >"$pkglist"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__update_mirrors() {
  __cmd_exists pacman || return 0
  sudo pacman -S --noconfirm --needed reflector &>/dev/null
  __cmd_exists reflector || return
  (
    sudo reflector --protocol 'https' --ipv4 --latest 100 \
      --country us --fastest 20 --sort rate --threads 5 \
      --download-timeout 1 --connection-timeout 1 --save "$PKMGR_TEMP_DIR/mirrorlist.new"
    rankmirrors -n 0 "$PKMGR_TEMP_DIR/mirrorlist.new" >"$PKMGR_TEMP_DIR/mirrorlist"
  ) |& tee &>/dev/null
  if [ -f "$PKMGR_TEMP_DIR/mirrorlist" ] && [ -s "$PKMGR_TEMP_DIR/mirrorlist" ]; then
    sudo mv -f "$PKMGR_TEMP_DIR/mirrorlist" "/etc/pacman.d/mirrorlist" &>/dev/null
    sudo rm -Rf "$PKMGR_TEMP_DIR/mirrorlist" "$PKMGR_TEMP_DIR/mirrorlist.new" &>/dev/null
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Map package names across distributions
__map_package_name() {
  local pkg="$1"
  local mapped_pkg=""

  # Detect the distribution type
  local distro_type=""
  if __cmd_exists apt-get || __cmd_exists apt; then
    distro_type="debian"
  elif __cmd_exists yum || __cmd_exists dnf; then
    distro_type="redhat"
  elif __cmd_exists pacman || __cmd_exists pamac; then
    distro_type="arch"
  elif __cmd_exists apk; then
    distro_type="alpine"
  elif __cmd_exists xbps-install; then
    distro_type="void"
  else
    echo "$pkg"
    return
  fi

  # Package mappings - format: "input_package:debian:redhat:arch:alpine:void"
  local -a mappings=(
    # Web servers
    "nginx-full:nginx-full:nginx:nginx:nginx:nginx"
    "nginx:nginx:nginx:nginx:nginx:nginx"
    "apache:apache2:httpd:apache:apache2:apache"
    "apache2:apache2:httpd:apache:apache2:apache"
    "httpd:apache2:httpd:apache:apache2:apache"

    # Databases
    "mysql:mysql-server:mysql-server:mariadb:mariadb:mariadb"
    "mysql-server:mysql-server:mysql-server:mariadb:mariadb:mariadb"
    "mariadb:mariadb-server:mariadb-server:mariadb:mariadb:mariadb"
    "postgresql:postgresql:postgresql-server:postgresql:postgresql:postgresql"
    "postgres:postgresql:postgresql-server:postgresql:postgresql:postgresql"
    "redis:redis-server:redis:redis:redis:redis"
    "mongodb:mongodb:mongodb-org:mongodb:mongodb:mongodb"

    # Development tools
    "gcc:build-essential:gcc:base-devel:gcc:gcc"
    "g++:g++:gcc-c++:base-devel:g++:gcc"
    "make:make:make:make:make:make"
    "cmake:cmake:cmake:cmake:cmake:cmake"
    "git:git:git:git:git:git"
    "svn:subversion:subversion:subversion:subversion:subversion"
    "hg:mercurial:mercurial:mercurial:mercurial:mercurial"

    # Languages and runtimes
    "python:python3:python3:python:python3:python3"
    "python3:python3:python3:python:python3:python3"
    "python2:python2:python2:python2:python2:python"
    "node:nodejs:nodejs:nodejs:nodejs:nodejs"
    "nodejs:nodejs:nodejs:nodejs:nodejs:nodejs"
    "npm:npm:npm:npm:npm:nodejs"
    "ruby:ruby:ruby:ruby:ruby:ruby"
    "perl:perl:perl:perl:perl:perl"
    "php:php:php:php:php:php"
    "java:default-jdk:java-11-openjdk:jdk-openjdk:openjdk11:openjdk"
    "openjdk:default-jdk:java-11-openjdk:jdk-openjdk:openjdk11:openjdk"

    # System utilities
    "vim:vim:vim:vim:vim:vim"
    "emacs:emacs:emacs:emacs:emacs:emacs"
    "nano:nano:nano:nano:nano:nano"
    "htop:htop:htop:htop:htop:htop"
    "curl:curl:curl:curl:curl:curl"
    "wget:wget:wget:wget:wget:wget"
    "netcat:netcat:nc:gnu-netcat:netcat-openbsd:nc"
    "nc:netcat:nc:gnu-netcat:netcat-openbsd:nc"
    "tmux:tmux:tmux:tmux:tmux:tmux"
    "screen:screen:screen:screen:screen:screen"
    "zsh:zsh:zsh:zsh:zsh:zsh"
    "fish:fish:fish:fish:fish:fish"
    "bash:bash:bash:bash:bash:bash"

    # Libraries
    "openssl:libssl-dev:openssl-devel:openssl:openssl-dev:libressl-devel"
    "libssl:libssl-dev:openssl-devel:openssl:openssl-dev:libressl-devel"
    "zlib:zlib1g-dev:zlib-devel:zlib:zlib-dev:zlib-devel"
    "libxml2:libxml2-dev:libxml2-devel:libxml2:libxml2-dev:libxml2-devel"
    "libxslt:libxslt1-dev:libxslt-devel:libxslt:libxslt-dev:libxslt-devel"
    "readline:libreadline-dev:readline-devel:readline:readline-dev:readline-devel"
    "ncurses:libncurses5-dev:ncurses-devel:ncurses:ncurses-dev:ncurses-devel"

    # Container tools
    "docker:docker.io:docker:docker:docker:docker"
    "podman:podman:podman:podman:podman:podman"
    "containerd:containerd:containerd:containerd:containerd:containerd"

    # Network tools
    "iptables:iptables:iptables:iptables:iptables:iptables"
    "nftables:nftables:nftables:nftables:nftables:nftables"
    "firewalld:firewalld:firewalld:firewalld:firewalld:void-firewall"
    "ufw:ufw:firewalld:ufw:ufw:void-firewall"
    "tcpdump:tcpdump:tcpdump:tcpdump:tcpdump:tcpdump"
    "wireshark:wireshark:wireshark:wireshark:wireshark:wireshark"
    "nmap:nmap:nmap:nmap:nmap:nmap"

    # Package managers and build tools
    "rpm:rpm:rpm:rpmextract:rpm:rpmextract"
    "dpkg:dpkg:dpkg:dpkg:dpkg:xbps-compat"
    "alien:alien:alien:debtap:alien:void-packages"
    "cpan:perl-cpan:perl-CPAN:cpanminus:perl-app-cpanminus:perl-CPAN"
    "cpanminus:cpanminus:perl-App-cpanminus:cpanminus:perl-app-cpanminus:cpanminus"
  )

  # Find the package mapping
  for mapping in "${mappings[@]}"; do
    local map_parts=(${mapping//:/ })
    if [ "${map_parts[0]}" = "$pkg" ]; then
      case "$distro_type" in
        debian) mapped_pkg="${map_parts[1]}" ;;
        redhat) mapped_pkg="${map_parts[2]}" ;;
        arch) mapped_pkg="${map_parts[3]}" ;;
        alpine) mapped_pkg="${map_parts[4]}" ;;
        void) mapped_pkg="${map_parts[5]}" ;;
      esac
      break
    fi
  done

  # Return the mapped package or original if no mapping found
  echo "${mapped_pkg:-$pkg}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check if a Python package is installed
__python_exists() {
  local package="$1"

  # Skip --sudo flag if present
  if [ "$1" = "--sudo" ]; then
    shift
    package="$1"
  fi

  # Find python and pip
  local py_bin="$(type -P python3 || type -P python2 || type -P python)"
  local pip_bin="$(type -P pip3 || type -P pip || echo "$py_bin -m pip")"

  if [[ -z "$py_bin" ]]; then
    return 1
  fi

  # Method 1: Try importing the module directly
  if $py_bin -c "import $package" 2>/dev/null; then
    return 0
  fi

  # Method 2: Check pip list for the package
  if $pip_bin list 2>/dev/null | grep -q "^${package} "; then
    return 0
  fi

  # Method 3: Use pip show to check
  if $pip_bin show "$package" >/dev/null 2>&1; then
    return 0
  fi

  # Method 4: Check if it's a command-line tool installed by pip
  if command -v "$package" >/dev/null 2>&1; then
    # Verify it's a Python tool by checking if it's in a Python path
    local cmd_path="$(command -v "$package")"
    if [[ "$cmd_path" == *"python"* ]] || [[ "$cmd_path" == *"/.local/bin"* ]] || [[ "$cmd_path" == */usr/local/bin* ]]; then
      return 0
    fi
  fi

  # Package not found
  return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__initialize_variables() {
  PKMGR_OS_NAME="$(uname -s | tr '[:upper:]' '[:lower:]')"
  export SUDO_USER RUN_USER
  if [[ "$(__devnull2 python3 -V)" =~ "Python 3" ]]; then
    PYTHONVER="python3"
    PIP="pip3"
    PATH="${PATH}:$(python3 -c 'import site; print(site.USER_BASE)')/bin"
  elif [[ "$(__devnull2 python2 -V)" =~ "Python 2" ]]; then
    PYTHONVER="python"
    PIP="pip"
    PATH="${PATH}:$(python -c 'import site; print(site.USER_BASE)')/bin"
  fi
  if __cmd_exists pacman; then
    PYTHONVER="python"
    PIP="pip3"
  fi
  [ -f "$PKMGR_TEMP_FILE" ] && __rm_rf "$PKMGR_TEMP_FILE"
  case "$PKMGR_OS_NAME" in
  linux)
    # apt-get debian based setup
    if [ -f "$(builtin type -P apt-get 2>/dev/null)" ]; then                                                                      #
      pkmgrcheckbin_opts="-q -y --ignore-hold --allow-change-held-packages --allow-unauthenticated -s dist-upgrade"               #
      export DEBIAN_FRONTEND=noninteractive                                                                                       #
      export APT_OPTS='-o Dpkg::Options::='--force-confdef' -o Dpkg::Options::='--force-confold''                                 #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                      #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/apt"                                                              #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/apt-get"                                                                       #
      pkgmgrbinins="$pkgmgrbin install"                                                                                           #
      pkgmgrbininssil="$pkgmgrbin install $APT_OPTS --ignore-missing -yy -q --allow-unauthenticated --assume-yes"                 #
      pkgmgrbinremsil="$pkgmgrbin remove -yy -q --assume-yes --purge"                                                             #
      pkgmgrbinupdsil="$pkgmgrbin dist-upgrade $APT_OPTS --ignore-missing -yy -q --allow-unauthenticated --assume-yes"            #
      pkgmgrbinupdcron="$pkgmgrbin dist-upgrade $APT_OPTS --ignore-missing -yy --allow-unauthenticated --assume-yes"              #
      pkgmgrbindel="$pkgmgrbin remove --purge"                                                                                    #
      pkgmgrbinsea="sudo --preserve-env=PATH /usr/bin/apt-cache search"                                                           #
      pkgmgrbinupd="$pkgmgrbin dist-upgrade"                                                                                      #
      pkgmgrbincle="$pkgmgrbin clean"                                                                                             #
      pkgmgrbincac="$pkgmgrbin update"                                                                                            #
      pkmgrcheckbin="$(builtin type -P apt 2>/dev/null)"                                                                          #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin $pkmgrcheckbin_opts 2>/dev/null | grep '^Inst' | wc -l; } #
      pkgmgrexport() { dpkg -l | grep ^ii | awk '{print $2}' | sed "s#:.*##g" | sort -u; }                                        #
      __pkgmr_reinstall() { echo "Not yet implemented" && return 1; }                                                               #
    # apt-get debian based setup
    elif [ -f "$(builtin type -P apt 2>/dev/null)" ]; then                                                                        #
      pkmgrcheckbin_opts="-q -y --ignore-hold --allow-change-held-packages --allow-unauthenticated -s dist-upgrade"               #
      export DEBIAN_FRONTEND=noninteractive                                                                                       #
      export APT_OPTS="-o Dpkg::Options::='--force-confdef' -o Dpkg::Options::='--force-confold'"                                 #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                      #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/apt"                                                              #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/apt"                                                                           #
      pkgmgrbinins="$pkgmgrbin install"                                                                                           #
      pkgmgrbininssil="$pkgmgrbin install $APT_OPTS --ignore-missing -yy -q --allow-unauthenticated --assume-yes"                 #
      pkgmgrbinremsil="$pkgmgrbin remove -yy -q --assume-yes --purge"                                                             #
      pkgmgrbinupdsil="$pkgmgrbin dist-upgrade $APT_OPTS --ignore-missing -yy -q --allow-unauthenticated --assume-yes"            #
      pkgmgrbinupdcron="$pkgmgrbin dist-upgrade $APT_OPTS --ignore-missing -yy --allow-unauthenticated --assume-yes"              #
      pkgmgrbindel="$pkgmgrbin remove --purge"                                                                                    #
      pkgmgrbinsea="sudo --preserve-env=PATH /usr/bin/apt-cache search"                                                           #
      pkgmgrbinupd="$pkgmgrbin dist-upgrade"                                                                                      #
      pkgmgrbincle="$pkgmgrbin clean"                                                                                             #
      pkgmgrbincac="$pkgmgrbin update"                                                                                            #
      pkmgrcheckbin="$(builtin type -P apt 2>/dev/null)"                                                                          #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin $pkmgrcheckbin_opts 2>/dev/null | grep '^Inst' | wc -l; } #
      pkgmgrexport() { dpkg -l | grep ^ii | awk '{print $2}' | sed "s#:.*##g" | sort -u; }                                        #
      __pkgmr_reinstall() { echo "Not yet implemented" && return 1; }                                                               #
    # pacman archlinux based setup
    elif [ -f "$(builtin type -P pacman 2>/dev/null)" ]; then                                                                                                               #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                                                                #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/pacman"                                                                                                     #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/pacman"                                                                                                                  #
      pkgmgrbinins="$pkgmgrbin -S --noconfirm --overwrite='*'"                                                                                                              #
      pkgmgrbininssil="$pkgmgrbin -Sy --noconfirm --needed --overwrite='*' "                                                                                                #
      pkgmgrbinremsil="$pkgmgrbin -Ry --noconfirm"                                                                                                                          #
      pkgmgrbinupdsil="$pkgmgrbin -Syyu --noconfirm"                                                                                                                        #
      pkgmgrbinupdcron="$pkgmgrbin -Syyu --noconfirm"                                                                                                                       #
      pkgmgrbindel="$pkgmgrbin -R"                                                                                                                                          #
      pkgmgrbinsea="$pkgmgrbin -Ss --noconfirm"                                                                                                                             #
      pkgmgrbinupd="$pkgmgrbin -Syyu --needed --overwrite='*'"                                                                                                              #
      pkgmgrbincle="yes | $pkgmgrbin -Scc --noconfirm"                                                                                                                      #
      pkgmgrbincac="$pkgmgrbin -Syy"                                                                                                                                        #
      pkmgrcheckbin="$(builtin type -P pacman 2>/dev/null)"                                                                                                                 #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin -Qu 2>/dev/null | wc -l; }                                                                          #
      pkgmgrexport() { (pacman -Qqe | grep -v "$(pacman -Qqm)" && pacman -Qqet | grep -v "$(pacman -Qqm)") | sort -u; }                                                     #
      __pkgmr_reinstall() { for pkg in $(pacman -Q | cut -d' ' -f1); do __execute "pacman -S --noconfirm $pkg" "Reinstalling package: $pkg"; done && return 0 || return $?; } #
    # pamac archlinux based setup
    elif [ -f "$(builtin type -P pamac 2>/dev/null)" ]; then                                                                                                      #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                                                      #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/pacman"                                                                                           #
      pkgmgrbin="sudo /usr/bin/pamac"                                                                                                                             #
      pkgmgrbinins="$pkgmgrbin install --noconfirm"                                                                                                               #
      pkgmgrbininssil="$pkgmgrbin install --noconfirm"                                                                                                            #
      pkgmgrbinremsil="$pkgmgrbin remove --noconfirm"                                                                                                             #
      pkgmgrbinupdsil="$pkgmgrbin upgrade -a"                                                                                                                     #
      pkgmgrbinupdcron="$pkgmgrbin upgrade -a"                                                                                                                    #
      pkgmgrbindel="$pkgmgrbin remove"                                                                                                                            #
      pkgmgrbinsea="$pkgmgrbin search -a"                                                                                                                         #
      pkgmgrbinupd="$pkgmgrbin upgrade -a"                                                                                                                        #
      pkgmgrbincle="$pkgmgrbin clean"                                                                                                                             #
      pkgmgrbincac="$pkgmgrbin checkupdates"                                                                                                                      #
      pkmgrcheckbin="$(builtin type -P pamac 2>/dev/null)"                                                                                                        #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin checkupdates -a 2>/dev/null | wc -l; }                                                    #
      pkgmgrexport() { pamac list ${1:--e} | grep -E 'extra|community|core' | awk '{print $1}' | sort -u; }                                                       #
      __pkgmr_reinstall() { for pkg in $(pkgmgrexport -i); do __execute "pacman -S --noconfirm $pkg" "Reinstalling package: $pkg"; done && return 0 || return $?; } #
    # dnf fedora based setup
    elif [ -f "$(builtin type -P dnf 2>/dev/null)" ]; then                                                                        #
      execute_pkg_check="true"                                                                                                    #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                      #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/yum"                                                              #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/dnf"                                                                           #
      pkgmgrbinins="$pkgmgrbin install"                                                                                           #
      pkgmgrbininssil="$pkgmgrbin install --skip-broken -y"                                                                       #
      pkgmgrbinremsil="$pkgmgrbin remove -y"                                                                                      #
      pkgmgrbinupdsil="$pkgmgrbin update -y"                                                                                      #
      pkgmgrbinupdcron="$pkgmgrbin update -y"                                                                                     #
      pkgmgrbindel="$pkgmgrbin remove"                                                                                            #
      pkgmgrbinsea="$pkgmgrbin search"                                                                                            #
      pkgmgrbinupd="$pkgmgrbin update"                                                                                            #
      pkgmgrbincle="$pkgmgrbin clean"                                                                                             #
      pkgmgrbincac="$pkgmgrbin makecache"                                                                                         #
      pkmgrcheckbin="$(builtin type -P dnf 2>/dev/null)"                                                                          #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin -q check-update 2>/dev/null | grep -v Security | wc -l; } #
      pkgmgrexport() { rpm -qa --qf '%{name}\n' | grep -v gpg-pubkey | sort -u; }                                                 #
      __pkgmr_reinstall() { echo "Not yet implemented" && return 1; }                                                               #
      execute_pkg_check() { __cmd_exists "$1" || rpm -qi "$1" &>/dev/null || return 1; }                                          #
    # yum fedora based setup
    elif [ -f "$(builtin type -P yum 2>/dev/null)" ]; then                                                                        #
      execute_pkg_check="true"                                                                                                    #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                      #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/yum"                                                              #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/yum"                                                                           #
      pkgmgrbinins="$pkgmgrbin install"                                                                                           #
      pkgmgrbininssil="$pkgmgrbin install --skip-broken -y"                                                                       #
      pkgmgrbinremsil="$pkgmgrbin remove -y"                                                                                      #
      pkgmgrbinupdsil="$pkgmgrbin update -y"                                                                                      #
      pkgmgrbinupdcron="$pkgmgrbin update -y"                                                                                     #
      pkgmgrbindel="$pkgmgrbin remove"                                                                                            #
      pkgmgrbinsea="$pkgmgrbin search"                                                                                            #
      pkgmgrbinupd="$pkgmgrbin update"                                                                                            #
      pkgmgrbincle="$pkgmgrbin clean"                                                                                             #
      pkgmgrbincac="$pkgmgrbin makecache"                                                                                         #
      pkmgrcheckbin="$(builtin type -P yum 2>/dev/null)"                                                                          #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin -q check-update 2>/dev/null | grep -v Security | wc -l; } #
      pkgmgrexport() { rpm -qa --qf '%{name}\n' | grep -v gpg-pubkey | sort -u; }                                                 #
      __pkgmr_reinstall() { echo "Not yet implemented" && return 1; }                                                               #
      execute_pkg_check() { __cmd_exists "$1" || rpm -qi "$1" &>/dev/null || return 1; }                                          #
      # tdnf photon based setup
    elif [ -f "$(builtin type -P tdnf 2>/dev/null)" ]; then                                                                         #
      execute_pkg_check="true"                                                                                                      #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                                                        #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/tdnf"                                                               #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/tdnf"                                                                            #
      pkgmgrbinins="$pkgmgrbin install"                                                                                             #
      pkgmgrbininssil="$pkgmgrbin install -y"                                                                                       #
      pkgmgrbinremsil="$pkgmgrbin remove -y"                                                                                        #
      pkgmgrbinupdsil="$pkgmgrbin update -y"                                                                                        #
      pkgmgrbinupdcron="$pkgmgrbin update -y"                                                                                       #
      pkgmgrbindel="$pkgmgrbin remove"                                                                                              #
      pkgmgrbinsea="$pkgmgrbin search"                                                                                              #
      pkgmgrbinupd="$pkgmgrbin update"                                                                                              #
      pkgmgrbincle="$pkgmgrbin clean"                                                                                               #
      pkgmgrbincac="$pkgmgrbin makecache"                                                                                           #
      pkmgrcheckbin="$(builtin type -P tdnf 2>/dev/null)"                                                                           #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin -q check-update 2>/dev/null | grep -v 'Security' | wc -l; } #
      pkgmgrexport() { rpm -qa --qf '%{name}\n' | grep -v gpg-pubkey | sort -u; }                                                   #
      __pkgmr_reinstall() { echo "Not yet implemented" && return 1; }                                                                 #
      execute_pkg_check() { __cmd_exists "$1" || rpm -qi "$1" &>/dev/null || return 1; }                                            #
      # apk alpine based setup
    elif [ -f "$(builtin type -P apk 2>/dev/null)" ]; then                   #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                 #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/apk"         #
      pkgmgrbin="$(builtin type -P apk 2>/dev/null)"                         #
      pkgmgrbinins="$pkgmgrbin -U add"                                       #
      pkgmgrbininssil="$pkgmgrbin -U add >/dev/null"                         #
      pkgmgrbinremsil="$pkgmgrbin del -f"                                    #
      pkgmgrbinupdsil="$pkgmgrbin -U upgrade >/dev/null"                     #
      pkgmgrbinupdcron="$pkgmgrbin -U upgrade >/dev/null"                    #
      pkgmgrbindel="$pkgmgrbin del"                                          #
      pkgmgrbinsea="$pkgmgrbin search | sed 's|-[0-9].*\.[0-9]\.[0-9].*||g'" #
      pkgmgrbinupd="$pkgmgrbin -U upgrade"                                   #
      pkgmgrbincle="$pkgmgrbin cache clean && rm -rf /var/lib/apk/"          #
      pkgmgrbincac="$pkgmgrbin update"                                       #
      pkmgrcheckbin="$(builtin type -P apk 2>/dev/null)"                     #
      __pkmgrcheckupdates() { $pkmgrcheckbin -u list | wc -l; }              #
      pkgmgrexport() { $pkgmgrbin info | grep -ve '-doc$' | sort -u; }       #
      __pkgmr_reinstall() { apk info | xargs apk fix || return 1; }            #
    # xbps-* voidlinux based setup
    elif [ -f "$(builtin type -P xbps-install 2>/dev/null)" ]; then                            #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                   #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/xbps"                          #
      pkgmgrbin="sudo --preserve-env=PATH /usr/bin/xbps-install"                               #
      pkgmgrbinins="$pkgmgrbin -S"                                                             #
      pkgmgrbininssil="$pkgmgrbin -Sy"                                                         #
      pkgmgrbinremsil="sudo --preserve-env=PATH /usr/bin/xbps-remove -y"                       #
      pkgmgrbinupdsil="$pkgmgrbin -Syu"                                                        #
      pkgmgrbinupdcron="$pkgmgrbin -Syu"                                                       #
      pkgmgrbindel="sudo --preserve-env=PATH /usr/bin/xbps-remove"                             #
      pkgmgrbinsea="sudo --preserve-env=PATH /usr/bin/xbps-query -Rs"                          #
      pkgmgrbinupd="$pkgmgrbin -Syu "                                                          #
      pkgmgrbincle="sudo --preserve-env=PATH /usr/bin/xbps-remove -O"                          #
      pkgmgrbincac="$pkgmgrbin -S"                                                             #
      pkmgrcheckbin="$(builtin type -P xbps-install 2>/dev/null)"                              #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin 2>/dev/null | wc -l; } #
      pkgmgrexport() { xbps-query -l; }                                                        #
      __pkgmr_reinstall() { echo "Not yet implemented" && return 1; }                            #
    fi                                                                                         #
    ;;                                                                                         #
    # MacOS brew
  darwin)                                                                                               #
    if [ -n "$(builtin type -P brew 2>/dev/null)" ]; then                                               #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                            #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/brew"                                   #
      if [ "$1" = "--cask" ]; then                                                                      #
        pkgmgrbin="sudo --preserve-env=PATH -u $RUN_USER brew --cask"                                   #
      else                                                                                              #
        pkgmgrbin="sudo --preserve-env=PATH -u $RUN_USER brew"                                          #
      fi                                                                                                #
      pkgmgrbinins="$pkgmgrbin install"                                                                 #
      pkgmgrbininssil="$pkgmgrbin install -f"                                                           #
      pkgmgrbinremsil="$pkgmgrbin remove -f"                                                            #
      pkgmgrbinupdsil="$pkgmgrbin upgrade -f"                                                           #
      pkgmgrbinupdcron="$pkgmgrbin upgrade -f"                                                          #
      pkgmgrbindel="$pkgmgrbin remove"                                                                  #
      pkgmgrbinsea="$pkgmgrbin search"                                                                  #
      pkgmgrbinupd="$pkgmgrbin upgrade"                                                                 #
      pkgmgrbincle="$pkgmgrbin cleanup"                                                                 #
      pkgmgrbincac="$pkgmgrbin update"                                                                  #
      pkmgrcheckbin="$(builtin type -P brew 2>/dev/null)"                                               #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin outdated 2>/dev/null | wc -l; } #
      pkgmgrexport() { $pkgmgrbin list --cask && $pkgmgrbin list --formula | sort -u; }                 #
      __pkgmr_reinstall() { echo "Not yet implemented" && return 1; }                                     #
    fi                                                                                                  #
    ;;                                                                                                  #
    # BSD systems support
  freebsd* | FreeBSD*)                                                                                    #
    # FreeBSD pkg support
    if [ -f "$(builtin type -P pkg 2>/dev/null)" ]; then                                                 #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                             #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/freebsd"                                 #
      pkgmgrbin="sudo --preserve-env=PATH /usr/sbin/pkg"                                                 #
      pkgmgrbinins="$pkgmgrbin install"                                                                  #
      pkgmgrbininssil="$pkgmgrbin install -y"                                                            #
      pkgmgrbinremsil="$pkgmgrbin delete -y"                                                             #
      pkgmgrbinupdsil="$pkgmgrbin upgrade -y"                                                            #
      pkgmgrbinupdcron="$pkgmgrbin upgrade -y"                                                           #
      pkgmgrbindel="$pkgmgrbin delete"                                                                   #
      pkgmgrbinsea="$pkgmgrbin search"                                                                   #
      pkgmgrbinupd="$pkgmgrbin upgrade"                                                                  #
      pkgmgrbincle="$pkgmgrbin clean -y && $pkgmgrbin autoremove -y"                                     #
      pkgmgrbincac="$pkgmgrbin update"                                                                   #
      pkmgrcheckbin="$(builtin type -P pkg 2>/dev/null)"                                                 #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin version -l '<' 2>/dev/null | wc -l; } #
      pkgmgrexport() { $pkgmgrbin query -e '%n-%v' | sort -u; }                                          #
      __pkgmr_reinstall() { for pkg in $($pkgmgrbin query -e '%n'); do $pkgmgrbin install -fy "$pkg" || return 1; done; } #
    fi                                                                                                    #
    ;;                                                                                                    #
  openbsd* | OpenBSD*)                                                                                    #
    # OpenBSD pkg_add support
    if [ -f "$(builtin type -P pkg_add 2>/dev/null)" ]; then                                             #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                             #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/openbsd"                                 #
      pkgmgrbin="sudo --preserve-env=PATH /usr/sbin/pkg_add"                                             #
      pkgmgrbinins="$pkgmgrbin"                                                                          #
      pkgmgrbininssil="$pkgmgrbin -I"                                                                    #
      pkgmgrbinremsil="sudo --preserve-env=PATH /usr/sbin/pkg_delete -I"                                 #
      pkgmgrbinupdsil="$pkgmgrbin -u -I"                                                                 #
      pkgmgrbinupdcron="$pkgmgrbin -u -I"                                                                #
      pkgmgrbindel="sudo --preserve-env=PATH /usr/sbin/pkg_delete"                                       #
      pkgmgrbinsea="sudo --preserve-env=PATH /usr/sbin/pkg_info -Q"                                      #
      pkgmgrbinupd="$pkgmgrbin -u"                                                                       #
      pkgmgrbincle="sudo --preserve-env=PATH /usr/sbin/pkg_delete -a"                                    #
      pkgmgrbincac="echo 'OpenBSD: No cache update needed'"                                              #
      pkmgrcheckbin="$(builtin type -P pkg_info 2>/dev/null)"                                            #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin -u 2>/dev/null | wc -l; }       #
      pkgmgrexport() { pkg_info -q | sort -u; }                                                          #
      __pkgmr_reinstall() { for pkg in $(pkg_info -q); do $pkgmgrbin "$pkg" || return 1; done; }         #
    fi                                                                                                    #
    ;;                                                                                                    #
  netbsd* | NetBSD*)                                                                                      #
    # NetBSD pkgin support
    if [ -f "$(builtin type -P pkgin 2>/dev/null)" ]; then                                               #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                             #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/netbsd"                                  #
      pkgmgrbin="sudo --preserve-env=PATH /usr/pkg/bin/pkgin"                                            #
      pkgmgrbinins="$pkgmgrbin install"                                                                  #
      pkgmgrbininssil="$pkgmgrbin -y install"                                                            #
      pkgmgrbinremsil="$pkgmgrbin -y remove"                                                             #
      pkgmgrbinupdsil="$pkgmgrbin -y upgrade"                                                            #
      pkgmgrbinupdcron="$pkgmgrbin -y upgrade"                                                           #
      pkgmgrbindel="$pkgmgrbin remove"                                                                   #
      pkgmgrbinsea="$pkgmgrbin search"                                                                   #
      pkgmgrbinupd="$pkgmgrbin upgrade"                                                                  #
      pkgmgrbincle="$pkgmgrbin clean && $pkgmgrbin autoremove"                                           #
      pkgmgrbincac="$pkgmgrbin update"                                                                   #
      pkmgrcheckbin="$(builtin type -P pkgin 2>/dev/null)"                                               #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin upgrade -n 2>/dev/null | grep -c '^[[:space:]]'; } #
      pkgmgrexport() { $pkgmgrbin list | awk '{print $1}' | sort -u; }                                   #
      __pkgmr_reinstall() { for pkg in $($pkgmgrbin list | awk '{print $1}'); do $pkgmgrbin -y install "$pkg" || return 1; done; } #
    # NetBSD pkg_add fallback
    elif [ -f "$(builtin type -P pkg_add 2>/dev/null)" ]; then                                           #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                             #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/netbsd"                                  #
      pkgmgrbin="sudo --preserve-env=PATH /usr/sbin/pkg_add"                                             #
      pkgmgrbinins="$pkgmgrbin"                                                                          #
      pkgmgrbininssil="$pkgmgrbin"                                                                       #
      pkgmgrbinremsil="sudo --preserve-env=PATH /usr/sbin/pkg_delete"                                    #
      pkgmgrbinupdsil="echo 'NetBSD pkg_add: Manual upgrade required'"                                   #
      pkgmgrbinupdcron="echo 'NetBSD pkg_add: Manual upgrade required'"                                  #
      pkgmgrbindel="sudo --preserve-env=PATH /usr/sbin/pkg_delete"                                       #
      pkgmgrbinsea="sudo --preserve-env=PATH /usr/sbin/pkg_info -E"                                      #
      pkgmgrbinupd="echo 'NetBSD pkg_add: Manual upgrade required'"                                      #
      pkgmgrbincle="sudo --preserve-env=PATH /usr/sbin/pkg_delete -O"                                    #
      pkgmgrbincac="echo 'NetBSD pkg_add: No cache update needed'"                                       #
      pkmgrcheckbin="$(builtin type -P pkg_info 2>/dev/null)"                                            #
      __pkmgrcheckupdates() { echo "0"; }                                                                #
      pkgmgrexport() { pkg_info -e '*' | sort -u; }                                                      #
      __pkgmr_reinstall() { echo "Not supported with pkg_add" && return 1; }                             #
    fi                                                                                                    #
    ;;                                                                                                    #
  dragonfly* | DragonFly*)                                                                                #
    # DragonFly BSD pkg support (similar to FreeBSD)
    if [ -f "$(builtin type -P pkg 2>/dev/null)" ]; then                                                 #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                             #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/dragonfly"                               #
      pkgmgrbin="sudo --preserve-env=PATH /usr/local/sbin/pkg"                                           #
      pkgmgrbinins="$pkgmgrbin install"                                                                  #
      pkgmgrbininssil="$pkgmgrbin install -y"                                                            #
      pkgmgrbinremsil="$pkgmgrbin delete -y"                                                             #
      pkgmgrbinupdsil="$pkgmgrbin upgrade -y"                                                            #
      pkgmgrbinupdcron="$pkgmgrbin upgrade -y"                                                           #
      pkgmgrbindel="$pkgmgrbin delete"                                                                   #
      pkgmgrbinsea="$pkgmgrbin search"                                                                   #
      pkgmgrbinupd="$pkgmgrbin upgrade"                                                                  #
      pkgmgrbincle="$pkgmgrbin clean -y && $pkgmgrbin autoremove -y"                                     #
      pkgmgrbincac="$pkgmgrbin update"                                                                   #
      pkmgrcheckbin="$(builtin type -P pkg 2>/dev/null)"                                                 #
      __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin version -l '<' 2>/dev/null | wc -l; } #
      pkgmgrexport() { $pkgmgrbin query -e '%n-%v' | sort -u; }                                          #
      __pkgmr_reinstall() { for pkg in $($pkgmgrbin query -e '%n'); do $pkgmgrbin install -fy "$pkg" || return 1; done; } #
    fi                                                                                                    #
    ;;                                                                                                    #
    # Windows chocolatey based setup
  cygwin* | mingw* | msys*)                                                                  #
    dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                   #
    dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/win"                           #
    pkgmgrbin="choco"                                                                        #
    pkgmgrbinins="choco install"                                                             #
    pkgmgrbininssil="choco install -yf"                                                      #
    pkgmgrbinremsil="choco remove -f"                                                        #
    pkgmgrbinupdsil="choco update -yf"                                                       #
    pkgmgrbinupdcron="choco update -yf"                                                      #
    pkgmgrbindel="choco remove"                                                              #
    pkgmgrbinsea="choco search"                                                              #
    pkgmgrbinupd="choco update"                                                              #
    pkgmgrbincle="choco cleanup"                                                             #
    pkmgrcheckbin="$(builtin type -P false 2>/dev/null)"                                     #
    __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $pkmgrcheckbin 2>/dev/null | wc -l; } #
    pkgmgrexport() { echo not enabled; }                                                     #
    __pkgmr_reinstall() { echo "Not yet implemented" && return 1; }                            #
    ;;                                                                                       #
  *)                                                                                         #
    printf_exit "Unknown OS or OS not supported"                                             #
    ;;                                                                                       #
  esac                                                                                       #
  #
  # AUR Helper Support for Arch-based systems
  if [ "$ENABLE_AUR" = "true" ] && __cmd_exists pacman; then                                             #
    # Detect available AUR helper (prefer paru > yay > pikaur > trizen)
    local aur_helper=""
    local aur_helper_path=""
    
    if [ -f "$(builtin type -P paru 2>/dev/null)" ]; then
      aur_helper="paru"
      aur_helper_path="$(builtin type -P paru)"
    elif [ -f "$(builtin type -P yay 2>/dev/null)" ]; then
      aur_helper="yay"
      aur_helper_path="$(builtin type -P yay)"
    elif [ -f "$(builtin type -P pikaur 2>/dev/null)" ]; then
      aur_helper="pikaur"
      aur_helper_path="$(builtin type -P pikaur)"
    elif [ -f "$(builtin type -P trizen 2>/dev/null)" ]; then
      aur_helper="trizen"
      aur_helper_path="$(builtin type -P trizen)"
    elif [ -f "$(builtin type -P aurman 2>/dev/null)" ]; then
      aur_helper="aurman"
      aur_helper_path="$(builtin type -P aurman)"
    fi
    
    if [ -n "$aur_helper" ]; then                                                                        #
      printf_cyan "AUR enabled with $aur_helper"                                                         #
      dotfilesrepo_url="$PKMGR_GIT_REPO/$PKMGR_GIT_DOTFILES"                                            #
      dotfilesrepo_raw="$dotfilesrepo_url/raw/$PKMGR_GIT_BRANCH/pacman"                                 #
      
      # Configure commands based on AUR helper
      case "$aur_helper" in
        paru)
          pkgmgrbin="sudo --preserve-env=PATH -u $RUN_USER $aur_helper_path"                             #
          pkgmgrbinins="$pkgmgrbin -S --cleanafter --overwrite='*'"                                      #
          pkgmgrbininssil="$pkgmgrbin -S --needed --noconfirm --cleanafter --overwrite='*'"              #
          pkgmgrbinremsil="$pkgmgrbin -R --noconfirm"                                                    #
          pkgmgrbinupdsil="$pkgmgrbin -Syyu --noconfirm"                                                 #
          pkgmgrbinupdcron="$pkgmgrbin -Syyu --noconfirm"                                                #
          pkgmgrbindel="$pkgmgrbin -R"                                                                   #
          pkgmgrbinsea="$pkgmgrbin -Ss"                                                                  #
          pkgmgrbinupd="$pkgmgrbin -Syyu --needed --overwrite='*'"                                       #
          pkgmgrbincle="$pkgmgrbin -Scc --noconfirm"                                                     #
          pkgmgrbincac="$pkgmgrbin -Syy"                                                                 #
          __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $aur_helper -Qum 2>/dev/null | wc -l; }    #
          ;;
        yay)
          pkgmgrbin="sudo --preserve-env=PATH -u $RUN_USER $aur_helper_path"                             #
          pkgmgrbinins="$pkgmgrbin -S --cleanafter --overwrite='*'"                                      #
          pkgmgrbininssil="$pkgmgrbin -Sy --needed --noconfirm --cleanafter --overwrite='*'"             #
          pkgmgrbinremsil="$pkgmgrbin -Ry --noconfirm"                                                   #
          pkgmgrbinupdsil="$pkgmgrbin -Syyu --noconfirm"                                                 #
          pkgmgrbinupdcron="$pkgmgrbin -Syyu --noconfirm"                                                #
          pkgmgrbindel="$pkgmgrbin -R"                                                                   #
          pkgmgrbinsea="$pkgmgrbin -Ss"                                                                  #
          pkgmgrbinupd="$pkgmgrbin -Syyu --needed --overwrite='*'"                                       #
          pkgmgrbincle="yes | $pkgmgrbin -Scc --noconfirm"                                               #
          pkgmgrbincac="$pkgmgrbin -Syy"                                                                 #
          __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $aur_helper -Qum 2>/dev/null | wc -l; }    #
          ;;
        pikaur|trizen|aurman)
          pkgmgrbin="sudo --preserve-env=PATH -u $RUN_USER $aur_helper_path"                             #
          pkgmgrbinins="$pkgmgrbin -S"                                                                   #
          pkgmgrbininssil="$pkgmgrbin -S --needed --noconfirm"                                           #
          pkgmgrbinremsil="$pkgmgrbin -R --noconfirm"                                                    #
          pkgmgrbinupdsil="$pkgmgrbin -Syyu --noconfirm"                                                 #
          pkgmgrbinupdcron="$pkgmgrbin -Syyu --noconfirm"                                                #
          pkgmgrbindel="$pkgmgrbin -R"                                                                   #
          pkgmgrbinsea="$pkgmgrbin -Ss"                                                                  #
          pkgmgrbinupd="$pkgmgrbin -Syyu --needed"                                                       #
          pkgmgrbincle="$pkgmgrbin -Scc --noconfirm"                                                     #
          pkgmgrbincac="$pkgmgrbin -Syy"                                                                 #
          __pkmgrcheckupdates() { [ -n "$pkmgrcheckbin" ] && $aur_helper -Qua 2>/dev/null | wc -l; }    #
          ;;
      esac
      
      pkmgrcheckbin="$aur_helper_path"                                                                   #
      pkgmgrexport() { pacman -Qqet | grep --line-buffered -v "$(pacman -Qqm)" | sort -u; }             #
      __pkgmr_reinstall() { for pkg in $(pacman -Q | cut -d' ' -f1); do __execute "$aur_helper -S --noconfirm $pkg" "Reinstalling: $pkg"; done && return 0 || return $?; } #
      
      # Combined update check for pacman + AUR
      __pkmgrcheckupdates() {                                                                            #
        local pacman_count="$(pacman -Qu 2>/dev/null | wc -l | grep '^')"                                #
        local aur_count="0"                                                                              #
        case "$aur_helper" in                                                                            #
          paru|yay) aur_count="$($aur_helper -Qum 2>/dev/null | wc -l)" ;;                               #
          *) aur_count="$($aur_helper -Qua 2>/dev/null | wc -l)" ;;                                      #
        esac                                                                                              #
        local updates=$((pacman_count + aur_count)) || updates="0"                                       #
        printf '%s\n' "$updates"                                                                         #
      }                                                                                                   #
    else                                                                                                  #
      printf_yellow "Warning: --enable-aur was set but no AUR helper found"                              #
      printf_yellow "Install one of: paru, yay, pikaur, trizen, or aurman"                               #
    fi                                                                                                    #
  fi                                                                                                      #
  pkginit="$pkgmgrbincle ; $pkgmgrbincac ; $pkgmgrbinupdsil"
  [ -d "$PKMGR_INSTALLED_LIST_DIR" ] || { sudo mkdir -p "$PKMGR_INSTALLED_LIST_DIR" && sudo chmod 777 "$PKMGR_INSTALLED_LIST_DIR"; }

}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
__execute_pkmgr() {
  case "$1" in
  check) # Check for updates
    shift 1
    if [ "$1" = "force" ] || [ "$FORCE_INSTALL" = "yes" ]; then
      __rm_rf "$CHECK_FOR_UPDATES_CACHE_DIR/update_check"
    elif ! __find_mtime "$CHECK_FOR_UPDATES_CACHE_DIR/update_check" "1800"; then
      __rm_rf "$CHECK_FOR_UPDATES_CACHE_DIR/update_check"
    fi
    if [ ! -f "$CHECK_FOR_UPDATES_CACHE_DIR/update_check" ]; then
      $pkgmgrbincac &>/dev/null
      __run_updatecheck >"$CHECK_FOR_UPDATES_CACHE_DIR/update_check"
    fi
    if [ -f "$CHECK_FOR_UPDATES_CACHE_DIR/update_check" ]; then
      cat "$CHECK_FOR_UPDATES_CACHE_DIR/update_check"
    else
      echo "0"
    fi
    exit ${exitCode:-0}
    ;;

  available) # List
    shift 1
    run_install_available "$APPNAME"
    exit ${exitCode:-0}
    ;;

  init) # Update package manager and upgrade system
    shift 1
    [ "$1" = "help" ] && printf_exit 2 0 "Initialize the system by making the cache and updating"
    am_i_online --error || exit 1
    __execute "$pkginit" "Initializing System" && exitCode=0 || exitCode=1
    exit ${exitCode:-0}
    ;;

  makecache) # Create the package manage cache file
    shift 1
    [ "$1" = "help" ] && printf_exit 2 0 "Create the cache for the package manager"
    printf_blue "Updating the package manager cache files - May take a while"
    __update_mirrors
    eval $pkgmgrbincac |& __devnull && exitCode=0 || exitCode=1
    exit ${exitCode:-0}
    ;;

  aliases) # Generate aliases
    shift 1
    if [ -d "$HOME/.config/bash/local" ] && grep -q userbashprofilelocal "$HOME/.bashrc" &>/dev/null; then
      ALIASFILE="$HOME/.config/bash/local/pkmgr.bash"
    else
      ALIASFILE="$HOME/.bash_profile"
    fi
    [ "$1" = "help" ] && printf_exit 2 0 "Print to terminal or --save to export to bash_profile"
    if [ "$1" = "--save" ]; then
      printf_green "Saving the aliases to your bash profile"
      if grep -vq "# pkmgr aliases" "$ALIASFILE"; then
        echo "# pkmgr aliases - Do not remove this line" >>"$ALIASFILE"
        __aliases >>"$ALIASFILE"
        printf_custom "5" "$ALIASFILE"
      fi
    else
      __aliases | printf_readline "2"
      printf_custom "3" "add --save to save this to the alias file"
      printf_custom "5" "$ALIASFILE"
      exit ${exitCode:-0}
    fi
    ;;

  cron) # run via cron
    shift 1
    exitCode=0
    [ "$1" = "help" ] && printf_exit 2 0 "Options are add, remove, or run"
    [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "cron" "__schedule $*"
    __schedule "$@" |& __logging || exitCode=$((exitCode + 1))
    [ $exitCode -eq 0 ] && __write_log_status "cron ran successfully" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  ask) # Ask user to install missing
    shift 1
    if [ -n "$DISPLAY" ]; then
      __attemp_install_menus "$@"
    else
      __check_app "$@" && printf_green "Installed: $*" || printf_exit 1 1 "Install of $* failed"
    fi
    echo
    ;;

  export) # Export installed packages
    shift 1
    [ "$1" = "help" ] && printf_exit 2 0 "Export installed packages to a list"
    __exportpkg
    ;;

  clean) # Clean package manager files
    shift 1
    exitCode=0
    [ "$1" = "help" ] && printf_exit 2 0 "Clean up package manager files"
    [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "clean" "$pkgmgrbincle $*"
    eval $pkgmgrbincle |& __logging || exitCode=1
    [ $exitCode -eq 0 ] && __write_log_status "clean ran successfully" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  search) # Search for packages
    shift 1
    [ $# = 0 ] && printf_exit 2 0 "Search for a package"
    [ "$1" = "help" ] && printf_exit 2 0 "Search for a package"
    
    # Interactive mode
    if [ "$1" = "--interactive" ] || [ "$1" = "-i" ]; then
      shift 1
      printf_cyan "Searching for packages..."
      if [ -n "$1" ]; then
        # Search with the given pattern
        local search_results="$(__searchcmd "$@" 2>/dev/null | head -100)"
        if [ -n "$search_results" ]; then
          local selected
          readarray -t packages_array <<< "$search_results"
          selected=$(__interactive_select "Select packages to install" "true" "${packages_array[@]}")
          if [ -n "$selected" ]; then
            printf_green "Installing selected packages: $selected"
            __execute_with_progress "$pkgmgrbinins $selected" "Installing packages"
          fi
        else
          printf_red "No packages found matching: $*"
          exit 1
        fi
      else
        printf_yellow "Please provide a search term"
        exit 1
      fi
    elif [ "$1" == "show-raw" ] || [ "$1" == "raw" ] || [ "$SHOW_RAW" = "true" ]; then
      [ "$SHOW_RAW" != "true" ] && shift 1
      printf_readline() { tee; }
      printf_red() { echo "$*"; }
      declare -a LISTARRAY=("$@")
      __searchcmd "${LISTARRAY[*]}"
    else
      declare -a LISTARRAY=("$@")
      __searchcmd "${LISTARRAY[*]}"
    fi
    exit $?
    ;;

  mirrors)
    shift 1

    exit $?
    ;;

  keys) # reinitialize pacman keys
    shift 1
    exitCode=0
    if __cmd_exists pacman-key; then
      [ "$1" = "help" ] && printf_exit 2 0 "Usage: $APPNAME keys [broken] [arch,manjaro,arcolinux] - Manage arch keys"
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "keys" "pacman-key $*"
      [ "$1" = "broken" ] && PKMGR_FIX_BROKEN="true" && shift 1 && printf_yellow "Updating mirrors file and deleting gpg keys"
      (
        __default_mirror_list_archlinux | sudo tee /etc/pacman.d/mirrorlist &>/dev/null
        sudo rm -Rf "/root/.gnupg/" "/etc/pacman.d/gnupg/" &>/dev/null
        if [ "$PKMGR_FIX_BROKEN" = "true" ]; then
          if [ -f "/etc/pacman.conf" ]; then
            sudo cp -Rf "/etc/pacman.conf" "$PKMGR_TEMP_DIR/pacman.conf"
            sudo sed -i "s|SigLevel.*=.*|SigLevel = Optional TrustAll|g" "/etc/pacman.conf"
          fi
          __execute "sudo reflector -f 30 -l 30 --number 10 --verbose --save /etc/pacman.d/mirrorlist 2>/dev/null >&1" "${CYAN}Updating the mirrors"
          printf_cyan "Attempting to fix pacman signatures"
        fi
        sudo gpg --refresh-keys >/dev/null 2>&1
        __execute "sudo pacman-key --init >/dev/null 2>&1" "Initializing pacman key"
        __execute "sudo pacman-key --populate ${1:-archlinux} >/dev/null 2>&1" "Populating the keys"
        __execute "sudo pacman-key --refresh-keys >/dev/null 2>&1" "Refreshing the keys"
        __execute "sudo pacman -Syyu --noconfirm >/dev/null 2>&1" "${YELLOW}Updating packages"
        if [ -f "$PKMGR_TEMP_DIR/pacman.conf" ]; then
          [ "$PKMGR_FIX_BROKEN" = "true" ] && sudo cp -Rf "$PKMGR_TEMP_DIR/pacman.conf" "/etc/pacman.broken.conf" || cp -Rf "$PKMGR_TEMP_DIR/pacman.conf" "/etc/pacman.conf"
        fi
      ) |& __logging || exitCode=$((exitCode + 1))
    else
      printf_error "This is only supported on Arch based distros"
      exitCode=1
    fi
    [ $exitCode -eq 0 ] && __write_log_status "keys ran successfully" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  import) # Install packages from export
    shift 1
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Install package via a list: pkmgr list ./listToInstall"
    am_i_online --error || exit 1
    __list_install "$@"
    exit $?
    ;;

  list) # Install package in a list file
    shift 1
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Install package via a list: pkmgr list ./listToInstall"
    am_i_online --error || exit 1
    __list_install "$@"
    exit $?
    ;;

  curl) # Download a list file and install
    shift 1
    exitCode=0
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "pkmgr curl arch min or pkmgr curl fullURLtoList"
    am_i_online --error || exit 1
    __curl_run "$@"
    PCKLIST="$(grep -sh -Ev '^$|^#' "$PKMGR_TEMP_FILE" | sort -u | tr '\n' ' ' && echo '')"
    if [ -n "$PCKLIST" ]; then
      for pkg in $PCKLIST; do
        if [ -n "$pkg" ]; then
          __execute "$pkgmgrbininssil $pkg" "Installing $pkg" && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
        fi
      done
    else
      printf_exit "Error: No packages were defined"
    fi
    [ -n "$VDEBUG" ] || __rm_rf "$PKMGR_TEMP_FILE"
    [ $exitCode -eq 0 ] && exitCode=0 || exitCode="${exitCode:-1}"
    exit ${exitCode:-0}
    ;;

  dotfiles) # Install dfmgr packages
    shift 1
    exitCode=0
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "pkmgr dotfiles git"
    am_i_online --error || exit 1
    __dotfiles_run "$@"
    PCKLIST="$(grep -Ev '^$|^#' "$PKMGR_TEMP_FILE" | sort -u | tr '\n' ' ' && echo '')"
    if [ -n "$PCKLIST" ]; then
      for pkg in $PCKLIST; do
        if [ -n "$pkg" ]; then
          __execute "$pkgmgrbininssil $pkg" "Installing $pkg" && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
        fi
      done
    else
      printf_red "Error: No packages were defined" >&2
      exitCode=2
    fi
    [ -n "$VDEBUG" ] || __rm_rf "$PKMGR_TEMP_FILE"
    [ $exitCode -eq 0 ] && exitCode=0 || exitCode="${exitCode:-1}"
    exit ${exitCode:-0}
    ;;

  script) # Execute a script
    shift 1
    exitCode=0
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "pkmgr script ./myScript or fullURLtoScript"
    am_i_online --error || exit 1
    __script_run "$@" || exitCode=$((exitCode + 1))
    [ $exitCode -eq 0 ] && exitCode=0 || exitCode="${exitCode:-1}"
    exit ${exitCode:-0}
    ;;

  required) # Install required files
    shift 1
    exitCode=0
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Install required packages"
    am_i_online --error || exit 1
    declare -a LISTARRAY=("$@")
    for pkg in "${LISTARRAY[@]}"; do
      __execute "$pkgmgrbininssil $pkg" "Installing $pkg" && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
    done
    [ $exitCode -eq 0 ] && exitCode=0 || exitCode="${exitCode:-1}"
    exit ${exitCode:-0}
    ;;

  reinstall) # reinstall all packages
    shift 1
    [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "reinstall" "__pkgmr_reinstall $*"
    __pkgmr_reinstall |& __logging || exitCode=1
    [ $exitCode -eq 0 ] && __write_log_status "reinstall ran successfully" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  install) # Install packages
    shift 1
    exitCode=0
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Install a package"
    am_i_online --error || exit 1
    
    # Interactive mode for package selection
    if [ "$1" = "--interactive" ] || [ "$1" = "-i" ]; then
      shift 1
      local selected=""
      if [ -n "$1" ]; then
        # Search and select from results
        printf_cyan "Searching for packages matching: $*"
        local search_results="$(__searchcmd "$@" 2>/dev/null | head -100)"
        if [ -n "$search_results" ]; then
          readarray -t packages_array <<< "$search_results"
          selected=$(__interactive_select "Select packages to install" "true" "${packages_array[@]}")
        fi
      else
        # Browse available packages
        printf_cyan "Loading available packages..."
        if __cmd_exists apt-cache; then
          local packages="$(apt-cache pkgnames 2>/dev/null | head -500)"
        elif __cmd_exists pacman; then
          local packages="$(pacman -Slq 2>/dev/null | head -500)"
        elif __cmd_exists dnf; then
          local packages="$(dnf list available 2>/dev/null | awk '{print $1}' | sed 's/\..*$//' | head -500)"
        else
          printf_red "Interactive mode not supported for this package manager"
          exit 1
        fi
        readarray -t packages_array <<< "$packages"
        selected=$(__interactive_select "Select packages to install" "true" "${packages_array[@]}")
      fi
      
      if [ -n "$selected" ]; then
        declare -a LISTARRAY=($selected)
        __init_log_status "install" "$pkgmgrbinins ${LISTARRAY[*]}"
        local start_time=$(date +%s)
        __status_display "Package Installation" "running" "Installing ${#LISTARRAY[@]} packages" "$start_time"
        
        # Install with progress tracking
        if [ "$PKMGR_SHOW_PROGRESS" = "true" ]; then
          __execute_with_progress "__exec_unbuffered '$pkgmgrbinins ${LISTARRAY[*]}'" "Installing packages"
        else
          __exec_unbuffered "$pkgmgrbinins ${LISTARRAY[*]}" |& __logging || exitCode=$((exitCode + 1))
        fi
        
        [ $exitCode -eq 0 ] && __status_display "Package Installation" "success" "Installed ${#LISTARRAY[@]} packages" "$start_time"
      else
        printf_yellow "No packages selected"
        exit 0
      fi
    else
      # Normal mode
      declare -a LISTARRAY=("$@")

      # Map package names for the current distribution
      declare -a MAPPED_PACKAGES=()
      for pkg in "${LISTARRAY[@]}"; do
        mapped_pkg="$(__map_package_name "$pkg")"
        MAPPED_PACKAGES+=("$mapped_pkg")
      done

      __init_log_status "install" "$pkgmgrbinins ${MAPPED_PACKAGES[*]}"

      # Show progress if enabled
      if [ "$PKMGR_SHOW_PROGRESS" = "true" ]; then
        __execute_with_progress "__exec_unbuffered '$pkgmgrbinins ${MAPPED_PACKAGES[*]}'" "Installing packages"
      else
        __exec_unbuffered "$pkgmgrbinins ${MAPPED_PACKAGES[*]}" |& __logging || exitCode=$((exitCode + 1))
      fi
    fi
    
    [ $exitCode -eq 0 ] && __write_log_status "install was successful" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  upgrade | update) # Update packages
    shift 1
    exitCode=0
    [ "$1" = "help" ] && printf_exit 2 0 "Update your system"
    am_i_online --error || exit 1
    __init_log_status "update" "$pkgmgrbinupd $*"
    if __cmd_exists systemmgr; then
      systemmgr update installer || exitCode=$((exitCode + 1))
    fi
    printf_cyan "Updating system packages"
    __exec_unbuffered "$pkgmgrbinupd $*" |& __logging || exitCode=$((exitCode + 1))
    [ $exitCode -eq 0 ] && __write_log_status "upgrade was successful" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  remove) # Remove packages
    shift 1
    exitCode=0
    { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Remove a package"
    
    # Interactive mode for package selection
    if [ "$1" = "--interactive" ] || [ "$1" = "-i" ]; then
      shift 1
      printf_cyan "Loading installed packages..."
      local installed_packages=""
      
      # Get installed packages based on the system
      if __cmd_exists dpkg; then
        installed_packages="$(dpkg -l | grep '^ii' | awk '{print $2}' | sed 's/:.*$//')"
      elif __cmd_exists pacman; then
        installed_packages="$(pacman -Q | awk '{print $1}')"
      elif __cmd_exists rpm; then
        installed_packages="$(rpm -qa --qf '%{name}\n')"
      elif __cmd_exists apk; then
        installed_packages="$(apk info -q)"
      elif __cmd_exists pkg; then
        installed_packages="$(pkg query '%n')"
      else
        printf_red "Interactive mode not supported for this package manager"
        exit 1
      fi
      
      if [ -n "$installed_packages" ]; then
        readarray -t packages_array <<< "$installed_packages"
        local selected=$(__interactive_select "Select packages to remove" "true" "${packages_array[@]}")
        
        if [ -n "$selected" ]; then
          declare -a LISTARRAY=($selected)
          printf_yellow "⚠ You are about to remove: ${LISTARRAY[*]}"
          printf_green "Are you sure? (y/N): "
          read -r confirmation
          
          if [[ "$confirmation" =~ ^[Yy] ]]; then
            __init_log_status "remove" "$pkgmgrbindel ${LISTARRAY[*]}"
            local start_time=$(date +%s)
            __status_display "Package Removal" "running" "Removing ${#LISTARRAY[@]} packages" "$start_time"
            
            for pkg in "${LISTARRAY[@]}"; do
              if [ "$PKMGR_SHOW_PROGRESS" = "true" ]; then
                __execute_with_progress "eval $pkgmgrbindel '$pkg'" "Removing $pkg"
              else
                eval $pkgmgrbindel "$pkg" |& __logging
              fi
              __saved_file_delete "$pkg"
            done
            
            [ $exitCode -eq 0 ] && __status_display "Package Removal" "success" "Removed ${#LISTARRAY[@]} packages" "$start_time"
          else
            printf_yellow "Removal cancelled"
            exit 0
          fi
        else
          printf_yellow "No packages selected"
          exit 0
        fi
      else
        printf_red "No installed packages found"
        exit 1
      fi
    else
      # Normal mode
      declare -a LISTARRAY=("$@")

      # Map package names for the current distribution
      declare -a MAPPED_PACKAGES=()
      for pkg in "${LISTARRAY[@]}"; do
        mapped_pkg="$(__map_package_name "$pkg")"
        MAPPED_PACKAGES+=("$mapped_pkg")
      done

      __init_log_status "remove" "$pkgmgrbindel ${MAPPED_PACKAGES[*]}"

      if [ "$PKMGR_SHOW_PROGRESS" = "true" ]; then
        local start_time=$(date +%s)
        __status_display "Package Removal" "running" "Removing ${#MAPPED_PACKAGES[@]} packages" "$start_time"
      fi

      for i in "${!MAPPED_PACKAGES[@]}"; do
        pkg="${MAPPED_PACKAGES[$i]}"
        orig_pkg="${LISTARRAY[$i]}"
        if [ "$PKMGR_SHOW_PROGRESS" = "true" ]; then
          __execute_with_progress "eval $pkgmgrbindel '$pkg'" "Removing $pkg"
        else
          eval $pkgmgrbindel "$pkg" |& __logging || exitCode=$((exitCode + 1))
        fi
        __saved_file_delete "$orig_pkg"
      done
      
      if [ "$PKMGR_SHOW_PROGRESS" = "true" ]; then
        [ $exitCode -eq 0 ] && __status_display "Package Removal" "success" "" "$start_time"
      fi
    fi
    
    [ $exitCode -eq 0 ] && __write_log_status "remove was successful" || __write_log_status "Failed with status: $exitCode"
    exit ${exitCode:-0}
    ;;

  silent) # Silent
    case "$2" in
    install) # Silently install packages
      shift 2
      exitCode=0
      { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Silently install packages"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      __init_log_status "silent install" "$pkgmgrbininssil ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        eval $pkgmgrbininssil "$pkg" |& __silent_log_file && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
        [ "$execute_pkg_check" = "true" ] && { execute_pkg_check "$pkg" || exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "upgrade was successful" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # Silently remove packages
      shift 2
      exitCode=0
      { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Silently remove packages"
      declare -a LISTARRAY=("$@")
      __init_log_status "silent remove" "$pkgmgrbinremsil ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        eval $pkgmgrbinremsil "*$pkg*" |& __silent_log_file && __saved_file_delete "$pkg" || exitCode=$((exitCode + 1))
        [ "$execute_pkg_check" = "true" ] && { execute_pkg_check "$pkg" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "package was removal was successful" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    upgrade) # Silently update packages
      shift 2
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Silently upgrade your system"
      am_i_online --error || exit 1
      __init_log_status "silent update" "$pkgmgrbinupdsil $*"
      if __cmd_exists systemmgr; then
        systemmgr --raw update installer |& __silent_log_file
      fi
      eval $pkgmgrbinupdsil |& __silent_log_file || false
      [ $exitCode -eq 0 ] && __write_log_status "upgrade was successful" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    *) # Silently update packages
      shift 1
      exitCode=0
      { [ "$1" = "" ] || [ "$1" = "help" ]; } && printf_exit 2 0 "Silently install packages | defaults to a silent update"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      __init_log_status "silent update" "$pkgmgrbininssil ${LISTARRAY[*]}"
      if [ -z "$1" ]; then
        eval $pkgmgrbinupdsil |& __silent_log_file || exitCode=$((exitCode + 1))
      else
        for pkg in "${LISTARRAY[@]}"; do
          eval $pkgmgrbininssil "$pkg" |& __silent_log_file && __saved_file_create "$pkg" || exitCode=$((exitCode + 1))
        done
      fi
      [ $exitCode -eq 0 ] && __write_log_status "upgrade was successful" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  cpan | perl) # perl CPAN modules
    shift 1
    case $1 in
    install) # Install perl modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "install perl modules via cpan"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "cpan" "__cpan_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __cpan_run "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "cpan install ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # Remove perl modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove perl modules via cpan"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "cpan" "__cpan_remove ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __cpan_remove "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "cpan remove ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    check) # Check to see if perl modules are installed
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Check for cpan module"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "cpan" "__perl_exists ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __perl_exists --sudo "$pkg" |& __logging || { printf_red "CPAN module $pkg is missing" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "cpan check" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    *) # Install perl modules
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "install perl modules via cpan"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "cpan" "__cpan_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __cpan_run "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "cpan ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  pip | python) # Python modules
    shift 1
    case $1 in
    install) # Install python modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install python modules via pip"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "pip" "__pip_run ${LISTARRAY[*]}"
      __pip_run "${LISTARRAY[*]}" || exitCode=$((exitCode + 1))
      [ $exitCode -eq 0 ] && __write_log_status "pip install ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # Remove python modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove python modules via pip"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "pip" "__pip_remove ${LISTARRAY[*]}"
      __pip_remove "${LISTARRAY[*]}" || exitCode=$((exitCode + 1))
      [ $exitCode -eq 0 ] && __write_log_status "pip remove ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    check) # Check to see if python module is installed
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Check for pip module"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "pip" "__python_exists ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __python_exists --sudo "$pkg" |& __logging || { printf_red "PIP module $pkg is missing" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "pip chack ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  gem | ruby) # ruby modules
    shift 1
    case $1 in
    install) # Install ruby modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install ruby modules via rubygems"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "gem" "__gem_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __gem_run "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "gem install ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # remove ruby modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove ruby modules via rubygems"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "gem" "__gem_remove ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __gem_remove "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "gem remove ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    check) # Check to see if ruby module is installed
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove ruby modules via rubygems"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "gem" "__gem_exists ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __gem_exists --sudo "$pkg" |& __logging || { printf_red "GEM module $pkg is missing" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "gem check ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    *) # Install ruby modules
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install ruby modules via rubygems"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "gem" "__gem_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __gem_run "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "gem ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  npm | node) # node modules
    shift 1
    case $1 in
    install) # Install node modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install node package via npm"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "npm" "__npm_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __npm_run "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "npm install ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # Remove node modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove node package via npm"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "npm" "__npm_remove ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __npm_remove "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "npm remove ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    check) # Check to see if node module is installed
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Check npm module"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "npm" "__npm_exists ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __npm_exists --sudo "$pkg" |& __logging || { printf_red "NPM module $pkg is missing" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "npm check ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    *) # Install node modules
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install node package via npm"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "npm" "__npm_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __npm_run "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "npm ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  go) # GO modules
    shift 1
    case $1 in
    install) # Install GO modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install go modules"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "go" "__go_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __go_run "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "go install ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # Remove GO modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove go modules"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "go" "__go_remove ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __go_remove "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "go remove ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    check) # Check to see if GO module is installed
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Check for go module"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "go" "__go_exists ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __go_exists "$pkg" |& __logging || { printf_red "go module $pkg is missing" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "go check ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    *) # Install GO modules
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install go modules via"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "go" "__go_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __go_run "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "go ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  lua) # LUA modules
    shift 1
    case $1 in
    install) # Install lua modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install lua modules via luarocks"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "lua" "__lua_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __lua_run "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "lua install ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    remove) # Remove lua modules
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Remove lua modules via luarocks"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "lua" "__lua_remove ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __lua_remove "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "lua remove ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;

    check) # Check to see if lua module is installed
      shift 1
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Check for lua module"
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "lua" "__lua_exists ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __lua_exists "$pkg" |& __logging || { printf_red "lua module $pkg is missing" && exitCode=$((exitCode + 1)); }
      done
      [ $exitCode -eq 0 ] && __write_log_status "lua check ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    *) # Install lua modules
      exitCode=0
      [ "$1" = "help" ] && printf_exit 2 0 "Install lua modules via luarocks"
      am_i_online --error || exit 1
      declare -a LISTARRAY=("$@")
      [ "$PKMGR_LOG_ENABLED" = "true" ] && __init_log_status "lua" "__lua_run ${LISTARRAY[*]}"
      for pkg in "${LISTARRAY[@]}"; do
        __lua_run "$pkg" |& __logging || exitCode=$((exitCode + 1))
      done
      [ $exitCode -eq 0 ] && __write_log_status "lua ran successfully" || __write_log_status "Failed with status: $exitCode"
      exit ${exitCode:-0}
      ;;
    esac
    ;;

  info) # Show system info
    shift 1
    [ "$1" = "help" ] && printf_exit 2 0 "Show info about your system"
    __show_info "${1:-notruncate}"
    ;;

  version) # Show version
    shift 1
    run_install_version "$@"
    exit
    ;;

  bin) # pass everything to $pkgmgrbin
    shift 1
    $pkgmgrbin "$@"
    ;;

  *) # Help
    __help
    ;;
  esac
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined variables/import external variables

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Application Folders
PKMGR_CONFIG_FILE="${PKMGR_CONFIG_FILE:-settings.conf}"
PKMGR_CONFIG_DIR="${PKMGR_CONFIG_DIR:-$HOME/.config/myscripts/pkmgr}"
PKMGR_CONFIG_BACKUP_DIR="${PKMGR_CONFIG_BACKUP_DIR:-$HOME/.local/share/myscripts/pkmgr/backups}"
PKMGR_LOG_DIR="${PKMGR_LOG_DIR:-$HOME/.local/log/pkmgr}"
PKMGR_TEMP_DIR="${PKMGR_TEMP_DIR:-$HOME/.local/tmp/system_scripts/pkmgr}"
PKMGR_CACHE_DIR="${PKMGR_CACHE_DIR:-$HOME/.cache/pkmgr}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
PKMGR_OUTPUT_COLOR_1="${PKMGR_OUTPUT_COLOR_1:-33}"
PKMGR_OUTPUT_COLOR_2="${PKMGR_OUTPUT_COLOR_2:-5}"
PKMGR_OUTPUT_COLOR_GOOD="${PKMGR_OUTPUT_COLOR_GOOD:-2}"
PKMGR_OUTPUT_COLOR_ERROR="${PKMGR_OUTPUT_COLOR_ERROR:-1}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
PKMGR_NOTIFY_ENABLED="${PKMGR_NOTIFY_ENABLED:-yes}"
PKMGR_GOOD_NAME="${PKMGR_GOOD_NAME:-Great:}"
PKMGR_ERROR_NAME="${PKMGR_ERROR_NAME:-Error:}"
PKMGR_GOOD_MESSAGE="${PKMGR_GOOD_MESSAGE:-No errors reported}"
PKMGR_ERROR_MESSAGE="${PKMGR_ERROR_MESSAGE:-Errors were reported}"
PKMGR_NOTIFY_CLIENT_NAME="${PKMGR_NOTIFY_CLIENT_NAME:-$APPNAME}"
PKMGR_NOTIFY_CLIENT_ICON="${PKMGR_NOTIFY_CLIENT_ICON:-notification-new}"
PKMGR_NOTIFY_CLIENT_URGENCY="${PKMGR_NOTIFY_CLIENT_URGENCY:-normal}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional Variables
CHECK_FOR_UPDATES_CACHE_DIR="${CHECK_FOR_UPDATES_CACHE_DIR:-$HOME/.cache/check-for-updates}"
PKMGR_FORCE_INSTALL="${PKMGR_FORCE_INSTALL:-false}"
PKMGR_NOTIFICATION_EMAIL="${PKMGR_NOTIFICATION_EMAIL:-root}"
PKMGR_OUTPUT_TRUNCATE="${PKMGR_OUTPUT_TRUNCATE:-110}"
PKMGR_LOG_ERROR="${INSTALLER_LOG_ERR:-$PKMGR_LOG_DIR/$APPNAME.err.log}"
PKMGR_LOG_INFO="${INSTALLER_LOG_FILE:-$PKMGR_LOG_DIR/$APPNAME.log}"
PKMGR_GIT_REPO="${PKMGR_GIT_REPO:-$PKMGRREPO}"
PKMGR_GIT_BRANCH="${PKMGR_GIT_BRANCH:-main}"
PKMGR_GIT_DOTFILES="${PKMGR_GIT_DOTFILES:-dotfiles}"
PKMGR_INSTALLED_LIST_DIR="/usr/local/etc/pkmgr/lists"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[ -n "$PKMGR_GIT_REPO" ] || PKMGR_GIT_REPO="${PKMGRREPO:-https://github.com/pkmgr}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Generate config files
[ -f "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE" ] || [ "$*" = "--config" ] || INIT_CONFIG="${INIT_CONFIG:-TRUE}" __gen_config ${SETARGS:-$@}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Import config
[ -f "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE" ] && . "$PKMGR_CONFIG_DIR/$PKMGR_CONFIG_FILE"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Ensure Directories exist
[ -d "$PKMGR_LOG_DIR" ] || mkdir -p "$PKMGR_LOG_DIR" |& __devnull
[ -d "$PKMGR_TEMP_DIR" ] || mkdir -p "$PKMGR_TEMP_DIR" |& __devnull
[ -d "$PKMGR_CACHE_DIR" ] || mkdir -p "$PKMGR_CACHE_DIR" |& __devnull
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
PKMGR_TEMP_FILE="${PKMGR_TEMP_FILE:-$(mktemp $PKMGR_TEMP_DIR/XXXXXX 2>/dev/null)}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup trap to remove temp file
trap '__trap_exit' EXIT
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup notification function
__notifications() {
  __cmd_exists notifications || return
  [ "$PKMGR_NOTIFY_ENABLED" = "yes" ] || return
  [ "$SEND_NOTIFICATION" = "no" ] && return
  (
    export SCRIPT_OPTS="" _DEBUG=""
    export NOTIFY_GOOD_MESSAGE="${NOTIFY_GOOD_MESSAGE:-$PKMGR_GOOD_MESSAGE}"
    export NOTIFY_ERROR_MESSAGE="${NOTIFY_ERROR_MESSAGE:-$PKMGR_ERROR_MESSAGE}"
    export NOTIFY_CLIENT_ICON="${NOTIFY_CLIENT_ICON:-$PKMGR_NOTIFY_CLIENT_ICON}"
    export NOTIFY_CLIENT_NAME="${NOTIFY_CLIENT_NAME:-$PKMGR_NOTIFY_CLIENT_NAME}"
    export NOTIFY_CLIENT_URGENCY="${NOTIFY_CLIENT_URGENCY:-$PKMGR_NOTIFY_CLIENT_URGENCY}"
    notifications "$@"
  ) |& __devnull &
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set custom actions

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Argument/Option settings
SETARGS=("$@")
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
SHORTOPTS="f"
SHORTOPTS+=""
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
LONGOPTS="completions:,config,debug,dir:,help,options,raw,version,silent"
LONGOPTS+=",force,enable-aur,raw,enable-log"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
ARRAY="check alias available install remove list curl script dotfiles upgrade export import clean "
ARRAY+="init makecache search required silent cpan pip gem npm info version bin lua go"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
LIST=""
LIST+=""
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup application options
setopts=$(getopt -o "$SHORTOPTS" --long "$LONGOPTS" -n "$APPNAME" -- "$@" 2>/dev/null)
eval set -- "${setopts[@]}" 2>/dev/null
while :; do
  case "$1" in
  --raw)
    shift 1
    export SHOW_RAW="true"
    NC=""
    RESET=""
    BLACK=""
    RED=""
    GREEN=""
    YELLOW=""
    BLUE=""
    PURPLE=""
    CYAN=""
    WHITE=""
    ORANGE=""
    LIGHTRED=""
    BG_GREEN=""
    BG_RED=""
    ICON_INFO="[ info ]"
    ICON_GOOD="[ ok ]"
    ICON_WARN="[ warn ]"
    ICON_ERROR="[ error ]"
    ICON_QUESTION="[ ? ]"
    printf_column() { tee | grep --line-buffered '^'; }
    printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
    ;;
  --debug)
    shift 1
    set -xo pipefail
    export SCRIPT_OPTS="--debug"
    export _DEBUG="on"
    __devnull() { tee || return 1; }
    __devnull2() { eval "$@" |& tee || return 1; }
    ;;
  --completions)
    if [ "$2" = "short" ]; then
      printf '%s\n' "-$SHORTOPTS" | sed 's|"||g;s|:||g;s|,|,-|g' | tr ',' '\n'
    elif [ "$2" = "long" ]; then
      printf '%s\n' "--$LONGOPTS" | sed 's|"||g;s|:||g;s|,|,--|g' | tr ',' '\n'
    elif [ "$2" = "array" ]; then
      printf '%s\n' "$ARRAY" | sed 's|"||g;s|:||g' | tr ',' '\n'
    elif [ "$2" = "list" ]; then
      printf '%s\n' "$LIST" | sed 's|"||g;s|:||g' | tr ',' '\n'
    else
      exit 1
    fi
    shift 2
    exit $?
    ;;
  --options)
    shift 1
    printf_blue "Current options for ${PROG:-$APPNAME}"
    [ -z "$SHORTOPTS" ] || __list_options "Short Options" "-${SHORTOPTS}" ',' '-' 4
    [ -z "$LONGOPTS" ] || __list_options "Long Options" "--${LONGOPTS}" ',' '--' 4
    [ -z "$ARRAY" ] || __list_options "Base Options" "${ARRAY}" ',' '' 4
    [ -z "$LIST" ] || __list_options "LIST Options" "${LIST}" ',' '' 4
    exit $?
    ;;
  --version)
    shift 1
    __version
    exit $?
    ;;
  --help)
    shift 1
    __help
    exit $?
    ;;
  --config)
    shift 1
    __gen_config
    exit $?
    ;;
  --silent)
    shift 1
    PKMGR_SILENT="true"
    ;;
  --dir)
    CWD_IS_SET="TRUE"
    PKMGR_CWD="$2"
    #[ -d "$PKMGR_CWD" ] || mkdir -p "$PKMGR_CWD" |& __devnull
    shift 2
    ;;
  -f | --force)
    shift 1
    export FORCE_INSTALL="true"
    ;;
  --enable-aur)
    shift 1
    ENABLE_AUR="true"
    ;;
  -a | --all)
    shift 1
    INSTALL_ALL="true"
    ;;
  --enable-log)
    shift 1
    PKMGR_LOG_ENABLED="true"
    __logging() { tee -a "$PKMGR_LOG_INFO" || false; }
    __devnull2() { eval "$@" 2>>"$PKMGR_LOG_ERROR" || false; }
    __devnull() { tee -a "$PKMGR_LOG_INFO" "$PKMGR_LOG_ERROR" || false; }
    ;;
  --)
    shift 1
    break
    ;;
  esac
done
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Get directory from args
# set -- "$@"
# for arg in "$@"; do
# if [ -d "$arg" ]; then
# PKMGR_CWD="$arg" && shift 1 && SET_NEW_ARGS=("$@") && break
# elif [ -f "$arg" ]; then
# PKMGR_CWD="$(dirname "$arg" 2>/dev/null)" && shift 1 && SET_NEW_ARGS=("$@") && break
# else
# SET_NEW_ARGS+=("$arg")
# fi
# done
# set -- "${SET_NEW_ARGS[@]}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set directory to first argument
# [ -d "$1" ] && __is_an_option "$1" && PKMGR_CWD="$1" && shift 1 || PKMGR_CWD="${PKMGR_CWD:-$PWD}"
PKMGR_CWD="$(realpath "${PKMGR_CWD:-$PWD}" 2>/dev/null)"
# if [ -d "$PKMGR_CWD" ] && cd "$PKMGR_CWD"; then
# if [ "$PKMGR_SILENT" != true ]; then
# printf_cyan "Setting working dir to $PKMGR_CWD"
# fi
# else
# printf_exit "💔 $PKMGR_CWD does not exist 💔"
# fi
export PKMGR_CWD
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set actions based on variables
[ -d "$CHECK_FOR_UPDATES_CACHE_DIR" ] || mkdir -p "$CHECK_FOR_UPDATES_CACHE_DIR"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for required applications/Network check
#__requiresudo "$0" "$@" || exit 2     # exit 2 if errors
#cmd_exists --error --ask bash || exit 3 # exit 3 if not found
#am_i_online --error || exit 4           # exit 4 if no internet
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# APP Variables overrides
exitCode=0
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions based on env
if __user_is_not_root; then
  __sudoif && __sudoask || printf_exit "This requires sudo privileges"
fi
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute functions

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute commands

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# begin main app
__initialize_variables "$@"
__execute_pkmgr "$@"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Set exit code
exitCode="${exitCode:-0}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# End application
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# lets exit with code
exit ${exitCode:-0}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# ex: ts=2 sw=2 et filetype=sh
