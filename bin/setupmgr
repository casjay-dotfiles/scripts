#!/usr/bin/env bash
# shellcheck shell=bash
# - - - - - - - - - - - - - - - - - - - - - - - - -
##@Version           :  202511241730-git
# @@Author           :  Jason Hempstead
# @@Contact          :  jason@casjaysdev.pro
# @@License          :  WTFPL
# @@ReadME           :  setupmgr --help
# @@Copyright        :  Copyright: (c) 2024 Jason Hempstead, Casjays Developments
# @@Created          :  Saturday, Sep 14, 2024 14:03 EDT
# @@File             :  setupmgr
# @@Description      :  Cross-platform binary/package installation manager - supports Linux, macOS, BSD, Solaris
# @@Changelog        :  Added Plandex AI coding agent with server setup
# @@TODO             :  Add systemd service files for server binaries (localai, ollama, etc)
# @@Other            :
# @@Resource         :
# @@Terminal App     :  no
# @@sudo/root        :  no
# @@Template         :  bash/system
# - - - - - - - - - - - - - - - - - - - - - - - - -
# shellcheck disable=SC1001,SC1003,SC2001,SC2003,SC2016,SC2031,SC2090,SC2120,SC2155,SC2199,SC2317,SC2329
# - - - - - - - - - - - - - - - - - - - - - - - - -
APPNAME="$(basename -- "$0" 2>/dev/null)"
VERSION="202511241730-git"
USER="${SUDO_USER:-$USER}"
RUN_USER="${RUN_USER:-$USER}"
USER_HOME="${USER_HOME:-$HOME}"
SCRIPT_SRC_DIR="${BASH_SOURCE%/*}"
SETUPMGR_REQUIRE_SUDO="${SETUPMGR_REQUIRE_SUDO:-no}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Reopen in a terminal
#if [ ! -t 0 ] && { [ "$1" = --term ] || [ $# = 0 ]; }; then { [ "$1" = --term ] && shift 1 || true; } && TERMINAL_APP="TRUE" myterminal -e "$APPNAME $*" && exit || exit 1; fi
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set script title
#CASJAYS_DEV_TILE_FORMAT="${USER}@${HOSTNAME}:${PWD/#$HOME/~} - $APPNAME"
#CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}"
#[ -z "$CASJAYSDEV_TITLE_SET" ] && printf '\033]0;%s\007' "$CASJAYS_DEV_TILE_FORMAT" && CASJAYSDEV_TITLE_SET="$APPNAME"
export CASJAYSDEV_TITLE_PREV="${CASJAYSDEV_TITLE_PREV:-${CASJAYSDEV_TITLE_SET:-$APPNAME}}" CASJAYSDEV_TITLE_SET
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Initial debugging
[ "$1" = "--debug" ] && set -x && export SCRIPT_OPTS="--debug" && export _DEBUG="on"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Disables colorization
[ "$1" = "--raw" ] && export SHOW_RAW="true"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# pipes fail
set -o pipefail
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Send all output to /dev/null
__devnull() {
  tee &>/dev/null && SETUPMGR_EXIT_STATUS=0 || SETUPMGR_EXIT_STATUS=1
  return ${SETUPMGR_EXIT_STATUS:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -'
# Send errors to /dev/null
__devnull2() {
  [ -n "$1" ] && local cmd="$1" && shift 1 || return 1
  eval $cmd "$*" 2>/dev/null && SETUPMGR_EXIT_STATUS=0 || SETUPMGR_EXIT_STATUS=1
  return ${SETUPMGR_EXIT_STATUS:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -'
# See if the executable exists
__cmd_exists() {
  local SETUPMGR_EXIT_STATUS=0
  [ -n "$1" ] || return 0
  for cmd in "$@"; do
    if builtin command -v "$cmd" &>/dev/null; then
      SETUPMGR_EXIT_STATUS=$((SETUPMGR_EXIT_STATUS + 0))
    else
      SETUPMGR_EXIT_STATUS=$((SETUPMGR_EXIT_STATUS + 1))
    fi
  done
  [ $SETUPMGR_EXIT_STATUS -eq 0 ] || SETUPMGR_EXIT_STATUS=3
  return ${SETUPMGR_EXIT_STATUS:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for a valid internet connection
__am_i_online() {
  local SETUPMGR_EXIT_STATUS=0
  curl -q -LSsfI --max-time 1 --retry 0 "${1:-https://1.1.1.1}" 2>&1 | grep -qi 'server:.*cloudflare' || SETUPMGR_EXIT_STATUS=4
  return ${SETUPMGR_EXIT_STATUS:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# colorization
if [ "$SHOW_RAW" = "true" ]; then
  NC=""
  RESET=""
  BLACK=""
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  PURPLE=""
  CYAN=""
  WHITE=""
  ORANGE=""
  LIGHTRED=""
  BG_GREEN=""
  BG_RED=""
  ICON_INFO="[ info ]"
  ICON_GOOD="[ ok ]"
  ICON_WARN="[ warn ]"
  ICON_ERROR="[ error ]"
  ICON_QUESTION="[ ? ]"
  printf_column() { tee | grep '^'; }
  printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
else
  printf_color() { printf "%b" "$(tput setaf "${2:-7}" 2>/dev/null)" "$1" "$(tput sgr0 2>/dev/null)"; }
fi
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional printf_ colors
__printf_head() { printf_blue "$1"; }
__printf_opts() { printf_purple "$1"; }
__printf_line() { printf_cyan "$1"; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
# output version
__version() { printf_cyan "$VERSION"; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Inlined external functions - BEGIN
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Printf functions from colors.bash
printf_newline() {
  [[ -n "$1" ]] && printf '%b\n' "${*:-}" || printf '\n'
}
printf_green() {
  printf_color "$1" 2
  printf "\n"
}
printf_red() {
  printf_color "$1" 9
  printf "\n"
}
printf_purple() {
  printf_color "$1" 5
  printf "\n"
}
printf_yellow() {
  printf_color "$1" 3
  printf "\n"
}
printf_blue() {
  printf_color "$1" 33
  printf "\n"
}
printf_cyan() {
  printf_color "$1" 6
  printf "\n"
}
printf_return() {
  test -n "$1" && test -z "${1//[0-9]/}" && local color="$1" && shift 1 || local color="1"
  test -n "$1" && test -z "${1//[0-9]/}" && local exitCode="$1" && shift 1 || local exitCode="1"
  local msg="$*"
  [ ${#msg} = 0 ] || { printf_color "$msg" "$color" 1>&2 && printf "\n"; }
  return ${exitCode:-2}
}
printf_exit() {
  test -n "$1" && test -z "${1//[0-9]/}" && local color="$1" && shift 1 || local color="1"
  test -n "$1" && test -z "${1//[0-9]/}" && local exitCode="$1" && shift 1 || local exitCode="1"
  local msg="$*"
  shift
  printf_color "$msg" "$color" 1>&2
  printf "\n"
  exit "$exitCode"
}
printf_head() {
  test -n "$1" && test -z "${1//[0-9]/}" && local color="$1" && shift 1 || local color="6"
  local msg1="$1" && shift 1
  local msg2="$1" && shift 1 || msg2=
  local msg3="$1" && shift 1 || msg3=
  shift
  [ -z "$msg1" ] || printf_color "##################################################\n" "${PRINTF_COLOR:-$color}"
  [ -z "$msg1" ] || printf_color "$msg1\n" "${PRINTF_COLOR:-$color}"
  [ -z "$msg2" ] || printf_color "$msg2\n" "${PRINTF_COLOR:-$color}"
  [ -z "$msg3" ] || printf_color "$msg3\n" "${PRINTF_COLOR:-$color}"
  [ -z "$msg1" ] || printf_color "##################################################\n" "${PRINTF_COLOR:-$color}"
}
printf_line() {
  test -n "$1" && test -z "${1//[0-9]/}" && local color="$1" && shift 1 || local color="6"
  local msg="$*"
  printf_color "$msg\n" "${PRINTF_COLOR:-$color}"
}
printf_opts() {
  test -n "$1" && test -z "${1//[0-9]/}" && local color="$1" && shift 1 || local color="5"
  local msg="$*"
  printf_color "$msg\n" "${PRINTF_COLOR:-$color}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Utility functions from various sources
__basename() {
  basename -- "${1:-.}" 2>/dev/null
}
ask_for_password() {
  local opts="$*"
  if [ "$opts" = "sudo true" ]; then
    sudo -v 2>/dev/null && return 0 || return 1
  else
    printf_red "ask_for_password: Unknown option: $opts"
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Inlined external functions - END
# - - - - - - - - - - - - - - - - - - - - - - - - -
# list options
__list_options() {
  printf_color "$1: " "$5"
  echo -ne "$2" | sed 's|:||g;s/'$3'/ '$4'/g' | tr '\n' ' '
  printf_newline
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# create the config file
__gen_config() {
  local NOTIFY_CLIENT_NAME="$APPNAME"
  if [ "$INIT_CONFIG" != "TRUE" ]; then
    printf_blue "Generating the config file in"
    printf_cyan "$SETUPMGR_CONFIG_DIR/$SETUPMGR_CONFIG_FILE"
  fi
  [ -d "$SETUPMGR_CONFIG_DIR" ] || mkdir -p "$SETUPMGR_CONFIG_DIR"
  [ -d "$SETUPMGR_CONFIG_BACKUP_DIR" ] || mkdir -p "$SETUPMGR_CONFIG_BACKUP_DIR"
  [ -f "$SETUPMGR_CONFIG_DIR/$SETUPMGR_CONFIG_FILE" ] &&
    cp -Rf "$SETUPMGR_CONFIG_DIR/$SETUPMGR_CONFIG_FILE" "$SETUPMGR_CONFIG_BACKUP_DIR/$SETUPMGR_CONFIG_FILE.$$"
  cat <<EOF >"$SETUPMGR_CONFIG_DIR/$SETUPMGR_CONFIG_FILE"
# Settings for setupmgr
SETUPMGR_DEFAULT_USER_BIN_DIR="${SETUPMGR_DEFAULT_USER_BIN_DIR:-}"
SETUPMGR_DEFAULT_SYSTEM_BIN_DIR="${SETUPMGR_DEFAULT_SYSTEM_BIN_DIR:-}"
SETUPMGR_DEFAULT_USER_SHARE_DIR="${SETUPMGR_DEFAULT_USER_SHARE_DIR:-}"
SETUPMGR_DEFAULT_SYSTEM_SHARE_DIR="${SETUPMGR_DEFAULT_SYSTEM_SHARE_DIR:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# default npm packages
NODE_NPM_PACKAGES="${NODE_NPM_PACKAGES:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# LUA settings
LUAVER_HOME="${LUAVER_HOME:-}"
LUA_JIT_VERSION="${LUA_JIT_VERSION:-}"
LUA_DEFAULT_VERSION="${LUA_DEFAULT_VERSION:-}"
LUA_ROCKS_DEFAULT_VERSION="${LUA_ROCKS_DEFAULT_VERSION:-}"
LUAVER_GIT_REPO="${LUAVER_GIT_REPO:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# ASDF Settings
ASDF_DIR="${ASDF_DIR:-}"
ASDF_DATA_DIR="${ASDF_DATA_DIR:-}"
ASDF_GITREPO="${ASDF_GITREPO:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
DBX_HOME="${DBX_HOME:-}"
DISTROBOX_HOME="${DISTROBOX_HOME:-}"
DISTROBOX_SCRIPT_URL="${DISTROBOX_SCRIPT_URL:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# dotnet settings
DOTNET_ROOT="${DOTNET_ROOT:-}"
DOTNET_SCRIPT_URL="${DOTNET_SCRIPT_URL:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# gvm settings
GVM_ROOT="${GVM_ROOT:-}"
GVM_GITREPO="${GVM_GITREPO:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# vagrant settings
VAGRANT_HOME="${VAGRANT_HOME:-}"
VAGRANT_DEFAULT_PROVIDER="${VAGRANT_DEFAULT_PROVIDER:-}"
VAGRANT_DEFAULT_BOX="${VAGRANT_DEFAULT_BOX:-}"
VAGRANT_CLOUD_TOKEN="${VAGRANT_CLOUD_TOKEN:-}"
VAGRANT_CLOUD_USERNAME="${VAGRANT_CLOUD_USERNAME:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# fnm settings
FNM_DIR="${FNM_DIR:-}"
FNM_NODE_VERSION="${FNM_NODE_VERSION:-}"
FNM_INSTALL_SCRIPT="${FNM_INSTALL_SCRIPT:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# nvm settings
NVM_NODE_VERSION="${NVM_NODE_VERSION:-}"
NVM_DIR="${NVM_DIR:-}"
NVM_GITREPO="${NVM_GITREPO:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# powershell settings
POWERSHELL_INSTALL_DIR="${POWERSHELL_INSTALL_DIR:-}"
POWERSHELL_TEMP_DIR="${POWERSHELL_TEMP_DIR:-}"
POWERSHELL_LATEST_URL="${POWERSHELL_LATEST_URL:-}"
POWERSHELL_OMP_GITREPO="${POWERSHELL_OMP_GITREPO:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# jekyll settings
JEKYLL_VERSION="${JEKYLL_VERSION:-}"
JEKYLL_RUBY_VERSION="${JEKYLL_RUBY_VERSION:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# rvm settings
rvm_path="${rvm_path:-}"
RVM_GITREPO="${RVM_GITREPO:-}"
RVM_RUBY_VERSION="${RVM_RUBY_VERSION:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# rbenv settings
RBENV_ROOT="${RBENV_ROOT:-}"
RBENV_GITREPO="${RBENV_GITREPO:-}"
RBENV__RUBY_VERSION="${RBENV__RUBY_VERSION:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# minikube settings
MINIKUBE_MEMORY="${MINIKUBE_MEMORY:-}"
MINIKUBE_DRIVER="${MINIKUBE_DRIVER:-}"
MINIKUBE_HOME="${MINIKUBE_HOME:-}"
KIND_BIN_DIR="${KIND_BIN_DIR:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# packer settings
PACKER_VERSION="${PACKER_VERSION:-}"
PACKER_PLUGINS="${PACKER_PLUGINS:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# casaOS settings
CASAOS_SCRIPT_URL="${CASAOS_SCRIPT_URL:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# coolify settings
COOLIFY_SCRIPT_URL="${COOLIFY_SCRIPT_URL:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
GO_VERSION="${GO_VERSION:-}"
GO_INSTALL_DIR="${GO_INSTALL_DIR:-}"
ZED_INSTALL_DIR="${ZED_INSTALL_DIR:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
SETUPMGR_OUTPUT_COLOR_1="${SETUPMGR_OUTPUT_COLOR_1:-}"
SETUPMGR_OUTPUT_COLOR_2="${SETUPMGR_OUTPUT_COLOR_2:-}"
SETUPMGR_OUTPUT_COLOR_GOOD="${SETUPMGR_OUTPUT_COLOR_GOOD:-}"
SETUPMGR_OUTPUT_COLOR_ERROR="${SETUPMGR_OUTPUT_COLOR_ERROR:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
SETUPMGR_SYSTEM_NOTIFY_ENABLED="${SETUPMGR_SYSTEM_NOTIFY_ENABLED:-}"
SETUPMGR_GOOD_NAME="${SETUPMGR_GOOD_NAME:-}"
SETUPMGR_ERROR_NAME="${SETUPMGR_ERROR_NAME:-}"
SETUPMGR_GOOD_MESSAGE="${SETUPMGR_GOOD_MESSAGE:-}"
SETUPMGR_ERROR_MESSAGE="${SETUPMGR_ERROR_MESSAGE:-}"
SETUPMGR_NOTIFY_CLIENT_NAME="${SETUPMGR_NOTIFY_CLIENT_NAME:-}"
SETUPMGR_NOTIFY_CLIENT_ICON="${SETUPMGR_NOTIFY_CLIENT_ICON:-}"
SETUPMGR_NOTIFY_CLIENT_URGENCY="${SETUPMGR_NOTIFY_CLIENT_URGENCY:-}"

EOF
  if builtin type -t __gen_config_local | grep -q 'function'; then __gen_config_local; fi
  if [ -f "$SETUPMGR_CONFIG_DIR/$SETUPMGR_CONFIG_FILE" ]; then
    [ "$INIT_CONFIG" = "TRUE" ] || printf_green "Your config file for $APPNAME has been created"
    . "$SETUPMGR_CONFIG_DIR/$SETUPMGR_CONFIG_FILE"
    SETUPMGR_EXIT_STATUS=0
  else
    printf_red "Failed to create the config file"
    SETUPMGR_EXIT_STATUS=1
  fi
  return ${SETUPMGR_EXIT_STATUS:-0}
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Help function - Align to 50
__help() {
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "setupmgr:  - $VERSION"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "Usage: setupmgr [options] [commands]"
  __printf_line "remove [package...]             - Remove installed packages"
  __printf_line "all                             - Install all available packages"
  __printf_line "system                          - Install packages system-wide"
  __printf_line " - "
  __printf_line "Supported Platforms: Linux, macOS, FreeBSD, OpenBSD, NetBSD, DragonFly BSD, Solaris"
  __printf_line "Supported Architectures: x86_64 (amd64), aarch64 (arm64), armv7 (arm), armv6"
  __printf_line " - "
  __printf_line "Package Installation Commands:"
  __printf_line "act,aichat,aider,asdf,atuin,bat,bob,broot,bun,caddy,coder,ctop,delta,deno,devbox,direnv,distrobox,dive"
  __printf_line "dotnet,dust,exa,fabric,fastfetch,fd,fnm,fzf,garage,gemini,gh,glow,go,gohttpserver"
  __printf_line "gpt,gvm,helm,helix,hyperfine,incus,jekyll,jless,just,k9s,kind,kubectl,lapce,lazydocker"
  __printf_line "lazygit,lima,llama-cpp,llm,localai,lua,mc,minikube,minio_server,mods,nix,nodejs,nvm,ollama"
  __printf_line "opentofu,packer,plandex,pipx,podman,powershell,procs,rbenv,ripgrep,ruff,rustup,rvm"
  __printf_line "shellcheck,shfmt,speedtest,starship,tokei,traefik,uv,vagrant,vfox"
  __printf_line "webhookd,yq,zed,zellij,zig,zoxide,claude,copilot,cortex,codex,vercel,prettier,eslint"
  __printf_line "npm-check-updates"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_opts "Other Options"
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
  __printf_line "--help                          - Shows this message"
  __printf_line "--config                        - Generate user config file"
  __printf_line "--version                       - Show script version"
  __printf_line "--options                       - Shows all available options"
  __printf_line "--debug                         - Enables script debugging"
  __printf_line "--raw                           - Removes all formatting on output"
  __printf_line "--no                            - No options"
  __printf_line "--yes                           - Yes options"
  __printf_line ""
  __printf_head "- - - - - - - - - - - - - - - - - - - - - - - - -"
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__grep() { grep "$@" 2>/dev/null; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
# check if arg is a builtin option
__is_an_option() { if echo "$ARRAY" | grep -q "${1:-^}"; then return 1; else return 0; fi; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Is current user root
__user_is_root() {
  { [ $(id -u) -eq 0 ] || [ $EUID -eq 0 ] || [ "$WHOAMI" = "root" ]; } && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Is current user not root
__user_is_not_root() {
  if { [ $(id -u) -eq 0 ] || [ $EUID -eq 0 ] || [ "$WHOAMI" = "root" ]; }; then return 1; else return 0; fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Check if user is a member of sudo
__sudo_group() {
  grep -sh "${1:-$USER}" "/etc/group" | grep -Eq 'wheel|adm|sudo' || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# # Get sudo password
__sudoask() {
  ask_for_password sudo true && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Run sudo
__sudorun() {
  __sudoif && __cmd_exists sudo && sudo -HE "$@" || { __sudoif && eval "$@"; }
  return $?
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Test if user has access to sudo
__can_i_sudo() {
  (sudo -vn && sudo -ln) 2>&1 | grep -vq 'may not' >/dev/null && return 0
  __sudo_group "${1:-$USER}" || __sudoif || sudo true &>/dev/null || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# User can run sudo
__sudoif() {
  __user_is_root && return 0
  __can_i_sudo "${RUN_USER:-$USER}" && return 0
  __user_is_not_root && __sudoask && return 0 || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Run command as root
requiresudo() {
  if [ "$SETUPMGR_REQUIRE_SUDO" = "yes" ] && [ -z "$SETUPMGR_REQUIRE_SUDO_RUN" ]; then
    export SETUPMGR_REQUIRE_SUDO="no"
    export SETUPMGR_REQUIRE_SUDO_RUN="true"
    sudo "$@"
    exit $?
  else
    return 0
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute sudo
__sudo() {
  CMD="${1:-echo}" && shift 1
  CMD_ARGS="${*:--e "${RUN_USER:-$USER}"}"
  SUDO="$(builtin command -v sudo 2>/dev/null || echo 'eval')"
  [ "$(basename -- "$SUDO" 2>/dev/null)" = "sudo" ] && OPTS="--preserve-env=PATH -HE"
  if __sudoif; then
    export PATH="$PATH"
    $SUDO ${OPTS:-} $CMD $CMD_ARGS && true || false
    SETUPMGR_EXIT_STATUS=$?
  else
    printf '%s\n' "This requires root to run"
    SETUPMGR_EXIT_STATUS=1
  fi
  return ${SETUPMGR_EXIT_STATUS:-0}
}
# End of sudo functions
# - - - - - - - - - - - - - - - - - - - - - - - - -
__how_long_did_it_take() {
  local retprev=$?
  local retval=${1:-$retprev}
  __cmd_exists bc || return $retval
  [ -n "$SETUPMGR_START_TIMER" ] || return 0
  local stop_time="$(date +%s.%N)"
  local dt=$(echo "$stop_time - $SETUPMGR_START_TIMER" | bc)
  local dd=$(echo "$dt/86400" | bc)
  local dt2=$(echo "$dt-86400*$dd" | bc)
  local dh=$(echo "$dt2/3600" | bc)
  local dt3=$(echo "$dt2-3600*$dh" | bc)
  local dm=$(echo "$dt3/60" | bc)
  local ds=$(echo "$dt3-60*$dm" | bc)
  printf_purple "$(LC_NUMERIC=C printf "Total runtime: %d Days, %02d Hours, %02d Minutes, %02.4f Seconds\n" $dd $dh $dm $ds)"
  return $retval
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__trap_exit() {
  SETUPMGR_EXIT_STATUS=${SETUPMGR_EXIT_STATUS:-0}
  [ -n "$SETUPMGR_TEMP_FILE" ] && [ -f "$SETUPMGR_TEMP_FILE" ] && rm -Rf "$SETUPMGR_TEMP_FILE" &>/dev/null
  [ -n "$SETUPMGR_TEMP_EXTRACT_FILE" ] && [ -e "$SETUPMGR_TEMP_EXTRACT_FILE" ] && rm -Rf "$SETUPMGR_TEMP_EXTRACT_FILE"
  #unset CASJAYSDEV_TITLE_SET && printf '\033]2â”‚;%s\033\\' "${USER}@${HOSTNAME}:${PWD/#$HOME/~} - ${CASJAYSDEV_TITLE_PREV:-$SHELL}"
  if builtin type -t __trap_exit_local | grep -q 'function'; then __trap_exit_local; fi
  return $SETUPMGR_EXIT_STATUS
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Create a --no-* options function
__options_function_no() {
  local options="${1//=*/}"
  local argument="${1//*=/}"
  case "$options" in
  *-tee) __output_status() { tee; } && shift ;;
  *) echo "${argument:-No argument provided}" && shift ;;
  esac
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Create a --yes-* options function
__options_function_yes() {
  local options="${1//=*/}"
  local argument="${1//*=/}"
  case "$options" in
  *) echo "${argument:-No argument provided}" && shift ;;
  esac
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup notification function
__notifications() {
  __cmd_exists notifications || return
  [ "$SETUPMGR_SYSTEM_NOTIFY_ENABLED" = "yes" ] || return
  [ "$SEND_NOTIFICATION" = "no" ] && return
  (
    export SCRIPT_OPTS="" _DEBUG=""
    export NOTIFY_GOOD_MESSAGE="${NOTIFY_GOOD_MESSAGE:-$SETUPMGR_GOOD_MESSAGE}"
    export NOTIFY_ERROR_MESSAGE="${NOTIFY_ERROR_MESSAGE:-$SETUPMGR_ERROR_MESSAGE}"
    export NOTIFY_CLIENT_ICON="${NOTIFY_CLIENT_ICON:-$SETUPMGR_NOTIFY_CLIENT_ICON}"
    export NOTIFY_CLIENT_NAME="${NOTIFY_CLIENT_NAME:-$SETUPMGR_NOTIFY_CLIENT_NAME}"
    export NOTIFY_CLIENT_URGENCY="${NOTIFY_CLIENT_URGENCY:-$SETUPMGR_NOTIFY_CLIENT_URGENCY}"
    notifications "$@"
  ) |& __devnull &
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__notify_remote() {
  local cmd="$(echo "$SETUPMGR_REMOTE_NOTIFY_COMMAND" | awk -F ' ' '{print $1}')"
  if [ "$SETUPMGR_REMOTE_NOTIFY_ENABLED" = "yes" ]; then
    if [ -n "$(command -v "$cmd")" ]; then
      eval $SETUPMGR_REMOTE_NOTIFY_COMMAND "$@"
    fi
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup trap to remove temp file
trap '__trap_exit' EXIT
# - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined functions
__output_status() { tee /dev/null &>/dev/null; }
__curl() { curl -q -LSsf "$@" 2>/dev/null || return 1; }
__get_releases() { __curl "$1" | jq -r '.[].name' | grep -vE 'beta|dev' | sort -rV | head -n1 || return 1; }
__get_release_info() { __curl "$1" | grep "$2" 2>/dev/null | cut -d '"' -f 4 2>/dev/null | grep "${3:-^}" 2>/dev/null; }
__is_dir_empty() { if [ "$(find "$1" -maxdepth 1 -type f 2>/dev/null | grep -v '^$' | wc -l)" != 0 ]; then return 1; fi; }
__dir_has_one_folder() { if [ "$(find "$1" -maxdepth 1 -type d 2>/dev/null | grep -v '^$' | wc -l)" != 1 ]; then return 1; fi; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__rm() { [ -n "$1" ] && [ -e "$1" ] && \rm -Rf "$@"; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__check_for_vulkan_support() { if __check_for_vulkan_info; then __check_for_vulkan_error; else return 1; fi; }
__check_for_vulkan_error() { if [ $? -eq 2 ]; then printf_red "This system doesn't seem to have vulkan support: Try installing vulkan drivers" && return 1; else return 0; fi; }
__check_for_vulkan_info() { __cmd_exists vulkaninfo && { vulkaninfo 2>/dev/null | grep 'Devices: count = ' | awk -F '=' '{print $2}' | sed 's| ||g' | grep -qv '0' || return 2; } || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_update_repo() { (git -C "$1" reset --hard && git -C "$1" fetch origin && git -C "$1" pull && git -C "$1" reset --hard) &>/dev/null || return 1; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__git_clone_repo() { git clone "$1" "$2" -q &>/dev/null || return 2; }
# - - - - - - - - - - - - - - - - - - - - - - - - -
__npm_install_global() {
  printf_blue "Installing npm package: $1"
  eval "$SETUPMG_NPM_SYSTEM_BIN_FILE" install "$1" -g --silent --no-progress 2>/dev/null
  npm list -g --depth=0 2>/dev/null | grep "$1" | awk -F '/' '{print $2}' | sed 's|@.*||g' | grep -q '^' ||
    npm list -g --depth=0 2>/dev/null | grep "$1" | sed 's|.* ||g;s|@.*||g' | grep -q '^' || return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__execute_npm() {
  local name="$1"
  local package=$2
  SETUPMG_NPM_SYSTEM_BIN_FILE="${SETUPMG_NPM_SYSTEM_BIN_FILE:-$(type -p npm 2>/dev/null)}"
  if [ -z "$SETUPMG_NPM_SYSTEM_BIN_FILE" ]; then
    printf_red "npm is not installed"
    return 1
  fi
  if __cmd_exists "$name" && [ "$SETUPMGR_FORCE_INSTALL" != "true" ]; then
    printf_green "$name is already installed"
    return 0
  elif __npm_install_global "$package"; then
    printf_green "Installed npm package: $package"
  else
    printf_red "Failed to install npm package: $package"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__is_npm_package() {
  local pkg="$1"
  echo " $NODE_NPM_PACKAGES " | grep -q " $pkg "
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__install_to_system_bin() {
  local basename="$(__basename "$1")"
  local sysBinDir="${SETUPMGR_DEFAULT_SYSTEM_BIN_DIR:-/usr/local/bin}"
  if [ -f "$1" ] && __can_i_sudo; then __sudo cp -Rf "$1" "$sysBinDir/$basename" && __sudo chmod -Rf 777 "$sysBinDir/$basename" && printf_blue "Installed to $sysBinDir/$basename"; fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__gen_desktopfile() {
  local exitCode=0
  local desktop_file="$HOME/.local/share/applications/$1.desktop"
  mkdir -p "$HOME/.local/share/applications"
  [ -f "$desktop_file" ] && return
  cat <<EOF | tee "$desktop_file" &>/dev/null
[Desktop Entry]
Name=$1
Exec=$2
Type=Application
Icon=xfce4

EOF
  if [ -f "$desktop_file" ]; then
    chmod 755 "$desktop_file"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__is_installed() {
  local name="$1"
  local path="$2"
  if [ -x "$path" ] || [ -d "$2" ]; then
    return 0
  else
    return 1
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# url options
__download_and_execute() {
  local exitCode=0
  local url="$1" name="$(__basename "$1")" && shift 1
  [ "$1" = "sudo" ] && local use_sudo="yes" && shift 1
  SETUPMGR_TEMP_EXECUTE_FILE=$SETUPMGR_TEMP_DIR/$name
  if [ -n "$PACKAGE_TMP_DIR" ] && [ -d "$PACKAGE_TMP_DIR" ]; then
    __rm "$PACKAGE_TMP_DIR"/*
  fi
  [ -n "$SETUPMGR_TEMP_EXECUTE_FILE" ] && { __rm "$SETUPMGR_TEMP_EXECUTE_FILE" || true; } || return
  if [ "$use_sudo" = "yes" ]; then
    shift 1
    __curl "$url" | sudo -- bash -s -- "$@" 2>/dev/null || exitCode=1
  else
    __curl "$url" | bash -s -- "$@" 2>/dev/null || exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# url tmpFile installDir files
__download_extract_all() {
  local exitCode=0
  local url="$1" name="$(__basename "$1")" && shift 1
  SETUPMGR_TEMP_EXTRACT_FILE=$SETUPMGR_TEMP_DIR/$name
  if [ -n "$PACKAGE_TMP_DIR" ] && [ -d "$PACKAGE_TMP_DIR" ]; then
    __rm "$PACKAGE_TMP_DIR"/*
  fi
  [ -d "$SETUPMGR_TEMP_DIR" ] || mkdir -p "$SETUPMGR_TEMP_DIR"
  [ -n "$SETUPMGR_TEMP_EXTRACT_FILE" ] && { __rm "$SETUPMGR_TEMP_EXTRACT_FILE" || true; } || return
  if __curl "$url" -o "$SETUPMGR_TEMP_EXTRACT_FILE"; then
    tmpFile="$SETUPMGR_TEMP_EXTRACT_FILE"
    __extract "$SETUPMGR_TEMP_EXTRACT_FILE" "--all" "$@" || exitCode=1
  else
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# url tmpFile installDir files
__download_extract_move() {
  local exitCode=0
  local url="$1" name="$(__basename "$1")" && shift 1
  SETUPMGR_TEMP_EXTRACT_FILE=$SETUPMGR_TEMP_DIR/$name
  if [ -z "$url" ]; then
    printf_red "The url was not provided"
    return 1
  fi
  if [ -n "$PACKAGE_TMP_DIR" ] && [ -d "$PACKAGE_TMP_DIR" ]; then
    __rm "$PACKAGE_TMP_DIR"/*
  fi
  [ -d "$SETUPMGR_TEMP_DIR" ] || mkdir -p "$SETUPMGR_TEMP_DIR"
  [ -n "$SETUPMGR_TEMP_EXTRACT_FILE" ] && { __rm "$SETUPMGR_TEMP_EXTRACT_FILE" || true; } || return
  if __curl "$url" -o "$SETUPMGR_TEMP_EXTRACT_FILE"; then
    tmpFile="$SETUPMGR_TEMP_EXTRACT_FILE"
    __extract "$SETUPMGR_TEMP_EXTRACT_FILE" "--files" "$@" || exitCode=1
  else
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# url installDir name binDir/name
__download_extract_install() {
  local exitCode=0
  local url="$1" name="$(__basename "$1")" && shift 1
  SETUPMGR_TEMP_EXTRACT_FILE=$SETUPMGR_TEMP_DIR/$name
  [ -n "$url" ] || return 1
  if [ -n "$PACKAGE_TMP_DIR" ] && [ -d "$PACKAGE_TMP_DIR" ]; then
    __rm "$PACKAGE_TMP_DIR"/*
  fi
  [ -d "$SETUPMGR_TEMP_DIR" ] || mkdir -p "$SETUPMGR_TEMP_DIR"
  [ -n "$SETUPMGR_TEMP_EXTRACT_FILE" ] && { __rm "$SETUPMGR_TEMP_EXTRACT_FILE" || true; } || return
  [ -n "$url" ] || { printf_return "Can not get download link" && return 1; }
  if __curl "$url" -o "$SETUPMGR_TEMP_EXTRACT_FILE"; then
    tmpFile="$SETUPMGR_TEMP_EXTRACT_FILE"
    __extract "$SETUPMGR_TEMP_EXTRACT_FILE" "--install" "$1" "$2" "$3" || exitCode=1
  else
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# url tmpFile tmpFile moveTo
__download_and_move() {
  local exitCode=0
  local url="$1" name="$(__basename "$1")" && shift 1
  [ -n "$url" ] && [ $# -gt 1 ] || return 1
  SETUPMGR_TEMP_MOVE_FILE="$SETUPMGR_TEMP_DIR/$name"
  [ -n "$SETUPMGR_TEMP_MOVE_FILE" ] || return
  if [ -n "$PACKAGE_TMP_DIR" ] && [ -e "$PACKAGE_TMP_DIR" ]; then
    __rm "$PACKAGE_TMP_DIR"
  fi
  [ -d "$SETUPMGR_TEMP_DIR" ] || mkdir -p "$SETUPMGR_TEMP_DIR"
  [ -f "$SETUPMGR_TEMP_MOVE_FILE" ] && __rm "$SETUPMGR_TEMP_MOVE_FILE"
  if __curl "$url" -o "$SETUPMGR_TEMP_MOVE_FILE"; then
    mv -f "$SETUPMGR_TEMP_MOVE_FILE" "$2" && chmod +x "$2" && __rm "$SETUPMGR_TEMP_MOVE_FILE"
    [ -x "$2" ] || exitCode=1
  else
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Download and install AppImage: url name [binDir]
# Automatically strips .AppImage extension and installs system-wide if sudo available
__download_install_appimage() {
  local exitCode=0
  local url="$1"
  local name="$2"
  local userBinDir="$3"
  local binFile=""
  local binDir=""
  local prefix=""

  if [ -z "$url" ] || [ -z "$name" ]; then
    printf_red "Usage: __download_install_appimage <url> <name> [binDir]"
    return 1
  fi

  # Strip .AppImage extension from name if present
  name="${name%.AppImage}"
  name="${name%.appimage}"

  # Determine installation directory (system-wide if sudo, user otherwise)
  if __sudoif; then
    binDir="${SETUPMGR_DEFAULT_SYSTEM_BIN_DIR:-/usr/local/bin}"
    binFile="$binDir/$name"
    prefix="sudo"
  else
    binDir="${userBinDir:-${SETUPMGR_DEFAULT_USER_BIN_DIR:-$HOME/.local/bin}}"
    binFile="$binDir/$name"
    prefix=""
  fi

  SETUPMGR_TEMP_APPIMAGE_FILE="$SETUPMGR_TEMP_DIR/${name}.AppImage"

  if [ -n "$PACKAGE_TMP_DIR" ] && [ -e "$PACKAGE_TMP_DIR" ]; then
    __rm "$PACKAGE_TMP_DIR"
  fi

  [ -d "$SETUPMGR_TEMP_DIR" ] || mkdir -p "$SETUPMGR_TEMP_DIR"
  [ -f "$SETUPMGR_TEMP_APPIMAGE_FILE" ] && __rm "$SETUPMGR_TEMP_APPIMAGE_FILE"

  # Create bin directory
  if [ -n "$prefix" ]; then
    $prefix mkdir -p "$binDir" 2>/dev/null || mkdir -p "$binDir"
  else
    mkdir -p "$binDir"
  fi

  # Download AppImage
  if __curl "$url" -o "$SETUPMGR_TEMP_APPIMAGE_FILE"; then
    # Install with appropriate permissions
    if [ -n "$prefix" ]; then
      $prefix mv -f "$SETUPMGR_TEMP_APPIMAGE_FILE" "$binFile" && $prefix chmod +x "$binFile"
    else
      mv -f "$SETUPMGR_TEMP_APPIMAGE_FILE" "$binFile" && chmod +x "$binFile"
    fi
    __rm "$SETUPMGR_TEMP_APPIMAGE_FILE" 2>/dev/null
    [ -x "$binFile" ] || exitCode=1
  else
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
_tar_extract() {
  local tmpFile="$1"
  local exitEXCode=0
  if [ -f "$tmpFile" ]; then
    case "$tmpFile" in
    *.tar) tar xf "$tmpFile" -C "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || exitEXCode=1 ;;
    *.tgz) tar xzf "$tmpFile" -C "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || exitEXCode=1 ;;
    *.tbz2) tar xjf "$tmpFile" -C "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || exitEXCode=1 ;;
    *.tar.gz) tar xzf "$tmpFile" -C "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || exitEXCode=1 ;;
    *.tar.xz) tar xJf "$tmpFile" -C "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || exitEXCode=1 ;;
    *.tar.bz2) tar xjf "$tmpFile" -C "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || exitEXCode=1 ;;
    *) return ;;
    esac
  fi
  __is_dir_empty "$PACKAGE_TMP_DIR" && exitEXCode=1
  return $exitEXCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# tmpFile moveTo moveFrom
__extract() {
  local tmpFile
  local exitCode=0
  local exitEXCode=0
  if [ -f "$1" ]; then
    tmpFile="$1"
    shift 1
  else
    tmpFile="${tmpFile:-$SETUPMGR_TEMP_EXTRACT_FILE}"
  fi
  if mkdir -p "$PACKAGE_TMP_DIR" && builtin cd "$SETUPMGR_TEMP_DIR"; then
    if [ -f "$tmpFile" ]; then
      case "$tmpFile" in
      *.Z) uncompress "$tmpFile" >/dev/null 2>&1 || exitEXCode=1 ;;
      *.zip) [ "$extract_cmd" = "do_not_strip_components" ] && unzip -j "$tmpFile" -d "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || unzip "$tmpFile" -d "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || exitEXCode=1 ;;
      *.tar) [ "$extract_cmd" = "do_not_strip_components" ] && _tar_extract "$tmpFile" || tar xf "$tmpFile" --strip-components=1 -C "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || _tar_extract "$tmpFile" "$PACKAGE_TMP_DIR" || exitEXCode=1 ;;
      *.tgz) [ "$extract_cmd" = "do_not_strip_components" ] && _tar_extract "$tmpFile" || tar xzf "$tmpFile" --strip-components=1 -C "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || _tar_extract "$tmpFile" "$PACKAGE_TMP_DIR" || exitEXCode=1 ;;
      *.tbz2) [ "$extract_cmd" = "do_not_strip_components" ] && _tar_extract "$tmpFile" || tar xjf "$tmpFile" --strip-components=1 -C "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || _tar_extract "$tmpFile" "$PACKAGE_TMP_DIR" || exitEXCode=1 ;;
      *.tar.gz) [ "$extract_cmd" = "do_not_strip_components" ] && _tar_extract "$tmpFile" || tar xzf "$tmpFile" --strip-components=1 -C "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || _tar_extract "$tmpFile" "$PACKAGE_TMP_DIR" || exitEXCode=1 ;;
      *.tar.xz) [ "$extract_cmd" = "do_not_strip_components" ] && _tar_extract "$tmpFile" || tar xJf "$tmpFile" --strip-components=1 -C "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || _tar_extract "$tmpFile" "$PACKAGE_TMP_DIR" || exitEXCode=1 ;;
      *.tar.bz2) [ "$extract_cmd" = "do_not_strip_components" ] && _tar_extract "$tmpFile" || tar xjf "$tmpFile" --strip-components=1 -C "$PACKAGE_TMP_DIR" >/dev/null 2>&1 || _tar_extract "$tmpFile" "$PACKAGE_TMP_DIR" || exitEXCode=1 ;;
      *) printf_red "$tmpFile is not a valid archive file" && exitEXCode=1 ;;
      esac
      if [ $exitEXCode = 0 ]; then
        case "$1" in
        --all)
          shift 1
          for file in "$PACKAGE_TMP_DIR"/*; do
            if [ -x "$file" ]; then
              [ "$SETUPMGR_SYSTEM_INSTALL" = "yes" ] && prefix="sudo" && directory="$SETUPMGR_DEFAULT_BIN_DIR" || directory="$1"
              local filename="$(__basename "$file")"
              printf_purple "Installing $file to $directory/$filename"
              $prefix mv -f "$file" "$directory/$filename"
              retVal=$?
              exitCode=$((retVal + exitCode))
            else
              printf_yellow "$file is not an executable"
              exitCode=$((exitCode++))
            fi
          done
          ;;
        --files)
          shift 1
          if [ -f "$PACKAGE_TMP_DIR/usr/bin/$1" ]; then
            find_extracted="$PACKAGE_TMP_DIR/usr/bin/$1"
          elif [ -f "$PACKAGE_TMP_DIR/bin/$1" ]; then
            find_extracted="$PACKAGE_TMP_DIR/bin/$1"
          elif [ -f "$PACKAGE_TMP_DIR/$1/$1" ]; then
            find_extracted="$PACKAGE_TMP_DIR/$1/$1"
          elif [ -f "$PACKAGE_TMP_DIR/$1" ]; then
            find_extracted="$PACKAGE_TMP_DIR/$1"
          else
            find_extracted="$(find "$PACKAGE_TMP_DIR" -name "$1" -type f 2>/dev/null | grep -E "^$1$|/$1$" | head -n1)"
          fi
          if [ -x "$find_extracted" ]; then
            __move_extracted_file "$find_extracted" "$2" || exitCode=1
          elif [ -d "$1" ]; then
            binDir="$1" && shift 1
            set_files="${*//,/ }"
            for get_files in $set_files; do
              for file in $PACKAGE_TMP_DIR/$get_files; do
                local tmpFilename="$(__basename "$file")"
                __move_extracted_file "$file" "$binDir/$tmpFilename"
              done
            done
            unset tmpFilename
          fi
          ;;
        --install)
          shift 1
          local installDir="$1"
          local installBinD="$2"
          local installBinTo="$3"
          local installBinFrom=""
          local usr_bin_dir="$SYMLINK_FILES_TO"
          local prefix=""
          # Determine if we need sudo for system directories
          if __sudoif && [[ "$installDir" == /usr/* ]] || [[ "$installDir" == /opt/* ]]; then
            prefix="sudo"
          fi
          if [ -n "$installDir" ]; then
            if [ -n "$prefix" ]; then
              $prefix mkdir -p "$installDir" && $prefix rsync -aq "$PACKAGE_TMP_DIR/." "$installDir/" --delete-before && exitEXCode=0 || exitEXCode=3
            else
              mkdir -p "$installDir" && rsync -aq "$PACKAGE_TMP_DIR/." "$installDir/" --delete-before && exitEXCode=0 || exitEXCode=3
            fi
            if [ $exitEXCode -eq 0 ]; then
              if [ -f "$installBinD" ]; then
                installBinFrom="$installBinD"
              elif [ -f "$installDir/$installBinD" ]; then
                installBinFrom="$installDir/$installBinD"
              elif [ -f "$installDir/$installBinD/$installBinD" ]; then
                installBinFrom="$installDir/$installBinD/$installBinD"
              fi
              if [ -n "$installBinFrom" ] && [ -n "$installBinTo" ]; then
                if [ -n "$prefix" ]; then
                  [ -e "$installBinFrom" ] && $prefix chmod +x "$installBinFrom" || exitCode=1
                else
                  [ -e "$installBinFrom" ] && chmod +x "$installBinFrom" || exitCode=1
                fi
                __symlink_installed_files "$installBinFrom" "$installBinTo" "$prefix" || exitCode=1
                if [ ! -f "$installBinTo" ]; then
                  exitCode=2
                  printf_red "Can not find file $installBinTo"
                fi
              fi
              if [ -d "$installDir/bin" ] && [ -n "$usr_bin_dir" ]; then
                for get_files in $installDir/bin/*; do
                  for file in $get_files; do
                    local tmpFilename="$(__basename "$file")"
                    if [ ! -f "$usr_bin_dir/$tmpFilename" ] || [ -L "$usr_bin_dir/$tmpFilename" ]; then
                      __symlink_installed_files "$file" "$usr_bin_dir/$tmpFilename" "$prefix"
                    fi
                  done
                done
              fi
            else
              exitCode=2
              printf_red "Failed to install to $installdir"
            fi
          else
            exitCode=3
            printf_red "installDir in not specified"
          fi
          ;;
        esac
      fi
    else
      exitCode=5
      printf_red "$tmpFile is not a valid file"
    fi
    if [ $exitEXCode -ne 0 ]; then
      printf_red "Failed to extract $tmpFile"
      exitEXCode=1
    fi
  else
    exitEXCode=1
    printf_red "$SETUPMGR_TEMP_DIR"
  fi
  exitEXCode="${exitEXCode:-$exitCode}"
  if [ $exitEXCode -eq 0 ]; then
    if [ -n "$tmpFile" ] && [ -f "$tmpFile" ]; then __rm "$tmpFile"; fi
    if [ -n "$PACKAGE_TMP_DIR" ] && [ -d "$PACKAGE_TMP_DIR" ]; then __rm "$PACKAGE_TMP_DIR"; fi
    if [ -n "$SETUPMGR_TEMP_MOVE_FILE" ] && [ -f "$SETUPMGR_TEMP_MOVE_FILE" ]; then __rm "$SETUPMGR_TEMP_MOVE_FILE"; fi
  fi
  return $exitEXCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# "toFile" "fromFile"
__move_extracted_file() {
  local exitCode=0
  local tempBin="$1"
  local userBin="$2"
  local installFrom=""
  local binFile="$(__basename "${userBin:-$tempBin}")"
  [ "$SETUPMGR_SYSTEM_INSTALL" = "yes" ] && prefix="sudo" && directory="$SETUPMGR_DEFAULT_BIN_DIR" || directory="$(dirname "$userBin")"
  [ -f "$PACKAGE_TMP_DIR/$binFile" ] && tempBin="$PACKAGE_TMP_DIR/$binFile" || tempBin="$(ls "$PACKAGE_TMP_DIR" | grep "$binFile$" || find "$PACKAGE_TMP_DIR" -type f -iname "$binFile" 2>/dev/null)"
  if [ -f "$1" ]; then
    installFrom="$1"
  elif [ -f "$PACKAGE_TMP_DIR/$binFile" ]; then
    installFrom="$PACKAGE_TMP_DIR/$binFile"
  elif [ -n "$tempBin" ] && [ -f "$tempBin" ]; then
    installFrom="$tempBin"
  else
    return 1
  fi
  printf_cyan "Installing ${installFrom//$HOME/\~} to $directory"
  $prefix mv -f "$installFrom" "$directory/$binFile" && chmod +x "$directory/$binFile" || exitEXCode=2
  [ -x "$directory/$binFile" ] || return $exitEXCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# "installDir/name" "~/.local/bin/name"
__symlink_installed_files() {
  local BinFrmFile="$1"
  local installBin="$2"
  local prefix="$3"
  if [ -n "$BinFrmFile" ] && [ -n "$installBin" ]; then
    if [ -f "$BinFrmFile" ]; then
      if [ -n "$prefix" ]; then
        $prefix chmod +x "$BinFrmFile"
        $prefix ln -sf "$BinFrmFile" "$installBin"
      else
        chmod +x "$BinFrmFile"
        ln -sf "$BinFrmFile" "$installBin"
      fi
    elif [ -f "$installDir/bin/$BinFrmFile" ]; then
      if [ -n "$prefix" ]; then
        $prefix chmod +x "$installDir/bin/$BinFrmFile"
        $prefix ln -sf "$installDir/bin/$BinFrmFile" "$installBin"
      else
        chmod +x "$installDir/bin/$BinFrmFile"
        ln -sf "$installDir/bin/$BinFrmFile" "$installBin"
      fi
    elif [ -f "$installDir/$BinFrmFile" ]; then
      if [ -n "$prefix" ]; then
        $prefix chmod +x "$installDir/$BinFrmFile"
        $prefix ln -sf "$installDir/$BinFrmFile" "$installBin"
      else
        chmod +x "$installDir/$BinFrmFile"
        ln -sf "$installDir/$BinFrmFile" "$installBin"
      fi
    else
      exitCode=1
    fi
  else
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Unified Installation System
# - - - - - - - - - - - - - - - - - - - - - - - - -
__get_system_arch() {
  local arch="$(uname -m)"
  case "$arch" in
  x86_64) echo "amd64" ;;
  aarch64 | arm64) echo "arm64" ;;
  armv7l) echo "arm" ;;
  armv6l) echo "armv6" ;;
  *) echo "$arch" ;;
  esac
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__get_system_os() {
  local os="$(uname -s | tr '[:upper:]' '[:lower:]')"
  case "$os" in
  linux*) echo "linux" ;;
  darwin*) echo "darwin" ;;
  freebsd*) echo "freebsd" ;;
  openbsd*) echo "openbsd" ;;
  netbsd*) echo "netbsd" ;;
  dragonfly*) echo "dragonfly" ;;
  sunos* | solaris*) echo "solaris" ;;
  *) echo "$os" ;;
  esac
}
# - - - - - - - - - - - - - - - - - - - - - - - - - -
__validate_binary_arch() {
  local binary_path="$1"
  local expected_arch="$2" # amd64, arm64, arm, armv6

  # Check if file exists and is executable
  if [ ! -f "$binary_path" ]; then
    return 1
  fi

  # Get binary architecture using file command
  local file_output="$(file "$binary_path" 2>/dev/null)"

  # Validate architecture matches
  case "$expected_arch" in
  amd64)
    echo "$file_output" | grep -qE "(x86-64|x86_64|amd64)" && return 0
    ;;
  arm64)
    echo "$file_output" | grep -qE "(aarch64|ARM aarch64)" && return 0
    ;;
  arm)
    echo "$file_output" | grep -qE "(ARM|armv7)" && ! echo "$file_output" | grep -qE "(aarch64|arm64)" && return 0
    ;;
  armv6)
    echo "$file_output" | grep -qE "armv6" && return 0
    ;;
  esac

  # Architecture mismatch
  printf_red "Architecture mismatch detected!"
  printf_red "Expected: $expected_arch"
  printf_red "Got: $file_output"
  return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - -
__get_version() {
  local name="$1"
  local version=""
  local raw_output=""

  # Return empty if command doesn't exist
  if ! command -v "$name" &>/dev/null; then
    return 1
  fi

  # Try common version flags and extract ONLY version number
  # Pattern matches: 1.2.3, 1.2, v1.2.3, 1.2.3-beta, 1.2.3-rc1, etc.
  raw_output="$($name --version 2>/dev/null)" && [ -n "$raw_output" ] && version="$(echo "$raw_output" | grep -oE '(v?[0-9]+\.){1,}[0-9]+([.-][a-zA-Z0-9]+)?' | head -n1)" && [ -n "$version" ] && echo "$version" && return 0
  raw_output="$($name -version 2>/dev/null)" && [ -n "$raw_output" ] && version="$(echo "$raw_output" | grep -oE '(v?[0-9]+\.){1,}[0-9]+([.-][a-zA-Z0-9]+)?' | head -n1)" && [ -n "$version" ] && echo "$version" && return 0
  raw_output="$($name -v 2>/dev/null)" && [ -n "$raw_output" ] && version="$(echo "$raw_output" | grep -oE '(v?[0-9]+\.){1,}[0-9]+([.-][a-zA-Z0-9]+)?' | head -n1)" && [ -n "$version" ] && echo "$version" && return 0
  raw_output="$($name -V 2>/dev/null)" && [ -n "$raw_output" ] && version="$(echo "$raw_output" | grep -oE '(v?[0-9]+\.){1,}[0-9]+([.-][a-zA-Z0-9]+)?' | head -n1)" && [ -n "$version" ] && echo "$version" && return 0
  raw_output="$($name version 2>/dev/null)" && [ -n "$raw_output" ] && version="$(echo "$raw_output" | grep -oE '(v?[0-9]+\.){1,}[0-9]+([.-][a-zA-Z0-9]+)?' | head -n1)" && [ -n "$version" ] && echo "$version" && return 0

  # Some tools output version to stderr or need help flag
  raw_output="$($name --help 2>&1 | grep -i version)" && [ -n "$raw_output" ] && version="$(echo "$raw_output" | grep -oE '(v?[0-9]+\.){1,}[0-9]+([.-][a-zA-Z0-9]+)?' | head -n1)" && [ -n "$version" ] && echo "$version" && return 0
  raw_output="$($name -h 2>&1 | grep -i version)" && [ -n "$raw_output" ] && version="$(echo "$raw_output" | grep -oE '(v?[0-9]+\.){1,}[0-9]+([.-][a-zA-Z0-9]+)?' | head -n1)" && [ -n "$version" ] && echo "$version" && return 0

  # If all else fails, return empty (no error)
  return 1
}

__get_release_api_url() {
  local repo="$1"               # format: owner/repo or full URL
  local platform="${2:-github}" # github, gitlab, gitea, gitea.com, codeberg, sourcehut, bitbucket
  local custom_host="$3"        # Optional: custom host for self-hosted instances

  # If already a full URL, return it
  if [[ "$repo" =~ ^https?:// ]]; then
    echo "$repo"
    return 0
  fi

  case "$platform" in
  github)
    # Always use /releases/latest endpoint for latest release
    echo "https://api.github.com/repos/${repo}/releases/latest"
    ;;
  gitlab)
    # GitLab API returns releases sorted by created date, get first one
    if [ -n "$custom_host" ]; then
      echo "https://${custom_host}/api/v4/projects/$(echo "$repo" | sed 's/\//%2F/g')/releases"
    else
      echo "https://gitlab.com/api/v4/projects/$(echo "$repo" | sed 's/\//%2F/g')/releases"
    fi
    ;;
  gitea | gitea.com)
    # Gitea has /releases/latest endpoint
    if [ -n "$custom_host" ]; then
      echo "https://${custom_host}/api/v1/repos/${repo}/releases/latest"
    else
      echo "https://gitea.com/api/v1/repos/${repo}/releases/latest"
    fi
    ;;
  codeberg)
    # Codeberg uses Gitea, has /releases/latest endpoint
    echo "https://codeberg.org/api/v1/repos/${repo}/releases/latest"
    ;;
  sourcehut | sr.ht)
    # sourcehut uses refs API, get latest tag
    echo "https://git.sr.ht/~${repo}/refs"
    ;;
  bitbucket)
    # Bitbucket uses downloads, sorted by date
    echo "https://api.bitbucket.org/2.0/repositories/${repo}/downloads"
    ;;
  *)
    # Default to GitHub
    echo "https://api.github.com/repos/${repo}/releases/latest"
    ;;
  esac
}

__find_release_asset() {
  local api_url="$1"
  local pattern="$2" # Pattern to match in asset name
  local platform="${3:-github}"

  case "$platform" in
  github)
    # GitHub: Use /releases/latest endpoint - always gets latest
    __curl "$api_url" | grep '"browser_download_url"' | cut -d '"' -f 4 | grep -iE "$pattern" | head -n1
    ;;
  gitlab)
    # GitLab: Get first release (latest by date), then find matching asset
    __curl "$api_url" | jq -r '.[0].assets.links[] | select(.name | test("'"$pattern"'"; "i")) | .direct_asset_url' 2>/dev/null | head -n1
    ;;
  gitea | gitea.com | codeberg)
    # Gitea/Codeberg: Use /releases/latest endpoint - always gets latest
    __curl "$api_url" | jq -r '.assets[] | select(.name | test("'"$pattern"'"; "i")) | .browser_download_url' 2>/dev/null | head -n1
    ;;
  sourcehut | sr.ht)
    # sourcehut: Get latest tag, construct download URL
    # Note: sourcehut doesn't have a releases API, uses git refs
    local latest_tag="$(__curl "$api_url" | jq -r '.results[0].name' 2>/dev/null)"
    if [ -n "$latest_tag" ]; then
      # Construct download URL based on repo and tag
      local repo_path="$(echo "$api_url" | sed 's|https://git.sr.ht/~||g' | sed 's|/refs||g')"
      echo "https://git.sr.ht/~${repo_path}/archive/${latest_tag}.tar.gz"
    fi
    ;;
  bitbucket)
    # Bitbucket: Downloads are sorted by date, get first matching
    __curl "$api_url" | jq -r '.values[] | select(.name | test("'"$pattern"'"; "i")) | .links.self.href' 2>/dev/null | head -n1
    ;;
  esac
}

__build_asset_pattern() {
  local arch="$1"  # amd64, arm64, arm, armv6
  local os="${2}"  # linux, darwin, freebsd, etc. (auto-detect if empty)
  local ext="${3}" # Optional: tar.gz, zip, etc.

  # Auto-detect OS if not provided
  if [ -z "$os" ]; then
    os="$(__get_system_os)"
  fi

  # Architecture variations - using word boundaries to be precise
  local patterns=""
  case "$arch" in
  amd64)
    # Match: x86_64, amd64, x64 (but not arm64, aarch64)
    patterns="(x86_64|amd64|x64)"
    ;;
  arm64)
    # Match: aarch64, arm64 (but not arm, armv7, armv6)
    patterns="(aarch64|arm64)"
    ;;
  arm)
    # Match: armv7, armhf (but not arm64, armv6)
    patterns="(armv7l?|armhf)"
    ;;
  armv6)
    # Match: armv6, armv6l, armv6hf
    patterns="(armv6l?|armv6hf)"
    ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  # OS pattern variations (handle different naming conventions)
  local os_patterns=""
  case "$os" in
  darwin)
    # macOS: darwin, macos, osx, apple-darwin
    os_patterns="(darwin|macos|osx|apple-darwin)"
    ;;
  linux)
    # Linux: linux, gnu (but not android)
    os_patterns="(linux|gnu)"
    ;;
  freebsd)
    os_patterns="(freebsd)"
    ;;
  openbsd)
    os_patterns="(openbsd)"
    ;;
  netbsd)
    os_patterns="(netbsd)"
    ;;
  dragonfly)
    os_patterns="(dragonfly)"
    ;;
  solaris)
    os_patterns="(solaris|sunos)"
    ;;
  *)
    os_patterns="$os"
    ;;
  esac

  # Build full pattern with proper boundaries
  if [ -n "$ext" ]; then
    echo "${os_patterns}[._-]${patterns}.*\.${ext}"
  else
    echo "${os_patterns}[._-]${patterns}"
  fi
}

__install_from_binary() {
  local name="$1"               # Binary name (e.g., "shfmt")
  local repo="$2"               # Repo (e.g., "mvdan/sh" or full URL)
  local bin_dir="$3"            # Installation directory
  local pattern="$4"            # Optional: custom asset pattern
  local platform="${5:-github}" # github, gitlab, gitea, codeberg, sourcehut, bitbucket
  local custom_host="$6"        # Optional: custom host for self-hosted instances

  local exitCode=0
  local arch="$(__get_system_arch)"
  local os="$(__get_system_os)"
  local binFile="$bin_dir/$name"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$bin_dir" ] || mkdir -p "$bin_dir"

  # Get release API URL - always targets latest release
  local api_url="$(__get_release_api_url "$repo" "$platform" "$custom_host")"

  # Build or use provided pattern
  if [ -z "$pattern" ]; then
    pattern="$(__build_asset_pattern "$arch" "$os")"
  fi

  # Find download URL from latest release
  local download_url="$(__find_release_asset "$api_url" "$pattern" "$platform")"

  if [ -z "$download_url" ]; then
    printf_red "Could not find latest release asset for $os/$arch ($(uname -s)/$(uname -m))"
    printf_red "Pattern used: $pattern"
    printf_red "Check if $name supports your platform at: $repo"
    return 1
  fi

  # Show status
  if __cmd_exists "$name"; then
    printf_green "Updating $name to latest release"
  else
    printf_green "Installing $name (latest release)"
  fi

  # Download and install
  if __download_and_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    # Validate binary architecture BEFORE installing to system
    if ! __validate_binary_arch "$binFile" "$arch"; then
      printf_red "Downloaded binary is not compatible with system architecture"
      printf_red "System: $(uname -m) ($arch)"
      printf_red "Binary: $(file "$binFile")"
      __rm "$binFile"
      return 1
    fi

    __install_to_system_bin "$binFile"

    # Try to get version (gracefully fails if not supported)
    local version="$(__get_version "$name")"
    if [ -n "$version" ]; then
      printf_green "$name has been installed: $version"
    else
      printf_green "$name has been installed"
    fi
  else
    exitCode=1
    printf_red "Failed to install $name"
  fi

  return $exitCode
}

__install_from_archive() {
  local name="$1"               # Binary name to extract
  local repo="$2"               # Repo (e.g., "koalaman/shellcheck")
  local bin_dir="$3"            # Installation directory
  local pattern="$4"            # Optional: custom asset pattern
  local platform="${5:-github}" # github, gitlab, gitea, codeberg, sourcehut, bitbucket
  local extract_path="${6}"     # Optional: path within archive (e.g., "bin/shellcheck")
  local custom_host="$7"        # Optional: custom host for self-hosted instances

  local exitCode=0
  local arch="$(__get_system_arch)"
  local os="$(__get_system_os)"
  local binFile="$bin_dir/$name"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$bin_dir" ] || mkdir -p "$bin_dir"

  # Get release API URL - always targets latest release
  local api_url="$(__get_release_api_url "$repo" "$platform" "$custom_host")"

  # Build or use provided pattern
  if [ -z "$pattern" ]; then
    # Try common archive extensions
    pattern="$(__build_asset_pattern "$arch" "$os" "(tar\\.gz|tar\\.xz|tgz|zip)")"
  fi

  # Find download URL from latest release
  local download_url="$(__find_release_asset "$api_url" "$pattern" "$platform")"

  if [ -z "$download_url" ]; then
    printf_red "Could not find latest release asset for $os/$arch ($(uname -s)/$(uname -m))"
    printf_red "Pattern used: $pattern"
    printf_red "Check if $name supports your platform at: $repo"
    return 1
  fi

  # Show status
  if __cmd_exists "$name"; then
    printf_green "Updating $name to latest release"
  else
    printf_green "Installing $name (latest release)"
  fi

  # Download, extract, and install
  local extract_name="${extract_path:-$name}"
  if __download_extract_move "$download_url" "$extract_name" "$binFile" && __is_installed "$name" "$binFile"; then
    # Validate binary architecture BEFORE installing to system
    if ! __validate_binary_arch "$binFile" "$arch"; then
      printf_red "Extracted binary is not compatible with system architecture"
      printf_red "System: $(uname -m) ($arch)"
      printf_red "Binary: $(file "$binFile")"
      __rm "$binFile"
      return 1
    fi

    __install_to_system_bin "$binFile"

    # Try to get version (gracefully fails if not supported)
    local version="$(__get_version "$name")"
    if [ -n "$version" ]; then
      printf_green "$name has been installed to $binFile: $version"
    else
      printf_green "$name has been installed to $binFile"
    fi
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi

  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__is_package_installed() {
  local name="$1"
  local bin_var="$(echo "${name^^}_BIN_DIR" | tr '-' '_')"
  local bin_dir="${!bin_var}"

  # Check common installation locations
  [ -n "$bin_dir" ] && [ -f "$bin_dir/$name" ] && return 0
  [ -f "$SETUPMGR_DEFAULT_BIN_DIR/$name" ] && return 0
  [ -f "/usr/local/bin/$name" ] && return 0
  command -v "$name" &>/dev/null && return 0

  return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - -
__remove_file() {
  local file_path="$1"
  local name="$(basename "$file_path")"
  local location="$(dirname "$file_path")"

  if [ -f "$file_path" ]; then
    if [[ "$file_path" == /usr/local/* ]] || [[ "$file_path" == /usr/* ]]; then
      __sudo rm -f "$file_path" && printf_green "Removed $name from $location"
    else
      __rm "$file_path" && printf_green "Removed $name from $location"
    fi
    return 0
  fi
  return 1
}
# - - - - - - - - - - - - - - - - - - - - - - - - - -
__remove_package() {
  local name="$1"
  local exitCode=0

  # Check if package is installed before showing message
  if ! __is_package_installed "$name"; then
    printf_yellow "Package $name not found or not installed via setupmgr"
    return 1
  fi

  printf_cyan "Removing $name"

  case "$name" in
  asdf)
    [ -d "$ASDF_DIR" ] && __rm "$ASDF_DIR" && printf_green "Removed $name from $ASDF_DIR"
    ;;
  deno)
    __remove_file "$SETUPMGR_DEFAULT_BIN_DIR/$name"
    __remove_file "/usr/local/bin/$name"
    ;;
  bun)
    __remove_file "$SETUPMGR_DEFAULT_BIN_DIR/$name"
    __remove_file "/usr/local/bin/$name"
    ;;
  distrobox)
    [ -d "$DISTROBOX_HOME" ] && __rm "$DISTROBOX_HOME" && printf_green "Removed $name"
    for bin in distrobox*; do
      [ -f "$SETUPMGR_DEFAULT_BIN_DIR/$bin" ] && __rm "$SETUPMGR_DEFAULT_BIN_DIR/$bin"
    done
    ;;
  dotnet)
    [ -d "$DOTNET_ROOT" ] && __rm "$DOTNET_ROOT" && printf_green "Removed $name from $DOTNET_ROOT"
    [ -f "$SETUPMGR_DEFAULT_BIN_DIR/$name" ] && __rm "$SETUPMGR_DEFAULT_BIN_DIR/$name"
    ;;
  fnm)
    [ -d "$FNM_DIR" ] && __rm "$FNM_DIR" && printf_green "Removed $name from $FNM_DIR"
    [ -f "$HOME/.local/bin/$name" ] && __rm "$HOME/.local/bin/$name"
    ;;
  nvm)
    [ -d "$NVM_DIR" ] && __rm "$NVM_DIR" && printf_green "Removed $name from $NVM_DIR"
    ;;
  gvm)
    [ -d "$GVM_ROOT" ] && __rm "$GVM_ROOT" && printf_green "Removed $name from $GVM_ROOT"
    for bin in "$SETUPMGR_DEFAULT_BIN_DIR"/*; do
      [ -f "$bin" ] && __rm "$bin"
    done
    ;;
  rbenv)
    [ -d "$RBENV_ROOT" ] && __rm "$RBENV_ROOT" && printf_green "Removed $name from $RBENV_ROOT"
    for bin in "$SETUPMGR_DEFAULT_BIN_DIR"/*; do
      [ -f "$bin" ] && __rm "$bin"
    done
    ;;
  rvm)
    [ -d "$rvm_path" ] && __rm "$rvm_path" && printf_green "Removed $name from $rvm_path"
    [ -f "$SETUPMGR_DEFAULT_BIN_DIR/rvm" ] && __rm "$SETUPMGR_DEFAULT_BIN_DIR/rvm"
    ;;
  ripgrep)
    __remove_file "$SETUPMGR_DEFAULT_BIN_DIR/$name"
    __remove_file "/usr/local/bin/rg"
    ;;
  bat | fd | delta | dust | exa | procs | starship | glow | just | zoxide | tokei | jless)
    local bin_var="$(echo "${name^^}_BIN_DIR" | tr '-' '_')"
    local bin_dir="${!bin_var}"
    __remove_file "$bin_dir/$name"
    __remove_file "/usr/local/bin/$name"
    ;;
  vagrant)
    __remove_file "$SETUPMGR_DEFAULT_BIN_DIR/$name"
    __remove_file "/usr/local/bin/$name"
    ;;
  minikube)
    __cmd_exists minikube && minikube stop &>/dev/null && minikube delete &>/dev/null
    __remove_file "$SETUPMGR_DEFAULT_BIN_DIR/$name"
    __remove_file "/usr/local/bin/$name"
    [ -d "$MINIKUBE_HOME" ] && __rm "$MINIKUBE_HOME" && printf_green "Removed minikube data"
    ;;
  *)
    # Generic removal for most packages - try common locations
    local bin_var="$(echo "${name^^}_BIN_DIR" | tr '-' '_')"
    local bin_dir="${!bin_var}"
    [ -n "$bin_dir" ] && __remove_file "$bin_dir/$name"
    __remove_file "$SETUPMGR_DEFAULT_BIN_DIR/$name"
    __remove_file "/usr/local/bin/$name"
    ;;
  esac

  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_ripgrep() {
  local exitCode=0
  local name="rg"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/BurntSushi/ripgrep/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/BurntSushi/ripgrep/releases/download/${version}/ripgrep-${version}-x86_64-unknown-linux-musl.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/BurntSushi/ripgrep/releases/download/${version}/ripgrep-${version}-aarch64-unknown-linux-gnu.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_ruff() {
  local exitCode=0
  local name="ruff"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/astral-sh/ruff/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/astral-sh/ruff/releases/download/${version}/ruff-x86_64-unknown-linux-gnu.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/astral-sh/ruff/releases/download/${version}/ruff-aarch64-unknown-linux-gnu.tar.gz" ;;
  armv7l | arm) download_url="https://github.com/astral-sh/ruff/releases/download/${version}/ruff-armv7-unknown-linux-gnueabihf.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_fd() {
  local exitCode=0
  local name="fd"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/sharkdp/fd/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/sharkdp/fd/releases/download/${version}/fd-${version}-x86_64-unknown-linux-musl.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/sharkdp/fd/releases/download/${version}/fd-${version}-aarch64-unknown-linux-gnu.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_bat() {
  local exitCode=0
  local name="bat"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/sharkdp/bat/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/sharkdp/bat/releases/download/${version}/bat-${version}-x86_64-unknown-linux-musl.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/sharkdp/bat/releases/download/${version}/bat-${version}-aarch64-unknown-linux-gnu.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_delta() {
  local exitCode=0
  local name="delta"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/dandavison/delta/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/dandavison/delta/releases/download/${version}/delta-${version}-x86_64-unknown-linux-musl.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/dandavison/delta/releases/download/${version}/delta-${version}-aarch64-unknown-linux-gnu.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_exa() {
  local exitCode=0
  local name="exa"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/ogham/exa/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/ogham/exa/releases/download/${version}/exa-linux-x86_64-${version}.zip" ;;
  *)
    printf_red "Unsupported architecture: $arch (only x86_64 supported)"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_dust() {
  local exitCode=0
  local name="dust"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/bootandy/dust/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/bootandy/dust/releases/download/${version}/dust-${version}-x86_64-unknown-linux-musl.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/bootandy/dust/releases/download/${version}/dust-${version}-aarch64-unknown-linux-gnu.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_procs() {
  local exitCode=0
  local name="procs"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/dalance/procs/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/dalance/procs/releases/download/${version}/procs-${version}-x86_64-linux.zip" ;;
  aarch64 | arm64) download_url="https://github.com/dalance/procs/releases/download/${version}/procs-${version}-aarch64-linux.zip" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_starship() {
  local exitCode=0
  local name="starship"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/starship/starship/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/starship/starship/releases/download/${version}/starship-x86_64-unknown-linux-musl.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/starship/starship/releases/download/${version}/starship-aarch64-unknown-linux-gnu.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_glow() {
  local exitCode=0
  local name="glow"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/charmbracelet/glow/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/charmbracelet/glow/releases/download/${version}/glow_Linux_x86_64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/charmbracelet/glow/releases/download/${version}/glow_Linux_arm64.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_just() {
  local exitCode=0
  local name="just"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/casey/just/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/casey/just/releases/download/${version}/just-${version}-x86_64-unknown-linux-musl.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/casey/just/releases/download/${version}/just-${version}-aarch64-unknown-linux-musl.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_zoxide() {
  local exitCode=0
  local name="zoxide"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/ajeetdsouza/zoxide/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/ajeetdsouza/zoxide/releases/download/${version}/zoxide-${version}-x86_64-unknown-linux-musl.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/ajeetdsouza/zoxide/releases/download/${version}/zoxide-${version}-aarch64-unknown-linux-musl.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_zellij() {
  local exitCode=0
  local name="zellij"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/zellij-org/zellij/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/zellij-org/zellij/releases/download/${version}/zellij-x86_64-unknown-linux-musl.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/zellij-org/zellij/releases/download/${version}/zellij-aarch64-unknown-linux-musl.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_zig() {
  local exitCode=0
  local name="zig"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local installDir="$SETUPMGR_DEFAULT_SHARE_DIR/$name"
  local version="${ZIG_VERSION:-master}"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  case $arch in
  x86_64) download_url="https://ziglang.org/builds/zig-linux-x86_64-${version}.tar.xz" ;;
  aarch64 | arm64) download_url="https://ziglang.org/builds/zig-linux-aarch64-${version}.tar.xz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if __download_extract_install "$download_url" "$installDir" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
    printf_cyan "Set ZIG_VERSION environment variable to install a specific version"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_rustup() {
  local exitCode=0
  local name="rustup"

  if __cmd_exists $name && [ "$SETUPMGR_FORCE_INSTALL" != "true" ]; then
    printf_green "$name is already installed"
    return 0
  fi

  printf_green "Installing $name and Rust toolchain"

  if curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y |& __output_status; then
    printf_green "$name has been installed"
    printf_cyan "Run 'source \$HOME/.cargo/env' to add Rust to your PATH"
    printf_cyan "Or restart your shell"
  else
    exitCode=1
    printf_red "Failed to install $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_tokei() {
  local exitCode=0
  local name="tokei"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/XAMPPRocky/tokei/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/XAMPPRocky/tokei/releases/download/${version}/tokei-x86_64-unknown-linux-musl.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/XAMPPRocky/tokei/releases/download/${version}/tokei-aarch64-unknown-linux-musl.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_jless() {
  local exitCode=0
  local name="jless"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/PaulJuliusMartinez/jless/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/PaulJuliusMartinez/jless/releases/download/${version}/jless-${version}-x86_64-unknown-linux-gnu.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/PaulJuliusMartinez/jless/releases/download/${version}/jless-${version}-aarch64-unknown-linux-gnu.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_lua() {
  printf_red "This doesn't seem to be working" && return
  local exitCode=0
  local GITREPO="${LUAVER_GIT_REPO:-https://github.com/DhavalKapil/luaver}"
  local LUAVER_HOME="${LUAVER_HOME:-$HOME/.local/share/lua/plugins/luaver}"
  local LUAROCKS_BIN="${LUAROCKS_BIN:-$HOME/.local/share/lua/luarocks/bin}"
  local jversion="${LUA_JIT_VERSION:-2.0.5}"
  local version="${LUA_DEFAULT_VERSION:-5.4.3}"
  local rversion="${LUA_ROCKS_DEFAULT_VERSION:-3.8.0}"
  local logFile="$SETUPMGR_LOG_DIR/lua.log"
  local luaver_bin_file="$SETUPMGR_DEFAULT_BIN_DIR/luaver"
  export LUAVER_HOME LUAROCKS_BIN PATH="$LUAROCKS_BIN:$PATH"
  [ -d "$LUAVER_HOME/.git" ] || __rm "$LUAVER_HOME" &>/dev/null
  if [ -d "$LUAVER_HOME/.git" ]; then
    printf_cyan "Updating luaver from $GITREPO"
    if __git_update_repo "$LUAVER_HOME"; then
      printf_blue "Updated luaver in $LUAVER_HOME"
    else
      exitCode=1
      printf_red "Failed to update $LUAVER_HOME" >&2
    fi
  else
    printf_green "Downloading luaver from $GITREPO"
    if __git_clone_repo "$GITREPO" "$LUAVER_HOME"; then
      printf_blue "Downloaded luaver to $LUAVER_HOME"
      chmod 755 "$LUAVER_HOME/luaver"
    else
      exitCode=1
      printf_red "Failed to download the repo" >&2
    fi
  fi
  if [ ! -f "$luaver_bin_file" ] && [ -f "$LUAVER_HOME/luaver" ] && [ "$luaver_bin_file" != "$LUAVER_HOME/luaver" ]; then
    local prefix=""
    if __sudoif && [[ "$luaver_bin_file" == /usr/* ]] || [[ "$luaver_bin_file" == /opt/* ]]; then
      prefix="sudo"
    fi
    __symlink_installed_files "$LUAVER_HOME/luaver" "$luaver_bin_file" "$prefix"
  fi
  if type luaver &>/dev/null; then
    printf_green "Installing lua version: $version"
    if yes | luaver install "$version" >>"$logFile" 2>>"$logFile.err"; then
      luaver use "$version" >>"$logFile" 2>>"$logFile.err" &&
        yes | luaver install-luarocks "$rversion" >>"$logFile" 2>>"$logFile.err" &&
        luaver install-luajit "$jversion" >>"$logFile" 2>>"$logFile.err" &&
        luaver set-default "$version" >>"$logFile" 2>>"$logFile.err" &&
        luaver set-default-luajit "$jversion" 2>>"$logFile.err" &&
        luaver set-default-luarocks "$rversion" 2>>"$logFile.err"
    else
      error="true"
    fi
    get_ver="$(luaver current | grep 'lua' | grep '^')"
    get_rver="$(luaver set-default-luarocks 3.8.0 2>&1 | tr ' ' '\n' | grep '[0-9].[0-9]' | grep '^')"
    if [ -n "$get_ver" ] && [ -n "$get_rver" ] && [ -z "$error" ]; then
      printf_green "Finished installing lua! $get_ver"
      [ -f "$logFile" ] && __rm "$logFile"
      [ -f "$logFile.err" ] && __rm "$logFile.err"
    else
      printf_exit "Installation of lua has failed: log saved to $logFile.err" >&2
      exitCode=1
    fi
  else
    printf_red "Failed to setup luaver"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_asdf() {
  local exitCode=0
  local err_mess=""
  export ASDF_DIR="${ASDF_DIR:-}"
  export ASDF_DATA_DIR="$ASDF_DIR"
  local GITREPO="${ASDF_GITREPO:-}"
  if [ -d "$ASDF_DIR/.git" ]; then
    printf_cyan "Updating asdf from $GITREPO"
    if __git_update_repo "$ASDF_DIR"; then
      printf_blue "Updated asdf in $ASDF_DIR"
    else
      printf_exit "Failed to update $ASDF_DIR" >&2
    fi
  else
    printf_green "Downloading asdf from $GITREPO"
    if __git_clone_repo "$GITREPO" "$ASDF_DIR"; then
      printf_blue "Downloaded asdf to $ASDF_DIR"
    else
      printf_exit "Failed to download the repo" >&2
    fi
  fi
  [ -f "$ASDF_DIR/asdf.sh" ] && . "$ASDF_DIR/asdf.sh"
  if type asdf &>/dev/null; then
    chmod 755 "$ASDF_DIR/asdf.sh"
    if [ -f "$ASDF_DIR/bin/asdf" ]; then
      chmod 755 "$ASDF_DIR/bin/asdf"
    fi
    printf_green "asdf has been installed"
  else
    exitCode=1
    printf_red "$err_mess"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_atuin() {
  local exitCode=0
  local name="atuin"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/atuinsh/atuin/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/atuinsh/atuin/releases/download/${version}/atuin-x86_64-unknown-linux-gnu.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/atuinsh/atuin/releases/download/${version}/atuin-aarch64-unknown-linux-gnu.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
    printf_cyan "Run 'atuin import auto' to import shell history"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_deno() {
  local exitCode=0
  local version=""
  local name="deno"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  local release_url="https://github.com/denoland/deno/releases/latest/download"
  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"
  if [ "$arch" = "x86_64" ]; then
    deno_uri="$release_url/deno-x86_64-unknown-linux-gnu.zip"
  elif [ "$arch" = "aarch64" ]; then
    deno_uri="$release_url/deno-aarch64-unknown-linux-gnu.zip"
  else
    printf_exit "Only x86_64 and ARM64 architecture is supported"
  fi
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  if __download_extract_move "$deno_uri" "$name" "$binFile"; then
    __install_to_system_bin "$binFile"
    version=$(eval $name --version 2>/dev/null | head -n1 | sed 's|deno ||g;s| .*||g' | grep '[0-9]')
  fi
  if [ -n "$version" ] && [ -n "$(type -P $name 2>/dev/null)" ]; then
    if $name --help 2>&1 | grep -q 'execute binary file'; then
      printf_red "Unsupported architecture detected"
      __rm "$binFile"
      exitCode=1
    else
      printf_green "$name $version has been installed"
    fi
  else
    exitCode=1
    printf_red "Failed to install $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_bun() {
  local exitCode=0
  local name="bun"
  local version=""
  local arch="$(uname -m)"
  local binDir="$SETUPMGR_DEFAULT_BIN_DIR"
  local binFile="$binDir/$name"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  local release_url="https://github.com/oven-sh/bun/releases/latest/download"
  [ -d "$binDir" ] || mkdir -p "$binDir"
  if [ "$arch" = "x86_64" ]; then
    tempBin="bun-linux-x64"
    bun_url="$release_url/bun-linux-x64.zip"
  elif [ "$arch" = "aarch64" ]; then
    tempBin="bun-linux-aarch64"
    bun_url="$release_url/bun-linux-aarch64.zip"
  else
    printf_exit "Only x86_64 and ARM64 architecture is supported"
  fi
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  if __download_extract_move "$bun_url" "$name" "$binFile"; then
    __install_to_system_bin "$binFile"
    version=$(eval $name --version 2>/dev/null | head -n1 | sed 's|bun ||g;s| .*||g' | grep '[0-9]')
  else
    printf_exit "Failed to download $bun_url"
  fi
  if [ -n "$version" ] && [ -n "$(type -P $name 2>/dev/null)" ]; then
    if $name --help 2>&1 | grep -q 'execute binary file'; then
      printf_red "Unsupported architecture detected"
      __rm "$binFile"
      exitCode=1
    else
      printf_green "$name $version has been installed"
    fi
  else
    printf_red "Failed to install $name"
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_distrobox() {
  local bin name
  local exitCode=0
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  DBX_HOME="${DBX_HOME:-$HOME/.local/share/distrobox}"
  printf_green "Installing distrobox"
  if __download_and_execute "$DISTROBOX_SCRIPT_URL" --next --prefix "$DISTROBOX_HOME" |& __output_status; then
    if [ -f "$DISTROBOX_HOME/bin/distrobox-init" ]; then
      for bin in "$DISTROBOX_HOME/bin"/*; do
        name="$(basename -- "$bin")"
        if [ ! -f "$SETUPMGR_DEFAULT_BIN_DIR/$name" ]; then
          ln -sf "$bin" "$SETUPMGR_DEFAULT_BIN_DIR/$name"
        fi
      done
      printf_green "Distrobox has been installed"
    else
      exitCode=1
      printf_red "Failed to install distrobox"
    fi
    __rm "$SETUPMGR_TEMP_DIR/distrobox" "$DISTROBOX_LOG_DIR/error.log"
  else
    exitCode=1
    printf_red "Failed to download distrobox"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_dotnet() {
  local exitCode=0
  local name="dotnet"
  local binDir="$SETUPMGR_DEFAULT_BIN_DIR"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  if __curl "$DOTNET_SCRIPT_URL" | bash -s -- --install-dir "$DOTNET_ROOT" |& __output_status; then
    [ -d "$HOME/.dotnet" ] && mv -f "$HOME/.dotnet" "$DOTNET_ROOT"
    [ -f "$DOTNET_ROOT/$name" ] && ln -sf "$DOTNET_ROOT/$name" "$SETUPMGR_DEFAULT_BIN_DIR/$name"
  fi
  if __cmd_exists $name && __is_installed "$name" "$DOTNET_ROOT"; then
    printf_green "$name has been installed to $DOTNET_ROOT"
  else
    printf_red "Failed to install $name"
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_vfox() {
  local exitCode=0
  local name="vfox"
  local arch=$(uname -m)
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  local release_url="https://github.com/version-fox/vfox/releases/download"
  local VERSION=$(curl --silent "https://api.github.com/repos/version-fox/vfox/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/' | cut -c 2-)
  case "$arch" in
  x86_64) url="$release_url/v$VERSION/vfox_${VERSION}_linux_x86_64.tar.gz" ;;
  aarch64 | arm64) url="$release_url/v$VERSION/vfox_${VERSION}_linux_aarch64.tar.gz" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  if __download_extract_move "$url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_fastfetch() {
  local exitCode=0
  local name="fastfetch"
  local arch=$(uname -m)
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://github.com/fastfetch-cli/fastfetch/releases/download"
  local VERSION=$(curl --silent "https://api.github.com/repos/fastfetch-cli/fastfetch/releases/latest" | grep '"tag_name":' | sed 's|.*tag.*:||g;s|"||g;s|,||g' | cut -c 2-)
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case "$arch" in
  x86_64) url="$release_url/$VERSION/fastfetch-linux-amd64.tar.gz" ;;
  aarch64 | arm64) url="$release_url/$VERSION/fastfetch-linux-aarch64.tar.gz" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  if __download_extract_move "$url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_gvm() {
  local exitCode=0
  local name="gvm"
  local binDir="$SETUPMGR_DEFAULT_BIN_DIR"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  [ -d "$HOME/.gvm" ] && __rm "$HOME/.gvm" &>/dev/null
  [ -d "$GVM_ROOT" ] && __rm "$GVM_ROOT" &>/dev/null
  if __git_clone_repo "$GVM_GITREPO" "$GVM_ROOT"; then
    [ -d "$GVM_ROOT/.git" ] && __rm "$GVM_ROOT/.git"
    if [ -f "$GVM_ROOT/scripts/gvm-default" ]; then
      . "$GVM_ROOT/scripts/gvm-default" &>/dev/null
      for f in "$GVM_ROOT/bin"/*; do
        name="$(basename -- "$f")"
        ln -sf "$f" "$binDir/$name"
      done
      printf_green "$name has been installed"
      exitCode=0
    else
      exitCode=1
    fi
  else
    exitCode=1
    printf_red "Failed to install $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_vagrant() {
  local exitCode=0
  local name="vagrant"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  local release_url="https://github.com/hashicorp/vagrant/releases/latest/download"
  case "$arch" in
  x86_64) url="$release_url/vagrant-go_linux_amd64" ;;
  *) printf_exit "only x86_64 is supported at this time" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  if __download_and_move "$url" "$name" "$binFile"; then
    if [ -f "$binFile" ]; then
      vagrant plugin install vagrant-libvirt &>/dev/null
      vagrant plugin install vagrant-host-shell &>/dev/null
      vagrant plugin install vagrant-mutate &>/dev/null
      vagrant plugin install vagrant-vbguest &>/dev/null
      vagrant plugin install vagrant-vbguest-libvirt &>/dev/null
      printf_green "vagrant has been installed"
    else
      exitCode=1
    fi
  else
    exitCode=1
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_fnm() {
  local exitCode=0
  local name="fnm"
  local binDir="$HOME/.local/bin"
  local node_version="$FNM_NODE_VERSION"
  local tmpFile="$(mktemp $SETUPMGR_TEMP_DIR/fnm_XXXXXX 2>/dev/null)"
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  [ -d "$FNM_DIR" ] || mkdir -p "$FNM_DIR"
  if __download_and_execute "$FNM_INSTALL_SCRIPT" --install-dir "$binDir" --skip-shell |& __output_status; then
    if __cmd_exists fnm; then
      printf_blue "installing nodejs"
      eval "$(fnm env)"
      fnm install "$node_version" >/dev/null 2>&1
      if fnm ls 2>&1 | grep -q "$node_version"; then
        installed_version="$(node --version 2>/dev/null)"
        fnm use "$node_version" >/dev/null 2>&1
        fnm default "$node_version" >/dev/null 2>&1
        printf_green "FNM is setup to use node $installed_version by default"
      else
        installed_version="$(node --version 2>/dev/null)"
        printf_green "FNM is setup to use node $installed_version by default"
      fi
    else
      printf_red "FNM Failed to install" >&2
    fi
  else
    exitCode=1
    printf_red "Failed to download FNM installer script" &
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_nvm() {
  local exitCode=0
  local GITREPO="$NVM_GITREPO"
  local node_version="$NVM_NODE_VERSION"
  if [ -d "$NVM_DIR/.git" ]; then
    printf_cyan "Updating nvm from $GITREPO"
    if __git_update_repo "$NVM_DIR"; then
      printf_blue "Updated nvm in $NVM_DIR"
    else
      printf_exit "Failed to update $NVM_DIR" >&2
    fi
  else
    printf_green "Downloading nvm from $GITREPO"
    if __git_clone_repo "$GITREPO" "$NVM_DIR"; then
      printf_blue "Downloaded nvm to $NVM_DIR"
      chmod 755 "$NVM_DIR/nvm.sh"
    else
      printf_exit "Failed to download the repo" >&2
    fi
  fi
  [ -f "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"
  if [ -f "$HOME/.npmrc" ]; then
    nvm use --delete-prefix v20.18.0 --silent
    grep -sq 'prefix=' "$HOME/.npmrc" && sed -i "s|prefix=.*||g" "$HOME/.npmrc"
  fi
  if builtin type nvm >/dev/null 2>&1; then
    printf_cyan "Configuring NVM to use $node_version"
    nvm install $node_version >/dev/null 2>&1 && nvm use $node_version >/dev/null 2>&1
    nvm alias default $node_version >/dev/null 2>&1
    version="$(node --version 2>/dev/null || echo 'node')"
    printf_blue "nvm is set to use: $(nvm current 2>/dev/null)"
    if builtin type nvm >/dev/null 2>&1; then
      printf_green "NVM has been configured"
    else
      exitCode=1
      printf_red "NVM Failed to configure" >&2
    fi
  else
    exitCode=1
    printf_red "NVM Failed to install" >&2
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_nodejs() {
  local exitCode=0
  local version="${NODE_VERSION:-24}"
  if __cmd_exists node || __cmd_exists nodejs; then
    printf_green "Attempting to update nodejs"
  else
    printf_green "Installing nodejs"
  fi
  if __cmd_exists volta || curl -q -LSsf "https://get.volta.sh" | bash -s -- --skip-setup >/dev/null 2>&1; then
    if [ -d "$HOME/.volta/bin" ]; then
      for f in "$HOME/.volta/bin"/*; do
        ln -sf "$f" "$HOME/.local/bin/$(basename -- "$f")"
      done
    else
      exitCode=1
      printf_red "Failed to install volta"
    fi
    volta install node@$version >/dev/null 2>&1
  else
    printf_red "Failed to install volta"
    pkmgr silent install nodejs || pkmgr silent install node
  fi
  if __cmd_exists nodejs || __cmd_exists node; then
    npm_ver="$(npm -v 2>/dev/null)"
    version="$(node --version 2>/dev/null)"
    printf_green "nodejs $version and npm $npm_ver have been installed"
  else
    exitCode=1
    printf_red "Failed to install nodejs"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_powershell() {
  local exitCode=0
  local tempBin="pwsh"
  local name="powershell"
  local get_release_file
  local get_release_version
  local binDir="$SETUPMGR_DEFAULT_BIN_DIR"
  PACKAGE_TMP_DIR="$POWERSHELL_TEMP_DIR"
  local installDir="$POWERSHELL_INSTALL_DIR"
  local latest_url="$POWERSHELL_LATEST_URL"
  local os="$(uname -s | tr '[:upper:]' '[:lower:]')"
  local arch="$(uname -m | tr '[:upper:]' '[:lower:]')"
  extract_cmd="do_not_strip_components"
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  if echo "$arch" | grep -q '.*86_64.*' || [ "$arch" = "amd64" ]; then
    arch="x64"
    posh_arch="amd64"
  elif echo "$arch" | grep -q '.*aarch64.*' || [ "$arch" = "arm64" ]; then
    arch="arm64"
    posh_arch="arm64"
  else
    printf_red "Unsupported architecture"
    return 1
  fi
  if [ "$os" = "linux" ]; then
    os="linux"
  elif [ "$os" = "darwin" ]; then
    os="osx"
  elif [ "$os" = "msys" ] || [ "$os" = "windowsnt" ] || [ "$os" = "cygwin" ]; then
    os="win"
  else
    printf_red "Unsupported Operating System"
    return 1
  fi
  [ -d "$PACKAGE_TMP_DIR" ] || mkdir -p "$PACKAGE_TMP_DIR"
  local get_release_url="$(__curl -H "Accept: application/vnd.github+json" "$latest_url" 2>/dev/null | jq -r '.assets[].browser_download_url' 2>/dev/null | grep -v 'fxdependent' | grep "$os-$arch" | grep -E '.tar.gz|.zip' | head -n1 | grep '^' || false)"
  local get_release_name="$(__basename "$get_release_url")"
  local get_release_file="$PACKAGE_TMP_DIR/$get_release_name"
  local get_release_version="$(echo "$get_release_name" | awk -F '.' '{print $1}' | sed 's|.*-||g')"
  local installDir="$installDir/$get_release_version"
  [ -e "$get_release_file" ] && __rm "$get_release_file"
  if [ -z "$get_release_url" ]; then
    exitCode=1
    printf_red "Failed to download powershell"
  else
    if ! __download_extract_install "$get_release_url" "$installDir" "$tempBin" "$binDir/$tempBin"; then
      exitCode=1
    fi
    if [ $exitCode -eq 0 ] && [ -f "$installDir/$tempBin" ]; then
      printf_green "Successfully installed powershell to: $installDir"
      [ -L "$binDir/$tempBin" ] && unlink "$binDir/$tempBin"
      [ -L "$binDir/powershell" ] && unlink "$binDir/powershell"
      [ -f "$binDir/$tempBin" ] || printf '#!/usr/bin/env sh\n\n%s\n' "exec $installDir/$tempBin -ExecutionPolicy Unrestricted \"\$@\"" >"$binDir/$tempBin"
      [ -f "$binDir/powershell" ] || printf '#!/usr/bin/env sh\n\n%s\n' "exec $installDir/$tempBin -ExecutionPolicy Unrestricted \"\$@\"" >"$binDir/powershell"
      chmod -f 755 "$binDir/$tempBin" "$binDir/powershell"
      if [ "$os" = "win" ]; then
        command -v winget >/dev/null 2>&1 && winget install JanDeDobbeleer.OhMyPosh -s winget >/dev/null 2>&1
      elif [ "$os" = "mac" ]; then
        command -v brew >/dev/null 2>&1 && brew install jandedobbeleer/oh-my-posh/oh-my-posh >/dev/null 2>&1
      elif [ "$os" = "linux" ]; then
        if [ -n "$posh_arch" ]; then
          install_posh="$(curl -q -LSsf -H "Accept: application/vnd.github+json" "$POWERSHELL_OMP_GITREPO" | jq -r '.assets[].browser_download_url' | grep "$os" | grep "$posh_arch$" || false)"
          if [ -n "$install_posh" ]; then
            printf_purple "Installing oh-my-posh"
            curl -q -LSsf "$install_posh" -o "$HOME/.local/bin/oh-my-posh"
            if [ -f "$HOME/.local/bin/oh-my-posh" ]; then
              chmod +x "$HOME/.local/bin/oh-my-posh"
              printf_green "Successfully saved oh-my-posh to: ~/.local/bin/oh-my-posh"
            fi
          else
            printf_red "Can not find oh-my-posh $install_posh" >&2
          fi
        else
          printf_red "oh-my-posh is not support on $arch" >&2
        fi
      fi
      printf_cyan "Initializing powershell modules"
      if [ -f "$HOME/.config/powershell/Microsoft.POWERSHELL_profile.ps1" ]; then
        mv -f "$HOME/.config/powershell/Microsoft.POWERSHELL_profile.ps1" "$HOME/.config/powershell/Microsoft.POWERSHELL_profile.bak"
      fi
      if [ -f "$HOME/.config/powershell/init.ps1" ]; then
        if ! eval "$installDir/$tempBin -Command $HOME/.config/powershell/init.ps1" >/dev/null 2>&1; then
          if [ -f "$HOME/.config/powershell/Microsoft.POWERSHELL_profile.bak" ]; then
            mv -f "$HOME/.config/powershell/Microsoft.POWERSHELL_profile.bak" "$HOME/.config/powershell/Microsoft.POWERSHELL_profile.ps1"
          fi
        fi
        if __cmd_exists pwsh; then
          version="$(powershell --version | sed 's|.* ||g')"
          printf_blue "Powershell $version has been installed"
        else
          exitCode=1
          printf_red "Failed to install powershell"
        fi
        for df in $PACKAGE_TMP_DIR $get_release_file; do
          [ -e "$df" ] && printf_yellow "Cleaning up: $df"
        done
      else
        printf_red "Well something went wrong" >&2
        exitCode=1
      fi
    fi
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_jekyll() {
  local exitCode=0
  local jekyllV="${JEKYLL_VERSION:-3.10.0}"
  local rubyV="${JEKYLL_RUBY_VERSION:-3.3.4}"
  if __cmd_exists rbenv; then
    eval "$(rbenv init -)"
    if ! __cmd_exists "ruby"; then
      if ! ruby --version | grep -q "$rubyV"; then
        rbenv install $rubyV >"/dev/null" 2>&1
      fi
    fi
    rbenv use $rubyV >"/dev/null" 2>&1 && printf_cyan "Using rbenv to install jekyll"
  elif __cmd_exists rvm; then
    rvm reload >"/dev/null" >"/dev/null" 2>&1
    if ! __cmd_exists "ruby"; then
      if ! ruby --version | grep -q "$rubyV"; then
        rvm install $rubyV >"/dev/null" 2>&1
      fi
    fi
    rvm use $rubyV >"/dev/null" 2>&1
    type rvm >"/dev/null" 2>&1 && printf_cyan "Using rvm to install jekyll"
  fi
  if ! __cmd_exists bundle; then
    printf_blue "Installing bundler"
    gem install --force bundler >"/dev/null" 2>&1 || sudo gem install --force bundler >"/dev/null" 2>&1
  fi
  if [ "$(type -P bundler)" ]; then
    printf_yellow "Installing jekyll $jekyllV"
    gem install --force webrick >"/dev/null" 2>&1 || sudo gem install --force webrick >"/dev/null" 2>&1
    gem install --force ffi -v 1.17.0 -f >"/dev/null" 2>&1 || sudo gem install --force ffi -v 1.17.0 -f >"/dev/null" 2>&1
    gem install --force jekyll -v $jekyllV >"/dev/null" 2>&1 || sudo gem install --force jekyll -v $jekyllV >"/dev/null" 2>&1
    gem install --force public_suffix -v 5.1.1 -f >"/dev/null" 2>&1 || sudo gem install --force public_suffix -v 5.1.1 -f >"/dev/null" 2>&1
    gem install --force casjaysdev-jekyll-theme >"/dev/null" 2>&1 || sudo gem install --force casjaysdev-jekyll-theme >"/dev/null" 2>&1
    gem install --force github-pages >"/dev/null" 2>&1 || sudo gem install --force github-pages >"/dev/null" 2>&1
    jekyll_bin="$(type -P jekyll)"
    if [ -n "$jekyll_bin" ]; then
      version="$(jekyll -v 2>/dev/null | grep '[0-9]' | sed 's|[jJ]ekyll ||g')"
      ln -sf "$jekyll_bin" "$HOME/.local/bin/jekyll"
      printf_green "Finished installing jekyll $version"
    else
      printf_red "Installation of jekyll has failed" >&2
      exitCode=1
    fi
  else
    exitCode=1
    printf_red "Can not find the command bundler"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_rvm() {
  local exitCode=0
  local binDir="$SETUPMGR_DEFAULT_BIN_DIR"
  local GITREPO="$RVM_GITREPO"
  export rvm_path RUBY_CONFIGURE_OPTS="--enable-shared=no"
  if [ -d "$rvm_path/.git" ]; then
    printf_cyan "Updating rvm from $GITREPO"
    if __git_update_repo "$rvm_path"; then
      printf_blue "Updated rvm in $rvm_path"
    else
      printf_exit "Failed to update $rvm_path" >&2
    fi
  else
    printf_green "Downloading rvm from $GITREPO"
    if __git_clone_repo "$GITREPO" "$rvm_path"; then
      printf_blue "Downloaded rvm to $rvm_path"
    else
      printf_exit "Failed to download the repo" >&2
    fi
  fi
  if [ -f "$rvm_path/bin/rvm" ]; then
    ln -sf "$rvm_path/bin/rvm" "$binDir/rvm"
    chmod 755 "$binDir/rvm"
    if __cmd_exists rvm; then
      mkdir -p "$rvm_path/rubies"
      printf_green "RVM has been installed"
      printf_yellow "Installing openssl"
      if rvm pkg install openssl &>/dev/null; then
        printf_green "Openssl has been installed"
      else
        exitCode=1
        printf_red failed to install OpenSSL
      fi
    else
      printf_green "Failed to install RVM"
    fi
  fi
  if [ $exitCode = 0 ]; then
    for d in "rubies" "src" "archives" "log" "user/install"; do
      [ -d "$rvm_path/$d" ] || mkdir -p "$rvm_path/$d"
    done
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_rbenv() {
  local exitCode=0
  local GITREPO="$RBENV_GITREPO"
  local binDir="$SETUPMGR_DEFAULT_BIN_DIR"
  export RUBY_CONFIGURE_OPTS="--enable-shared=no" RBENV_ROOT="$RBENV_ROOT"
  if [ -d "$RBENV_ROOT/.git" ]; then
    printf_cyan "Updating rbenv from $GITREPO"
    if __git_update_repo "$RBENV_ROOT"; then
      printf_blue "Updated rbenv in $RBENV_ROOT"
    else
      printf_exit "Failed to update $RBENV_ROOT" >&2
    fi
  else
    printf_green "Downloading rbenv from $GITREPO"
    if __git_clone_repo "$GITREPO" "$RBENV_ROOT"; then
      printf_blue "Downloaded rbenv to $RBENV_ROOT"
    else
      printf_exit "Failed to download the repo" >&2
    fi
  fi
  for f in "$RBENV_ROOT/libexec"/*; do
    name="$(basename -- "$f")"
    ln -sf "$f" "$SETUPMGR_DEFAULT_BIN_DIR/$name"
  done
  if __cmd_exists "rbenv"; then
    printf_cyan "RBENV has been installed"
  else
    exitCode=1
    printf_red "Failed to install RBENV"
  fi
  if [ "$exitCode" -eq 0 ]; then
    printf_blue "Installing plugins"
    eval "$(rbenv init -)"
    [ -d "$installDir/plugins/rbenv-plug" ] || __git_clone_repo "https://github.com/znz/rbenv-plug" "$installDir/plugins/rbenv-plug"
    [ -d "$installDir/plugins/ruby-build/.git" ] || __git_clone_repo "https://github.com/rbenv/ruby-build" "$installDir/plugins/ruby-build"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_devbox() {
  local exitCode=0
  local name="devbox"
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  printf_green "Installing $name"
  if __curl "https://get.jetify.com/devbox" | bash -s -- -f |& __output_status; then
    printf_cyan "$name has been installed"
  else
    exitCode=1
    printf_red "Failed to install $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_nix() {
  local exitCode=0
  local name="nix"
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  if __curl "https://install.determinate.systems/nix" | sh -s -- install --no-confirm |& __output_status; then
    if [ -f "/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh" ]; then
      printf_blue "nix-installer has been installed"
      . /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh
      for f in /nix/var/nix/profiles/default/bin/*; do
        ln -sf "$f" "$HOME/.local/bin/$(__basename "$f")"
      done
    else
      exitCode=1
      printf_red "Failed to install nix-installer"
    fi
  else
    exitCode=1
    printf_red "Failed to execute the nix-installer script"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_helm() {
  local url
  local name="helm"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local dist_tag="$(__curl "https://get.helm.sh/helm-latest-version" | grep '^v[0-9]')"
  if __cmd_exists $name; then
    printf_green "$name is already installed"
  else
    printf_green "Installing $name"
  fi
  case $arch in
  x86_64) url="https://get.helm.sh/helm-$dist_tag-linux-amd64.tar.gz" ;;
  aarch64 | arm64) url="https://get.helm.sh/helm-$dist_tag-linux-arm64.tar.gz" ;;
  esac
  if __download_extract_move "$url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    __install_to_system_bin "$binFile"
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode

}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_helix() {
  local exitCode=0
  local name="hx"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local installDir="$SETUPMGR_DEFAULT_SHARE_DIR/helix"
  local release_url="https://api.github.com/repos/helix-editor/helix/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/helix"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating helix"
  else
    printf_green "Installing helix"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/helix-editor/helix/releases/download/${version}/helix-${version}-x86_64-linux.tar.xz" ;;
  aarch64 | arm64) download_url="https://github.com/helix-editor/helix/releases/download/${version}/helix-${version}-aarch64-linux.tar.xz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for helix"
    return 1
  fi

  if __download_extract_install "$download_url" "$installDir" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "helix has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download helix"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_hyperfine() {
  local exitCode=0
  local name="hyperfine"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/sharkdp/hyperfine/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/sharkdp/hyperfine/releases/download/${version}/hyperfine-${version#v}-x86_64-unknown-linux-musl.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/sharkdp/hyperfine/releases/download/${version}/hyperfine-${version#v}-aarch64-unknown-linux-musl.tar.gz" ;;
  armv7l | arm) download_url="https://github.com/sharkdp/hyperfine/releases/download/${version}/hyperfine-${version#v}-arm-unknown-linux-musleabihf.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_packer() {
  local exitCode=0
  local name="packer"
  local arch="$(uname -m)"
  local version="$PACKER_VERSION"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi
  case $arch in
  x86_64) release_url="https://releases.hashicorp.com/packer/${version}/packer_${version}_linux_amd64.zip" ;;
  aarch64 | arm64) release_url="https://releases.hashicorp.com/packer/${version}/packer_${version}_linux_arm64.zip" ;;
  esac
  if __download_extract_move "$release_url" "$name" "$binFile"; then
    if [ -n "$PACKER_PLUGINS" ]; then
      for plug in $PACKER_PLUGINS; do
        packer plugins install github.com/hashicorp/$plug >/dev/null 2>&1 && printf_cyan "Installed plugin: $plug"
      done
    fi
    printf_green "$name hase been installed"
  else
    exitCode=1
    printf_red "Failed to install $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_kubectl() {
  local exitCode=0
  local name="kubectl"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)"
  case $arch in
  x86_64) file="bin/linux/amd64/kubectl" ;;
  aarch64 | arm64) file="bin/linux/arm64/kubectl" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi
  if __download_and_move "$release_url/$file" "$name" "$binFile"; then
    __install_to_system_bin "$binFile"
    printf_green "$name hase been installed"
  else
    exitCode=1
    printf_red "Failed to install $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_kind() {
  local exitCode=0
  local name="kind"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/kubernetes-sigs/kind/releases/latest"
  case $arch in
  x86_64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "kind.linux.amd64\$")" ;;
  aarch64 | arm64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "kind.linux.arm64\$")" ;;
  esac
  if __cmd_exists $name; then
    printf_green "$name is already installed"
  else
    printf_green "Installing $name"
  fi
  if __download_and_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    __install_to_system_bin "$binFile"
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_k9s() {
  local exitCode=0
  local name="k9s"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/derailed/k9s/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/derailed/k9s/releases/download/${version}/k9s_Linux_amd64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/derailed/k9s/releases/download/${version}/k9s_Linux_arm64.tar.gz" ;;
  armv7l | arm) download_url="https://github.com/derailed/k9s/releases/download/${version}/k9s_Linux_arm.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_minikube() {
  local exitCode=0
  local name=minikube
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/minikube"
  if __cmd_exists minikube; then
    printf_green "Updating minikube"
  else
    printf_green "Installing minikube"
  fi
  case $arch in
  x86_64) url="https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64" ;;
  aarch64 | arm64) url="https://storage.googleapis.com/minikube/releases/latest/minikube-linux-arm64" ;;
  esac
  if __download_and_move "$url" "minikube" "$binFile"; then
    __install_to_system_bin "$binFile"
    printf_green "minikube has been installed: $binFile"
    printf_cyan "Use 'dockermgr minikube' to configure and start minikube"
  else
    exitCode=1
    printf_red "Failed to download minikube"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_direnv() {
  local exitCode=0
  local name="direnv"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/direnv/direnv/releases/latest"
  case $arch in
  x86_64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "$name.linux.amd64\$")" ;;
  aarch64 | arm64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "$name.linux.arm64\$")" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi
  if __download_and_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    __install_to_system_bin "$binFile"
    printf_green "Direnv has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_incus() {
  local exitCode=0
  local name="incus"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/lxc/incus/releases/latest"
  case $arch in
  x86_64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "bin.linux.incus.x86_64\$")" ;;
  aarch64 | arm64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "bin.linux.incus.aarch64\$")" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi
  if __download_and_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    __install_to_system_bin "$binFile"
    if ! grep -qs 'incus-admin' '/etc/group'; then
      __sudo true
      __sudo groupadd --system incus-admin >/dev/null 2>&1
      __sudo usermod -a -G incus-admin $USER >/dev/null 2>&1
    fi
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_gohttpserver() {
  local exitCode=0
  local name="gohttpserver"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/codeskyblue/gohttpserver/releases/latest"
  extract_cmd="do_not_strip_components"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case $arch in
  x86_64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "linux_amd64.tar.gz\$")" ;;
  aarch64 | arm64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "linux_arm64.tar.gz\$")" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    __install_to_system_bin "$binFile"
    printf_green "$name has been installed to $binFile"

    # Setup systemd service (create but don't enable)
    local service_file=""
    local systemd_cmd="systemctl"
    local serve_dir="$HOME/public_html"

    mkdir -p "$serve_dir"

    if __sudoif; then
      service_file="/etc/systemd/system/gohttpserver.service"
    else
      service_file="$HOME/.config/systemd/user/gohttpserver.service"
      systemd_cmd="systemctl --user"
      mkdir -p "$HOME/.config/systemd/user"
    fi

    printf_green "Installing systemd service file"
    if __sudoif; then
      sudo tee "$service_file" >/dev/null <<EOF
[Unit]
Description=Go HTTP Server - Simple HTTP File Server
After=network-online.target
Wants=network-online.target
Documentation=https://github.com/codeskyblue/gohttpserver

[Service]
Type=simple
ExecStart=$binFile --root $serve_dir --addr 0.0.0.0:8000
Restart=on-failure
RestartSec=5

Environment=HOME=$HOME

[Install]
WantedBy=multi-user.target
EOF
      sudo systemctl daemon-reload
      printf_yellow "GoHTTPServer service created but NOT enabled"
    else
      cat >"$service_file" <<EOF
[Unit]
Description=Go HTTP Server - Simple HTTP File Server
After=network-online.target
Wants=network-online.target
Documentation=https://github.com/codeskyblue/gohttpserver

[Service]
Type=simple
ExecStart=$binFile --root $serve_dir --addr 0.0.0.0:8000
Restart=on-failure
RestartSec=5

Environment=HOME=$HOME

[Install]
WantedBy=default.target
EOF
      systemctl --user daemon-reload
      printf_yellow "GoHTTPServer service created but NOT enabled"
    fi
    printf_green "Systemd service installed: $service_file"
    printf_cyan "Serving directory: $serve_dir"
    printf_cyan "Enable service: $systemd_cmd enable gohttpserver"
    printf_cyan "Start service:  $systemd_cmd start gohttpserver"
    printf_cyan "Status:         $systemd_cmd status gohttpserver"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_lazygit() {
  local exitCode=0
  local name="lazygit"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/jesseduffield/lazygit/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/jesseduffield/lazygit/releases/download/${version}/lazygit_${version#v}_Linux_x86_64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/jesseduffield/lazygit/releases/download/${version}/lazygit_${version#v}_Linux_arm64.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_dive() {
  local exitCode=0
  local name="dive"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/wagoodman/dive/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/wagoodman/dive/releases/download/${version}/dive_${version#v}_linux_amd64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/wagoodman/dive/releases/download/${version}/dive_${version#v}_linux_arm64.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_lazydocker() {
  local exitCode=0
  local name="lazydocker"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/jesseduffield/lazydocker/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/jesseduffield/lazydocker/releases/download/${version}/lazydocker_${version#v}_Linux_x86_64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/jesseduffield/lazydocker/releases/download/${version}/lazydocker_${version#v}_Linux_arm64.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_fzf() {
  local exitCode=0
  local name="fzf"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/junegunn/fzf/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/junegunn/fzf/releases/download/${version}/fzf-${version#v}-linux_amd64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/junegunn/fzf/releases/download/${version}/fzf-${version#v}-linux_arm64.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_mc() {
  local exitCode=0
  local name="mc"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/minio-cli"
  extract_cmd="do_not_strip_components"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case $arch in
  x86_64) download_url="https://dl.min.io/client/mc/release/linux-amd64/mc" ;;
  aarch64 | arm64) download_url="https://dl.min.io/client/mc/release/linux-arm64/mc" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi
  if __download_and_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    __install_to_system_bin "$binFile"
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_act() {
  local exitCode=0
  local name="act"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/nektos/act/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/nektos/act/releases/download/${version}/act_Linux_x86_64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/nektos/act/releases/download/${version}/act_Linux_arm64.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_traefik() {
  local exitCode=0
  local name="traefik"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/traefik/traefik/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/traefik/traefik/releases/download/${version}/traefik_${version}_linux_amd64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/traefik/traefik/releases/download/${version}/traefik_${version}_linux_arm64.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"

    # Setup systemd service (create but don't enable)
    local service_file=""
    local systemd_cmd="systemctl"
    local config_file="$HOME/.config/traefik/traefik.yml"

    mkdir -p "$(dirname "$config_file")"

    if __sudoif; then
      service_file="/etc/systemd/system/traefik.service"
    else
      service_file="$HOME/.config/systemd/user/traefik.service"
      systemd_cmd="systemctl --user"
      mkdir -p "$HOME/.config/systemd/user"
    fi

    printf_green "Installing systemd service file"
    if __sudoif; then
      sudo tee "$service_file" >/dev/null <<EOF
[Unit]
Description=Traefik Reverse Proxy
After=network-online.target
Wants=network-online.target
Documentation=https://doc.traefik.io/traefik/

[Service]
Type=notify
ExecStart=$binFile --configfile=$config_file
Restart=on-failure
RestartSec=5

Environment=HOME=$HOME
WatchdogSec=30
LimitNOFILE=1048576
LimitNPROC=512

[Install]
WantedBy=multi-user.target
EOF
      sudo systemctl daemon-reload
      printf_yellow "Traefik service created but NOT enabled"
    else
      cat >"$service_file" <<EOF
[Unit]
Description=Traefik Reverse Proxy
After=network-online.target
Wants=network-online.target
Documentation=https://doc.traefik.io/traefik/

[Service]
Type=notify
ExecStart=$binFile --configfile=$config_file
Restart=on-failure
RestartSec=5

Environment=HOME=$HOME
WatchdogSec=30
LimitNOFILE=1048576
LimitNPROC=512

[Install]
WantedBy=default.target
EOF
      systemctl --user daemon-reload
      printf_yellow "Traefik service created but NOT enabled"
    fi
    printf_green "Systemd service installed: $service_file"
    printf_cyan "Config file location: $config_file"
    printf_cyan "Enable service: $systemd_cmd enable traefik"
    printf_cyan "Start service:  $systemd_cmd start traefik"
    printf_cyan "Status:         $systemd_cmd status traefik"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_bob() {
  local exitCode=0
  local name="bob"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/MordechaiHadad/bob/releases/latest"
  extract_cmd="do_not_strip_components"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case $arch in
  x86_64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "linux-x86_64-openssl.zip\$")" ;;
  aarch64 | arm64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "linux-aarch64-openssl.zip\$")" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi
  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    mkdir -p "$HOME/.local/share/bob"

    if [ ! -f "$HOME/.config/bob/config.json" ]; then
      mkdir -p "$HOME/.config/bob"
      cat <<EOF >"$HOME/.config/bob/config.json"
{
  "installation_location": "$HOME/.local/bin",
  "downloads_location": "$HOME/.local/share/bob",
  "version_sync_file_location": "$HOME/.config/bob/nvim.version"
}
EOF
    fi
    __install_to_system_bin "$binFile"
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_broot() {
  local exitCode=0
  local name="broot"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/Canop/broot/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/Canop/broot/releases/download/${version}/broot_${version#v}_linux_x86_64.zip" ;;
  aarch64 | arm64) download_url="https://github.com/Canop/broot/releases/download/${version}/broot_${version#v}_linux_aarch64.zip" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
    printf_cyan "Run 'broot' to configure on first launch"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_opentofu() {
  local exitCode=0
  local name="tofu"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/opentofu/opentofu/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/opentofu/opentofu/releases/download/${version}/tofu_${version#v}_linux_amd64.zip" ;;
  aarch64 | arm64) download_url="https://github.com/opentofu/opentofu/releases/download/${version}/tofu_${version#v}_linux_arm64.zip" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_webhookd() {
  local exitCode=0
  local name="webhookd"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/ncarlier/webhookd/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/ncarlier/webhookd/releases/download/${version}/webhookd-linux-amd64.tgz" ;;
  aarch64 | arm64) download_url="https://github.com/ncarlier/webhookd/releases/download/${version}/webhookd-linux-arm64.tgz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"

    # Setup systemd service (create but don't enable)
    local service_file=""
    local systemd_cmd="systemctl"
    local scripts_dir="$HOME/.local/share/webhookd/scripts"

    mkdir -p "$scripts_dir"

    if __sudoif; then
      service_file="/etc/systemd/system/webhookd.service"
    else
      service_file="$HOME/.config/systemd/user/webhookd.service"
      systemd_cmd="systemctl --user"
      mkdir -p "$HOME/.config/systemd/user"
    fi

    printf_green "Installing systemd service file"
    if __sudoif; then
      sudo tee "$service_file" >/dev/null <<EOF
[Unit]
Description=Webhookd - Webhook Server
After=network-online.target
Wants=network-online.target
Documentation=https://github.com/ncarlier/webhookd

[Service]
Type=simple
ExecStart=$binFile --listen 0.0.0.0:8080 --scripts $scripts_dir
Restart=on-failure
RestartSec=5

Environment=HOME=$HOME

[Install]
WantedBy=multi-user.target
EOF
      sudo systemctl daemon-reload
      printf_yellow "Webhookd service created but NOT enabled"
    else
      cat >"$service_file" <<EOF
[Unit]
Description=Webhookd - Webhook Server
After=network-online.target
Wants=network-online.target
Documentation=https://github.com/ncarlier/webhookd

[Service]
Type=simple
ExecStart=$binFile --listen 0.0.0.0:8080 --scripts $scripts_dir
Restart=on-failure
RestartSec=5

Environment=HOME=$HOME

[Install]
WantedBy=default.target
EOF
      systemctl --user daemon-reload
      printf_yellow "Webhookd service created but NOT enabled"
    fi
    printf_green "Systemd service installed: $service_file"
    printf_cyan "Scripts directory: $scripts_dir"
    printf_cyan "Enable service: $systemd_cmd enable webhookd"
    printf_cyan "Start service:  $systemd_cmd start webhookd"
    printf_cyan "Status:         $systemd_cmd status webhookd"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_gh() {
  local exitCode=0
  local name="gh"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/cli/cli/releases/latest"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case $arch in
  x86_64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "linux_amd64.tar.gz\$")" ;;
  aarch64 | arm64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "linux_arm64.tar.gz\$")" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    __install_to_system_bin "$binFile"
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_lima() {
  local exitCode=0
  local name="lima"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local installDir="$SETUPMGR_DEFAULT_SHARE_DIR/lima"
  local release_url="https://api.github.com/repos/lima-vm/lima/releases/latest"
  tempBin="bin/lima"
  SYMLINK_FILES_TO="$SETUPMGR_DEFAULT_BIN_DIR"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case $arch in
  x86_64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "Linux-x86_64.tar.gz\$")" ;;
  aarch64 | arm64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "Linux-aarch64.tar.gz\$")" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  if __download_extract_install "$download_url" "$installDir" "$tempBin" "$binFile" && __is_installed "$name" "$installDir"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode

}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_localai() {
  local exitCode=0
  local name="local-ai"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/mudler/LocalAI/releases/latest"
  local version=""

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  # Get the latest version tag
  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/mudler/LocalAI/releases/download/${version}/local-ai-${version}-linux-amd64" ;;
  aarch64 | arm64) download_url="https://github.com/mudler/LocalAI/releases/download/${version}/local-ai-${version}-linux-arm64" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_and_move "$download_url" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"

    # Setup systemd service
    local service_file=""
    local systemd_cmd="systemctl"
    local models_dir="$HOME/.local/share/localai/models"

    mkdir -p "$models_dir"

    if __sudoif; then
      service_file="/etc/systemd/system/localai.service"
    else
      service_file="$HOME/.config/systemd/user/localai.service"
      systemd_cmd="systemctl --user"
      mkdir -p "$HOME/.config/systemd/user"
    fi

    printf_green "Installing systemd service file"
    if __sudoif; then
      sudo tee "$service_file" >/dev/null <<EOF
[Unit]
Description=LocalAI Service
After=network-online.target
Documentation=https://localai.io/

[Service]
Type=simple
ExecStart=$binFile --address 0.0.0.0:8080 --models-path $models_dir
Restart=always
RestartSec=3

Environment=HOME=$HOME
WorkingDirectory=$models_dir

[Install]
WantedBy=multi-user.target
EOF
      sudo systemctl daemon-reload
      sudo systemctl enable localai
      printf_green "LocalAI service enabled (will start on boot)"
    else
      cat >"$service_file" <<EOF
[Unit]
Description=LocalAI Service
After=network-online.target
Documentation=https://localai.io/

[Service]
Type=simple
ExecStart=$binFile --address 0.0.0.0:8080 --models-path $models_dir
Restart=always
RestartSec=3

Environment=HOME=$HOME
WorkingDirectory=$models_dir

[Install]
WantedBy=default.target
EOF
      systemctl --user daemon-reload
      systemctl --user enable localai
      printf_green "LocalAI service enabled (will start on login)"
    fi
    printf_green "Systemd service installed: $service_file"
    printf_cyan "Models directory: $models_dir"
    printf_cyan "Start service: $systemd_cmd start localai"
    printf_cyan "Status:        $systemd_cmd status localai"
    printf_cyan "API endpoint:  http://localhost:8080"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_zed() {
  local exitCode=0
  local name="zed-editor"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local installDir="$ZED_INSTALL_DIR"
  local release_url="https://zed.dev/api/releases/stable/latest"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/zed"
  tempBin="bin/zed"
  if ! __check_for_vulkan_support; then
    printf_red "Vulkan support check failed - vulkaninfo not found or no Vulkan devices detected"
    printf_yellow "Zed editor requires Vulkan support. Install vulkan drivers and vulkan-tools package"
    return 1
  fi
  case $arch in
  x86_64) download_url="$release_url/zed-linux-x86_64.tar.gz" ;;
  aarch64 | arm64) download_url="$release_url/zed-linux-aarch64.tar.gz" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  if __download_extract_install "$download_url" "$installDir" "$tempBin" "$binFile" && __is_installed "$name" "$binFile"; then
    cp -Rf "$installDir/share/applications/zed.desktop" "$HOME/.local/share/applications/Zed-Editor.desktop"
    sed -i "s|Icon=zed|Icon=$installDir/share/icons/hicolor/512x512/apps/zed.png|g" "$HOME/.local/share/applications/Zed-Editor.desktop"
    sed -i "s|Exec=zed|Exec=$installDir/libexec/zed-editor|g" "$HOME/.local/share/applications/Zed-Editor.desktop"
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_golang() {
  local exitCode=0
  local name="go"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local installDir="$SETUPMGR_DEFAULT_SHARE_DIR/go"
  local release_base_url="https://go.dev/VERSION?m=text"
  local latest_version="${GO_VERSION:-$(curl -q -LSsf "$release_base_url" | grep go[0-9])}"
  local tempBin="bin/go"
  #extract_cmd="do_not_strip_components"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case $arch in
  x86_64) download_url="https://go.dev/dl/${latest_version}.linux-amd64.tar.gz" ;;
  aarch64 | arm64) download_url="https://go.dev/dl/${latest_version}.linux-arm64.tar.gz" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  if __download_extract_install "$download_url" "$installDir" "$tempBin" "$binFile" && __is_installed "$name" "$installDir"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_ollama() {
  local exitCode=0
  local name="ollama"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local installDir="$SETUPMGR_DEFAULT_SHARE_DIR/ollama"
  local release_url="https://api.github.com/repos/ollama/ollama/releases/latest"
  tempBin="bin/$name"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case $arch in
  x86_64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "linux-amd64.tgz\$")" ;;
  aarch64 | arm64) download_url="$(__curl ""$release_url | grep browser_download_url | cut -d '"' -f 4 | grep "linux-arm64.tgz\$")" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  if __download_extract_install "$download_url" "$installDir" "$tempBin" "$binFile" && __is_installed "$name" "$installDir/bin"; then
    printf_green "$name has been installed to $binFile"

    # Setup systemd service
    local service_file=""
    local systemd_cmd="systemctl"

    if __sudoif; then
      service_file="/etc/systemd/system/ollama.service"
    else
      service_file="$HOME/.config/systemd/user/ollama.service"
      systemd_cmd="systemctl --user"
      mkdir -p "$HOME/.config/systemd/user"
    fi

    printf_green "Installing systemd service file"
    if __sudoif; then
      sudo tee "$service_file" >/dev/null <<EOF
[Unit]
Description=Ollama Service
After=network-online.target
Documentation=https://github.com/ollama/ollama

[Service]
Type=simple
ExecStart=$binFile serve
Restart=always
RestartSec=3

Environment=HOME=$HOME
Environment=OLLAMA_HOST=0.0.0.0

[Install]
WantedBy=multi-user.target
EOF
      sudo systemctl daemon-reload
      sudo systemctl enable ollama
      printf_green "Ollama service enabled (will start on boot)"
    else
      cat >"$service_file" <<EOF
[Unit]
Description=Ollama Service
After=network-online.target
Documentation=https://github.com/ollama/ollama

[Service]
Type=simple
ExecStart=$binFile serve
Restart=always
RestartSec=3

Environment=HOME=$HOME
Environment=OLLAMA_HOST=0.0.0.0

[Install]
WantedBy=default.target
EOF
      systemctl --user daemon-reload
      systemctl --user enable ollama
      printf_green "Ollama service enabled (will start on login)"
    fi
    printf_green "Systemd service installed: $service_file"
    printf_cyan "Start service: $systemd_cmd start ollama"
    printf_cyan "Status:        $systemd_cmd status ollama"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_coder() {
  local exitCode=0
  local name="coder"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/coder/coder/releases/latest"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case $arch in
  x86_64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "_linux_amd64.tar.gz\$")" ;;
  aarch64 | arm64) download_url="$(__curl ""$release_url | grep browser_download_url | cut -d '"' -f 4 | grep "_linux_arm64.tar.gz\$")" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_ctop() {
  local exitCode=0
  local name="ctop"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/bcicen/ctop/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/bcicen/ctop/releases/download/${version}/ctop-${version#v}-linux-amd64" ;;
  aarch64 | arm64) download_url="https://github.com/bcicen/ctop/releases/download/${version}/ctop-${version#v}-linux-arm64" ;;
  armv7l | arm) download_url="https://github.com/bcicen/ctop/releases/download/${version}/ctop-${version#v}-linux-arm" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_and_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_podman() {
  local exitCode=0
  local name="podman-desktop"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local installDir="$SETUPMGR_DEFAULT_SHARE_DIR/$name"
  local release_url="https://github.com/containers/podman-desktop/releases/download/v1.13.2/podman-desktop-1.13.2.tar.gz"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  if [ "$arch" = "x86_64" ]; then
    if ! __cmd_exists podman; then
      printf_yellow "Installing podman"
      pkmgr install silent podman
    fi
    if __cmd_exists $name; then
      printf_green "Updating $name"
    else
      printf_green "Installing $name"
    fi
    if __download_extract_install "$release_url" "$installDir" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
      printf_green "$name has been installed to $binFile"
      __gen_desktopfile "$name" "$binFile"
    else
      exitCode=1
      printf_red "Failed to download $name"
    fi
  else
    exitCode=0
    printf_red "Unsupported architecture"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_lapce() {
  local exitCode=0
  local name="lapce"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/lapce/lapce/releases/latest"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case $arch in
  x86_64) download_url="https://github.com/lapce/lapce/releases/latest/download/lapce-linux-amd64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/lapce/lapce/releases/latest/download/lapce-linux-arm64.tar.gz" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi
  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    __install_to_system_bin "$binFile"
    printf_green "$name has been installed to $binFile"
    __gen_desktopfile "$name" "$binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_startship() {
  local exitCode=0
  local name="starship"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/starship/$name/releases/latest"
  extract_cmd="do_not_strip_components"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case $arch in
  x86_64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "x86_64-unknown-linux-gnu.tar.gz\$")" ;;
  aarch64 | arm64) download_url="$(__curl "$release_url" | grep browser_download_url | cut -d '"' -f 4 | grep "aarch64-unknown-linux-gnu.tar.gz\$")" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi
  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    __install_to_system_bin "$binFile"
    if [ ! -f "$HOME/.config/starship.toml" ]; then
      starship preset pastel-powerline -o "$HOME/.config/starship.toml" >/dev/null 2>&1
    fi
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_minio() {
  local exitCode=0
  local restart=""
  local name="minio"
  local console_port=""
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local username="administrator"
  local userpass="$(openssl rand -base64 32)"
  local release_url="https://dl.min.io/server/$name/release"
  local MINIO_ROOT_USER="${MINIO_ROOT_USER:-$username}"
  local MINIO_ROOT_PASSWORD="${MINIO_ROOT_PASSWORD:-$userpass}"
  local MINIO_STORAGE_DIR="${MINIO_STORAGE_DIR:-/var/lib/minio/data}"
  local MINIO_BROWSER_REDIRECT_URL="${MINIO_BROWSER_REDIRECT_URL:-http://$HOSTNAME:49001}"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case $arch in
  x86_64) download_url="$release_url/linux-amd64/$name" ;;
  aarch64 | arm64) download_url="$release_url/linux-arm64/$name" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
    sudo systemctl stop $name.service >/dev/null 2>&1
  else
    printf_green "Installing $name"
  fi
  if __download_and_move "$download_url" "$name" "$binFile"; then
    if [ -f "/etc/default/$name" ]; then
      . "/etc/default/$name"
    fi
    if __sudoif && __install_to_system_bin "$binFile"; then
      if ! grep -sq "/var/lib/$name" /etc/passwd; then
        sudo useradd -s /sbin/nologin -d "/var/lib/$name" $name >/dev/null 2>&1
      fi
      console_port="$(echo "$MINIO_BROWSER_REDIRECT_URL" | awk -F ':' '{print $NF}' | grep '^')"
      [ -d "/etc/minio" ] || sudo mkdir -p "/etc/minio"
      [ -d "$MINIO_STORAGE_DIR" ] || sudo mkdir -p "$MINIO_STORAGE_DIR"
      cat <<EOF | sudo tee "/etc/default/$name" &>/dev/null
# Volume to be used for Minio server.
MINIO_VOLUMES="$MINIO_STORAGE_DIR"

# Use if you want to run Minio on a custom port.
MINIO_OPTS="--address 0.0.0.0:49000 --console-address 0.0.0.0:$console_port"

# set console web address
MINIO_BROWSER_REDIRECT_URL="$MINIO_BROWSER_REDIRECT_URL"

# Root user for the server.
MINIO_ROOT_USER=$MINIO_ROOT_USER
# Root secret for the server.
MINIO_ROOT_PASSWORD=$MINIO_ROOT_PASSWORD

EOF
      cat <<EOF | sudo tee "/etc/systemd/system/$name.service" &>/dev/null
[Unit]
Description=S3 compatible server
Documentation=https://docs.min.io
AssertFileIsExecutable=/usr/local/bin/$name

[Service]
User=root
Group=root

WorkingDirectory=/var/lib/$name
EnvironmentFile=/etc/default/$name
Environment=MINIO_VOLUMES=$MINIO_STORAGE_DIR
Environment=MINIO_ROOT_USER=$MINIO_ROOT_USER
Environment=MINIO_ROOT_PASSWORD=$MINIO_ROOT_PASSWORD
Environment=MINIO_BROWSER_REDIRECT_URL=$MINIO_BROWSER_REDIRECT_URL
Environment=MINIO_OPTS=--address 0.0.0.0:49000 --console-address 0.0.0.0:$console_port

ExecStart=/usr/local/bin/$name server \$MINIO_OPTS $MINIO_STORAGE_DIR

# Let systemd restart this service always
Restart=always

# Specifies the maximum file descriptor number that can be opened by this process
LimitNOFILE=65536

# Disable timeout logic and wait until process is stopped
SendSIGKILL=no
TimeoutStopSec=infinity

[Install]
WantedBy=multi-user.target

EOF
      sudo systemctl daemon-reload >/dev/null 2>&1
      sudo chmod 777 "$MINIO_STORAGE_DIR" >/dev/null 2>&1
      sudo chown -f $name:$name /etc/default/$name >/dev/null 2>&1
      sudo chown -Rf $name:$name "/var/lib/$name" >/dev/null 2>&1
      sudo chown -Rf $name:$name "/etc/minio/minio.conf" >/dev/null 2>&1
      printf_green "$name has been installed to $binFile"
      printf_yellow "MinIO service created but NOT enabled"
      [ -z "$MINIO_ROOT_USER" ] || printf_cyan "Username: $MINIO_ROOT_USER"
      [ -z "$MINIO_ROOT_PASSWORD" ] || printf_cyan "Password: $MINIO_ROOT_PASSWORD"
      printf_cyan "Console URL: $MINIO_BROWSER_REDIRECT_URL"
      printf_cyan "Enable service: sudo systemctl enable $name"
      printf_cyan "Start service:  sudo systemctl start $name"
      printf_cyan "Status:         sudo systemctl status $name"
    else
      printf_green "$name has been installed to $binFile"
      printf_yellow "MINIO_ROOT_USER=$MINIO_ROOT_USER MINIO_ROOT_PASSWORD=$MINIO_ROOT_PASSWORD $binFile --address 0.0.0.0:49000 --console-address 0.0.0.0:$console_port \"$HOME/.local/share/minio/data\""
    fi
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_garage() {
  local exitCode=0
  local name="garage"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local rpc_secret="$(openssl rand -hex 32)"
  local metrics_token="$(openssl rand -base64 32)"
  local admin_password="$(openssl rand -base64 32)"
  local storage_dir="$GARAGE_STORAGE_DIR"
  local release_url="https://garagehq.deuxfleurs.fr/_releases/v${GARAGE_VERSION:-1.0.1}"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  case $arch in
  x86_64) download_url="$release_url/x86_64-unknown-linux-musl/garage" ;;
  aarch64 | arm64) download_url="$release_url/aarch64-unknown-linux-musl/garage" ;;
  esac
  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi
  if __download_and_move "$download_url" "$name" "$binFile"; then
    if __install_to_system_bin "$binFile"; then
      [ -d "/var/lib/$name/data" ] || sudo mkdir -p "/var/lib/$name/data"
      [ -d "/var/lib/$name/meta" ] || sudo mkdir -p "/var/lib/$name/meta"
      sudo chmod 755 "/var/lib/$name"
      if [ -f "/etc/garage.toml" ]; then
        unset admin_password username
      else
        cat <<EOF | sudo tee "/etc/garage.toml" >/dev/null
metadata_dir = "/var/lib/garage/meta"
data_dir = "/var/lib/garage/data"
db_engine = "sqlite"

replication_factor = 1

rpc_bind_addr = "[::]:49002"
rpc_public_addr = "[::]:49002"
rpc_secret = "$rpc_secret"

[s3_api]
s3_region = "garage"
api_bind_addr = "[::]:49003"
root_domain = ".garage.$HOSTNAME"

[s3_web]
bind_addr = "[::]:49004"
root_domain = ".garage-console.$HOSTNAME"
index = "index.html"

[k2v_api]
api_bind_addr = "[::]:49005"

[admin]
api_bind_addr = "[::]:49006"
admin_token = "$admin_password"
metrics_token = "$metrics_token"
EOF
      fi
      if [ ! -f "/etc/systemd/system/$name.service" ]; then
        cat <<EOF | sudo tee "/etc/systemd/system/$name.service" &>/dev/null
[Unit]
Description=Garage Data Store
After=network-online.target
Wants=network-online.target

[Service]
Environment='RUST_LOG=garage=info' 'RUST_BACKTRACE=1'
ExecStart=/usr/local/bin/garage server
StateDirectory=garage
DynamicUser=true
ProtectHome=true
NoNewPrivileges=true

[Install]
WantedBy=multi-user.target

EOF
      fi
      sudo systemctl daemon-reload >/dev/null 2>&1
    fi
    printf_green "$name has been installed to $binFile"
    printf_yellow "Garage service created but NOT enabled"
    [ -z "$admin_password" ] || printf_cyan "Admin password: $admin_password"
    printf_cyan "Enable service: sudo systemctl enable $name"
    printf_cyan "Start service:  sudo systemctl start $name"
    printf_cyan "Status:         sudo systemctl status $name"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_xcaddy() {
  local exitCode=0
  local name="xcaddy"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/caddyserver/xcaddy/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/caddyserver/xcaddy/releases/download/${version}/xcaddy_${version#v}_linux_amd64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/caddyserver/xcaddy/releases/download/${version}/xcaddy_${version#v}_linux_arm64.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_caddy() {
  local exitCode=0
  local name="caddy"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/caddyserver/caddy/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/caddyserver/caddy/releases/download/${version}/caddy_${version#v}_linux_amd64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/caddyserver/caddy/releases/download/${version}/caddy_${version#v}_linux_arm64.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
    __setup_xcaddy

    # Setup systemd service (create but don't enable)
    local service_file=""
    local systemd_cmd="systemctl"
    local caddyfile="$HOME/.config/caddy/Caddyfile"

    mkdir -p "$(dirname "$caddyfile")"

    if __sudoif; then
      service_file="/etc/systemd/system/caddy.service"
    else
      service_file="$HOME/.config/systemd/user/caddy.service"
      systemd_cmd="systemctl --user"
      mkdir -p "$HOME/.config/systemd/user"
    fi

    printf_green "Installing systemd service file"
    if __sudoif; then
      sudo tee "$service_file" >/dev/null <<EOF
[Unit]
Description=Caddy Web Server
After=network-online.target
Wants=network-online.target
Documentation=https://caddyserver.com/docs/

[Service]
Type=notify
ExecStart=$binFile run --config $caddyfile --adapter caddyfile
ExecReload=$binFile reload --config $caddyfile --adapter caddyfile
Restart=on-failure
RestartSec=5

Environment=HOME=$HOME
TimeoutStopSec=5
LimitNOFILE=1048576
LimitNPROC=512

[Install]
WantedBy=multi-user.target
EOF
      sudo systemctl daemon-reload
      printf_yellow "Caddy service created but NOT enabled"
    else
      cat >"$service_file" <<EOF
[Unit]
Description=Caddy Web Server
After=network-online.target
Wants=network-online.target
Documentation=https://caddyserver.com/docs/

[Service]
Type=notify
ExecStart=$binFile run --config $caddyfile --adapter caddyfile
ExecReload=$binFile reload --config $caddyfile --adapter caddyfile
Restart=on-failure
RestartSec=5

Environment=HOME=$HOME
TimeoutStopSec=5
LimitNOFILE=1048576
LimitNPROC=512

[Install]
WantedBy=default.target
EOF
      systemctl --user daemon-reload
      printf_yellow "Caddy service created but NOT enabled"
    fi
    printf_green "Systemd service installed: $service_file"
    printf_cyan "Caddyfile location: $caddyfile"
    printf_cyan "Enable service: $systemd_cmd enable caddy"
    printf_cyan "Start service:  $systemd_cmd start caddy"
    printf_cyan "Status:         $systemd_cmd status caddy"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_yq() {
  local exitCode=0
  local name="yq"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/mikefarah/yq/releases/latest"
  local version=""

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/mikefarah/yq/releases/download/${version}/yq_linux_amd64" ;;
  aarch64 | arm64) download_url="https://github.com/mikefarah/yq/releases/download/${version}/yq_linux_arm64" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_and_move "$download_url" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_tgpt() {
  local exitCode=0
  local name="tgpt"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/aandrew-me/tgpt/releases/latest"
  local version=""

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/aandrew-me/tgpt/releases/download/${version}/tgpt-linux-amd64" ;;
  aarch64 | arm64) download_url="https://github.com/aandrew-me/tgpt/releases/download/${version}/tgpt-linux-arm64" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_and_move "$download_url" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_gpt() {
  __setup_tgpt
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_pipx() {
  local exitCode=0
  local name="pipx"
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  if pkmgr silent install pipx; then
    requiresudo true
    pipx ensurepath >/dev/null 2>&1
    requiresudo pipx ensurepath --global >/dev/null 2>&1
    printf_green "$name has been installed"
  else
    exitCode=1
    printf_red "Failed to install $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_uv() {
  local exitCode=0
  local name="uv"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/astral-sh/uv/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/astral-sh/uv/releases/download/${version}/uv-x86_64-unknown-linux-gnu.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/astral-sh/uv/releases/download/${version}/uv-aarch64-unknown-linux-gnu.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_shellcheck() {
  local exitCode=0
  local name="shellcheck"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/koalaman/shellcheck/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/koalaman/shellcheck/releases/download/${version}/shellcheck-${version}.linux.x86_64.tar.xz" ;;
  aarch64 | arm64) download_url="https://github.com/koalaman/shellcheck/releases/download/${version}/shellcheck-${version}.linux.aarch64.tar.xz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_shfmt() {
  local exitCode=0
  local name="shfmt"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/mvdan/sh/releases/latest"
  local version=""

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/mvdan/sh/releases/download/${version}/shfmt_${version}_linux_amd64" ;;
  aarch64 | arm64) download_url="https://github.com/mvdan/sh/releases/download/${version}/shfmt_${version}_linux_arm64" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_and_move "$download_url" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_speedtest() {
  local exitCode=0
  local name="speedtest"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/${name}-cli"
  extract_cmd="do_not_strip_components"
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"
  local release_url="https://install.speedtest.net/app/cli"
  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"
  if [ "$arch" = "x86_64" ]; then
    download_url="$release_url/ookla-speedtest-${SPEEDTEST_VERSION}-linux-x86_64.tgz"
  elif [ "$arch" = "aarch64" ]; then
    download_url="$release_url/ookla-speedtest-${SPEEDTEST_VERSION}-linux-aarch64.tgz"
  else
    printf_exit "Only x86_64 and ARM64 architecture is supported"
  fi
  if __cmd_exists $name; then
    printf_green "Attempting to update $name"
  else
    printf_green "Attempting to install $name"
  fi
  if ! __download_extract_move "$download_url" "$name" "$binFile" && ! __is_installed "$name" "$binFile"; then
    exitCode=1
    printf_red "Failed to install $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_llama_cpp() {
  local exitCode=0
  local name="llama-cli"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/ggerganov/llama.cpp/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/ggerganov/llama.cpp/releases/download/${version}/llama-${version#b}-bin-ubuntu-x64.zip" ;;
  *)
    printf_red "Unsupported architecture: $arch (only x86_64 supported)"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_aichat() {
  local exitCode=0
  local name="aichat"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/sigoden/aichat/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/sigoden/aichat/releases/download/${version}/aichat-${version}-x86_64-unknown-linux-musl.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/sigoden/aichat/releases/download/${version}/aichat-${version}-aarch64-unknown-linux-musl.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_fabric() {
  local exitCode=0
  local name="fabric"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/danielmiessler/fabric/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/danielmiessler/fabric/releases/download/${version}/fabric-linux-amd64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/danielmiessler/fabric/releases/download/${version}/fabric-linux-arm64.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_mods() {
  local exitCode=0
  local name="mods"
  local arch="$(uname -m)"
  local binFile="$SETUPMGR_DEFAULT_BIN_DIR/$name"
  local release_url="https://api.github.com/repos/charmbracelet/mods/releases/latest"
  local version=""
  PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR/$name"

  [ -d "$SETUPMGR_DEFAULT_BIN_DIR" ] || mkdir -p "$SETUPMGR_DEFAULT_BIN_DIR"

  if __cmd_exists $name; then
    printf_green "Updating $name"
  else
    printf_green "Installing $name"
  fi

  version="$(__get_release_info "$release_url" '"tag_name"')"

  case $arch in
  x86_64) download_url="https://github.com/charmbracelet/mods/releases/download/${version}/mods_${version#v}_Linux_x86_64.tar.gz" ;;
  aarch64 | arm64) download_url="https://github.com/charmbracelet/mods/releases/download/${version}/mods_${version#v}_Linux_arm64.tar.gz" ;;
  *)
    printf_red "Unsupported architecture: $arch"
    return 1
    ;;
  esac

  if [ -z "$version" ] || [ -z "$download_url" ]; then
    printf_red "Failed to determine download URL for $name"
    return 1
  fi

  if __download_extract_move "$download_url" "$name" "$binFile" && __is_installed "$name" "$binFile"; then
    printf_green "$name has been installed to $binFile"
  else
    exitCode=1
    printf_red "Failed to download $name"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_llm() {
  local exitCode=0
  local name="llm"
  if ! __cmd_exists pipx; then
    printf_red "pipx is required to install $name"
    printf_yellow "Run: setupmgr pipx"
    return 1
  fi
  if __cmd_exists "$name" && [ "$SETUPMGR_FORCE_INSTALL" != "true" ]; then
    printf_green "$name is already installed"
    return 0
  fi
  if pipx install llm |& __output_status; then
    printf_green "Installed $name via pipx"
  else
    exitCode=1
    printf_red "Failed to install $name via pipx"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_aider() {
  local exitCode=0
  local name="aider-chat"
  local cmd_name="aider"
  if ! __cmd_exists pipx; then
    printf_red "pipx is required to install $name"
    printf_yellow "Run: setupmgr pipx"
    return 1
  fi
  if __cmd_exists "$cmd_name" && [ "$SETUPMGR_FORCE_INSTALL" != "true" ]; then
    printf_green "$cmd_name is already installed"
    return 0
  fi
  printf_green "Installing $name via pipx"
  if pipx install aider-chat |& __output_status; then
    printf_green "Installed $cmd_name via pipx"
    printf_cyan "Usage: aider --model ollama/qwen2.5-coder:32b"
    printf_cyan "Docs: https://aider.chat/docs/"
  else
    exitCode=1
    printf_red "Failed to install $name via pipx"
  fi
  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - -
__setup_plandex() {
  local exitCode=0
  local cli_name="plandex"
  local server_dir=""
  local install_server="${PLANDEX_INSTALL_SERVER:-true}"

  # Determine server directory based on sudo availability
  if __sudoif; then
    server_dir="${PLANDEX_SERVER_DIR:-/opt/plandex}"
  else
    server_dir="${PLANDEX_SERVER_DIR:-$HOME/.local/share/plandex/server}"
  fi

  # Check prerequisites
  if ! __cmd_exists docker; then
    printf_red "Docker is required for Plandex server"
    printf_yellow "Install Docker first, then run: setupmgr plandex"
    return 1
  fi

  if ! __cmd_exists docker-compose && ! docker compose version &>/dev/null; then
    printf_red "docker-compose is required for Plandex server"
    printf_yellow "Install docker-compose first, then run: setupmgr plandex"
    return 1
  fi

  # Install CLI
  if __cmd_exists "$cli_name" && [ "$SETUPMGR_FORCE_INSTALL" != "true" ]; then
    printf_green "Plandex CLI is already installed"
  else
    printf_green "Installing Plandex CLI"
    if curl -sL https://plandex.ai/install.sh | bash |& __output_status; then
      printf_green "Plandex CLI installed successfully"
    else
      exitCode=1
      printf_red "Failed to install Plandex CLI"
      return $exitCode
    fi
  fi

  # Setup server
  if [ "$install_server" = "true" ]; then
    if [ -d "$server_dir/.git" ]; then
      printf_cyan "Plandex server repository already exists at: $server_dir"
      printf_yellow "To update: cd $server_dir && git pull"
    else
      printf_green "Cloning Plandex server repository to: $server_dir"
      if git clone https://github.com/plandex-ai/plandex.git "$server_dir" |& __output_status; then
        printf_green "Plandex server repository cloned successfully"
      else
        exitCode=1
        printf_red "Failed to clone Plandex server repository"
        return $exitCode
      fi
    fi

    # Setup systemd service
    local service_file=""
    local systemd_cmd="systemctl"

    if __sudoif; then
      service_file="/etc/systemd/system/plandex.service"
    else
      service_file="$HOME/.config/systemd/user/plandex.service"
      systemd_cmd="systemctl --user"
      mkdir -p "$HOME/.config/systemd/user"
    fi

    printf_green "Installing systemd service file"
    # Create service file with embedded content
    if __sudoif; then
      sudo tee "$service_file" >/dev/null <<EOF
[Unit]
Description=Plandex AI Coding Agent Server
After=network.target docker.service
Requires=docker.service
Documentation=https://docs.plandex.ai/

[Service]
Type=simple
WorkingDirectory=$server_dir/app
PrivateTmp=true
Restart=always
RestartSec=10
KillMode=mixed

Environment=TERM=linux
Environment=HOME="$HOME"
Environment=GOENV=development
Environment=PORT=8099
Environment=LOCAL_MODE=true

# Start the server using the official start script
ExecStart=/bin/bash -c 'cd $server_dir/app && ./start_local.sh'
ExecStop=/usr/bin/docker compose down
ExecReload=/usr/bin/docker compose restart
TimeoutStartSec=60
TimeoutStopSec=30

# Security hardening
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=read-only
ReadWritePaths=$server_dir

[Install]
WantedBy=multi-user.target
EOF
      sudo systemctl daemon-reload
    else
      cat >"$service_file" <<EOF
[Unit]
Description=Plandex AI Coding Agent Server
After=network.target docker.service
Requires=docker.service
Documentation=https://docs.plandex.ai/

[Service]
Type=simple
WorkingDirectory=$server_dir/app
PrivateTmp=true
Restart=always
RestartSec=10
KillMode=mixed

Environment=TERM=linux
Environment=HOME="$HOME"
Environment=GOENV=development
Environment=PORT=8099
Environment=LOCAL_MODE=true

# Start the server using the official start script
ExecStart=/bin/bash -c 'cd $server_dir/app && ./start_local.sh'
ExecStop=/usr/bin/docker compose down
ExecReload=/usr/bin/docker compose restart
TimeoutStartSec=60
TimeoutStopSec=30

# Security hardening
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=read-only
ReadWritePaths=$server_dir

[Install]
WantedBy=multi-user.target
EOF
      systemctl --user daemon-reload
    fi
    printf_green "Systemd service installed: $service_file"
    printf_cyan "Enable service: $systemd_cmd enable plandex"
    printf_cyan "Start service:  $systemd_cmd start plandex"
    printf_cyan "Status:         $systemd_cmd status plandex"

    # Check if server is running
    if curl -s http://localhost:8099/health &>/dev/null; then
      printf_green "Plandex server is already running on http://localhost:8099"
    else
      printf_yellow "Plandex server is not running"
      printf_cyan "To start server manually:"
      printf_cyan "  cd $server_dir/app && ./start_local.sh"
      printf_cyan "Or use systemd:"
      printf_cyan "  $systemd_cmd start plandex"
    fi
  fi

  # Show configuration instructions
  printf_purple "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  printf_cyan "Plandex Setup Complete!"
  printf_purple "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  printf_cyan ""
  printf_cyan "Next Steps:"
  printf_cyan ""
  printf_cyan "1. Start the server (if not running):"
  printf_cyan "   cd $server_dir/app && ./start_local.sh"
  printf_cyan ""
  printf_cyan "2. Sign in (in a new terminal):"
  printf_cyan "   plandex sign-in"
  printf_cyan "   > Select: Local mode host"
  printf_cyan "   > Accept: http://localhost:8099"
  printf_cyan ""
  printf_cyan "3. Configure for Ollama:"
  printf_cyan "   plandex set-model ollama-daily  # Hybrid (recommended)"
  printf_cyan "   # OR"
  printf_cyan "   plandex set-model ollama         # Full local (needs 32GB+ RAM)"
  printf_cyan ""
  printf_cyan "4. Start using:"
  printf_cyan "   cd your-project && plandex"
  printf_cyan ""
  printf_cyan "Server location: $server_dir"
  printf_cyan "Server port: http://localhost:8099"
  printf_cyan "Docs: https://docs.plandex.ai/"
  printf_purple "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  return $exitCode
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# User defined variables/import external variables
SETUPMGR_START_TIMER="${SETUPMGR_START_TIMER:-$(date +%s.%N)}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Default exit code
SETUPMGR_EXIT_STATUS=0
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Application Folders
SETUPMGR_CONFIG_DIR="${SETUPMGR_CONFIG_DIR:-$HOME/.config/myscripts/setupmgr}"
SETUPMGR_CONFIG_BACKUP_DIR="${SETUPMGR_CONFIG_BACKUP_DIR:-$HOME/.local/share/myscripts/setupmgr/backups}"
SETUPMGR_LOG_DIR="${SETUPMGR_LOG_DIR:-$HOME/.local/log/setupmgr}"
SETUPMGR_RUN_DIR="${SETUPMGR_RUN_DIR:-$HOME/.local/run/system_scripts/$SETUPMGR_SCRIPTS_PREFIX}"
SETUPMGR_TEMP_DIR="${SETUPMGR_TEMP_DIR:-$HOME/.local/tmp/system_scripts/setupmgr}"
SETUPMGR_CACHE_DIR="${SETUPMGR_CACHE_DIR:-$HOME/.cache/setupmgr}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# File settings
SETUPMGR_CONFIG_FILE="${SETUPMGR_CONFIG_FILE:-settings.conf}"
SETUPMGR_LOG_ERROR_FILE="${SETUPMGR_LOG_ERROR_FILE:-$SETUPMGR_LOG_DIR/error.log}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Color Settings
SETUPMGR_OUTPUT_COLOR_1="${SETUPMGR_OUTPUT_COLOR_1:-33}"
SETUPMGR_OUTPUT_COLOR_2="${SETUPMGR_OUTPUT_COLOR_2:-5}"
SETUPMGR_OUTPUT_COLOR_GOOD="${SETUPMGR_OUTPUT_COLOR_GOOD:-2}"
SETUPMGR_OUTPUT_COLOR_ERROR="${SETUPMGR_OUTPUT_COLOR_ERROR:-1}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Notification Settings
SETUPMGR_REMOTE_NOTIFY_ENABLED="${SETUPMGR_REMOTE_NOTIFY_ENABLED:-yes}"
SETUPMGR_REMOTE_NOTIFY_COMMAND="${SETUPMGR_REMOTE_NOTIFY_COMMAND:-web-notify telegram}"
# System
SETUPMGR_SYSTEM_NOTIFY_ENABLED="${SETUPMGR_SYSTEM_NOTIFY_ENABLED:-yes}"
SETUPMGR_GOOD_NAME="${SETUPMGR_GOOD_NAME:-Great:}"
SETUPMGR_ERROR_NAME="${SETUPMGR_ERROR_NAME:-Error:}"
SETUPMGR_GOOD_MESSAGE="${SETUPMGR_GOOD_MESSAGE:-No errors reported}"
SETUPMGR_ERROR_MESSAGE="${SETUPMGR_ERROR_MESSAGE:-Errors were reported}"
SETUPMGR_NOTIFY_CLIENT_NAME="${SETUPMGR_NOTIFY_CLIENT_NAME:-$APPNAME}"
SETUPMGR_NOTIFY_CLIENT_ICON="${SETUPMGR_NOTIFY_CLIENT_ICON:-notification-new}"
SETUPMGR_NOTIFY_CLIENT_URGENCY="${SETUPMGR_NOTIFY_CLIENT_URGENCY:-normal}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Additional Variables
SETUPMGR_DEFAULT_USER_BIN_DIR="${SETUPMGR_DEFAULT_USER_BIN_DIR:-$HOME/.local/bin}"
SETUPMGR_DEFAULT_SYSTEM_BIN_DIR="${SETUPMGR_DEFAULT_SYSTEM_BIN_DIR:-/usr/local/bin}"
SETUPMGR_DEFAULT_USER_SHARE_DIR="${SETUPMGR_DEFAULT_USER_SHARE_DIR:-$HOME/.local/share}"
SETUPMGR_DEFAULT_SYSTEM_SHARE_DIR="${SETUPMGR_DEFAULT_SYSTEM_SHARE_DIR:-/usr/local/share}"
# Auto-detect: system-wide if sudo available, otherwise user directory
if __sudoif; then
  SETUPMGR_DEFAULT_BIN_DIR="${SETUPMGR_DEFAULT_SYSTEM_BIN_DIR}"
  SETUPMGR_DEFAULT_SHARE_DIR="${SETUPMGR_DEFAULT_SYSTEM_SHARE_DIR}"
else
  SETUPMGR_DEFAULT_BIN_DIR="${SETUPMGR_DEFAULT_USER_BIN_DIR}"
  SETUPMGR_DEFAULT_SHARE_DIR="${SETUPMGR_DEFAULT_USER_SHARE_DIR}"
fi
# - - - - - - - - - - - - - - - - - - - - - - - - -
LUA_JIT_VERSION="${LUA_JIT_VERSION:-2.0.5}"
LUA_DEFAULT_VERSION="${LUA_DEFAULT_VERSION:-5.4.3}"
LUA_ROCKS_DEFAULT_VERSION="${LUA_ROCKS_DEFAULT_VERSION:-3.8.0}"
LUAVER_HOME="${LUAVER_HOME:-$HOME/.local/share/lua/plugins/luaver}"
LUAVER_GIT_REPO="${LUAVER_GIT_REPO:-https://github.com/DhavalKapil/luaver}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
ASDF_DIR="${ASDF_DIR:-$HOME/.config/asdf}"
ASDF_DATA_DIR="${ASDF_DATA_DIR:-$HOME/.local/share/bash/plugins/asdf}"
ASDF_GITREPO="${ASDF_GITREPO:-https://github.com/asdf-vm/asdf}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
DBX_HOME="${DBX_HOME:-$HOME/.local/share/distrobox}"
DISTROBOX_HOME="${DISTROBOX_HOME:-$DBX_HOME}"
DISTROBOX_SCRIPT_URL="${DISTROBOX_SCRIPT_URL:-https://raw.githubusercontent.com/89luca89/distrobox/main/install}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
DOTNET_ROOT="${DOTNET_ROOT:-$HOME/.local/share/dotnet}"
DOTNET_SCRIPT_URL="${DOTNET_SCRIPT_URL:-https://dot.net/v1/dotnet-install.sh}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
GVM_ROOT="${GVM_ROOT:-$HOME/.local/share/gvm}"
GVM_GITREPO="${GVM_GITREPO:-https://github.com/moovweb/gvm}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
VAGRANT_HOME="${VAGRANT_HOME:-$HOME/.local/share/vagrant}"
VAGRANT_DEFAULT_PROVIDER="${VAGRANT_DEFAULT_PROVIDER:-libvirt}"
VAGRANT_DEFAULT_BOX="${VAGRANT_DEFAULT_BOX:-archlinux/archlinux}"
VAGRANT_CLOUD_TOKEN="${VAGRANT_CLOUD_TOKEN:-}"
VAGRANT_CLOUD_USERNAME="${VAGRANT_CLOUD_USERNAME:-}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
FNM_DIR="${FNM_DIR:-$HOME/.local/share/nodejs/fnm}"
FNM_NODE_VERSION="${FNM_NODE_VERSION:-latest}"
FNM_INSTALL_SCRIPT="${FNM_INSTALL_SCRIPT:-https://raw.githubusercontent.com/Schniz/fnm/master/.ci/install.sh}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
NVM_NODE_VERSION="${NVM_NODE_VERSION:-22}"
NVM_DIR="${NVM_DIR:-$HOME/.local/share/nodejs/nvm}"
NVM_GITREPO="${NVM_GITREPO:-https://github.com/nvm-sh/nvm}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
POWERSHELL_TEMP_DIR="${POWERSHELL_TEMP_DIR:-$SETUPMGR_TEMP_DIR/powershell}"
POWERSHELL_INSTALL_DIR="${POWERSHELL_INSTALL_DIR:-$HOME/.local/share/powershell}"
POWERSHELL_LATEST_URL="${POWERSHELL_LATEST_URL:-https://api.github.com/repos/PowerShell/PowerShell/releases/latest}"
POWERSHELL_OMP_GITREPO="${POWERSHELL_OMP_GITREPO:-https://api.github.com/repos/JanDeDobbeleer/oh-my-posh/releases/latest}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
JEKYLL_VERSION="${JEKYLL_VERSION:-3.10.0}"
JEKYLL_RUBY_VERSION="${JEKYLL_RUBY_VERSION:-3.3.4}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
rvm_path="${rvm_path:-$HOME/.local/share/ruby/rvm}"
RVM_GITREPO="${RVM_GITREPO:-https://github.com/rvm/rvm}"
RVM_RUBY_VERSION="${RVM_RUBY_VERSION:-3.3.4}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
RBENV_ROOT="${RBENV_ROOT:-$HOME/.local/share/ruby/rbenv}"
RBENV_GITREPO="${RBENV_GITREPO:-https://github.com/rbenv/rbenv.git}"
RBENV__RUBY_VERSION="${RBENV__RUBY_VERSION:-3.3.4}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# - - - - - - - - - - - - - - - - - - - - - - - - -
MINIKUBE_MEMORY="${MINIKUBE_MEMORY:-4096}"
MINIKUBE_DRIVER="${MINIKUBE_DRIVER:-docker}"
MINIKUBE_HOME="${MINIKUBE_HOME:-$HOME/.config/minikube}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
PACKER_VERSION="${PACKER_VERSION:-1.11.2}"
PACKER_PLUGINS="${PACKER_PLUGINS:-docker proxmox qemu vmware vagrant incus}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
CASAOS_SCRIPT_URL="${CASAOS_SCRIPT_URL:-https://get.casaos.io}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
COOLIFY_SCRIPT_URL="${COOLIFY_SCRIPT_URL:-https://cdn.coollabs.io/coolify/install.sh}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
GO_VERSION="${GO_VERSION:-}"
GO_INSTALL_DIR="${GO_INSTALL_DIR:-$SETUPMGR_DEFAULT_SHARE_DIR/go}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
ZED_INSTALL_DIR="${ZED_INSTALL_DIR:-$SETUPMGR_DEFAULT_SHARE_DIR/zed_editor}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
MINIO_STORAGE_DIR="${MINIO_STORAGE_DIR:-/var/lib/minio/data}"
MINIO_BROWSER_REDIRECT_URL="${MINIO_BROWSER_REDIRECT_URL:-http://$HOSTNAME:49001}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
GARAGE_STORAGE_DIR="${GARAGE_STORAGE_DIR:-/var/lib/garage/data}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
SPEEDTEST_VERSION="${SPEEDTEST_VERSION:-1.2.0}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
LUAROCKS_BIN="${LUAROCKS_BIN:-$HOME/.local/share/lua/luarocks/bin}"
SETUPMG_NPM_SYSTEM_BIN_FILE="$(type -P "/usr/bin/npm" || type -P "/usr/local/bin/npm")"
# - - - - - - - - - - - - - - - - - - - - - - - - -
NODE_NPM_PACKAGES="${NODE_NPM_PACKAGES:-vercel prettier eslint npm-check-updates}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Generate config files
[ -f "$SETUPMGR_CONFIG_DIR/$SETUPMGR_CONFIG_FILE" ] || [ "$*" = "--config" ] || INIT_CONFIG="${INIT_CONFIG:-TRUE}" __gen_config ${SETARGS:-$@}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Import config
[ -f "$SETUPMGR_CONFIG_DIR/$SETUPMGR_CONFIG_FILE" ] && . "$SETUPMGR_CONFIG_DIR/$SETUPMGR_CONFIG_FILE"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Ensure Directories exist
[ -d "$SETUPMGR_RUN_DIR" ] || mkdir -p "$SETUPMGR_RUN_DIR" |& __devnull
[ -d "$SETUPMGR_LOG_DIR" ] || mkdir -p "$SETUPMGR_LOG_DIR" |& __devnull
[ -d "$SETUPMGR_TEMP_DIR" ] || mkdir -p "$SETUPMGR_TEMP_DIR" |& __devnull
[ -d "$SETUPMGR_CACHE_DIR" ] || mkdir -p "$SETUPMGR_CACHE_DIR" |& __devnull
# - - - - - - - - - - - - - - - - - - - - - - - - -
SETUPMGR_TEMP_FILE="${SETUPMGR_TEMP_FILE:-$(mktemp $SETUPMGR_TEMP_DIR/XXXXXX 2>/dev/null)}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set custom actions

# - - - - - - - - - - - - - - - - - - - - - - - - -
# Argument/Option settings
SETARGS=("$@")
# - - - - - - - - - - - - - - - - - - - - - - - - -
SHORTOPTS=""
SHORTOPTS+=""
# - - - - - - - - - - - - - - - - - - - - - - - - -
GET_OPTIONS_NO="no-tee"
GET_OPTIONS_YES="yes-*"
LONGOPTS="completions:,config,reset-config,debug,dir:,help,options,raw,version,silent,force,"
LONGOPTS+="system,all,$GET_OPTIONS_NO,$GET_OPTIONS_YES"
# - - - - - - - - - - - - - - - - - - - - - - - - -
ARRAY="act,aichat,asdf,bat,bob,bun,caddy,coder,delta,deno,devbox,direnv,distrobox,dotnet,dust,exa,fabric,fastfetch,fd,fnm,fzf,garage,gh,glow,go,gohttpserver,"
ARRAY+="gpt,gvm,helm,incus,jekyll,jless,just,kind,kubectl,lapce,lazydocker,lazygit,lima,llama-cpp,llm,lua,mc,minikube,minio_server,mods,nix,nodejs,nvm,ollama,opentofu,"
ARRAY+="packer,pipx,podman,powershell,procs,rbenv,remove,ripgrep,rvm,speedtest,starship,tokei,traefik,uv,vagrant,vfox,webhookd,yq,zed,zoxide,"
ARRAY+="claude,copilot,codex,vercel,prettier,eslint,npm-check-updates"
# - - - - - - - - - - - - - - - - - - - - - - - - -
LIST=""
LIST+=""
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Setup application options
setopts=$(getopt -o "$SHORTOPTS" --long "$LONGOPTS" -n "$APPNAME" -- "$@" 2>/dev/null)
eval set -- "${setopts[@]}" 2>/dev/null
while :; do
  case "$1" in
  --raw)
    shift 1
    export SHOW_RAW="true"
    NC=""
    RESET=""
    BLACK=""
    RED=""
    GREEN=""
    YELLOW=""
    BLUE=""
    PURPLE=""
    CYAN=""
    WHITE=""
    ORANGE=""
    LIGHTRED=""
    BG_GREEN=""
    BG_RED=""
    ICON_INFO="[ info ]"
    ICON_GOOD="[ ok ]"
    ICON_WARN="[ warn ]"
    ICON_ERROR="[ error ]"
    ICON_QUESTION="[ ? ]"
    printf_column() { tee | grep '^'; }
    printf_color() { printf '%b' "$1" | tr -d '\t' | sed '/^%b$/d;s,\x1B\[ 0-9;]*[a-zA-Z],,g'; }
    ;;
  --debug)
    shift 1
    set -xo pipefail
    export SCRIPT_OPTS="--debug"
    export _DEBUG="on"
    __devnull() { tee || return 1; }
    __devnull2() { eval "$@" |& tee -p || return 1; }
    ;;
  --completions)
    if [ "$2" = "short" ]; then
      printf '%s\n' "-$SHORTOPTS" | sed 's|"||g;s|:||g;s|,|,-|g' | tr ',' '\n'
    elif [ "$2" = "long" ]; then
      printf '%s\n' "--$LONGOPTS" | sed 's|"||g;s|:||g;s|,|,--|g' | tr ',' '\n'
    elif [ "$2" = "array" ]; then
      printf '%s\n' "$ARRAY" | sed 's|"||g;s|:||g' | tr ',' '\n'
    elif [ "$2" = "list" ]; then
      printf '%s\n' "$LIST" | sed 's|"||g;s|:||g' | tr ',' '\n'
    else
      exit 1
    fi
    shift 2
    exit $?
    ;;
  --options)
    shift 1
    printf_blue "Current options for ${PROG:-$APPNAME}"
    [ -z "$SHORTOPTS" ] || __list_options "Short Options" "-${SHORTOPTS}" ',' '-' 4
    [ -z "$LONGOPTS" ] || __list_options "Long Options" "--${LONGOPTS}" ',' '--' 4
    [ -z "$ARRAY" ] || __list_options "Base Options" "${ARRAY}" ',' '' 4
    [ -z "$LIST" ] || __list_options "LIST Options" "${LIST}" ',' '' 4
    exit $?
    ;;
  --version)
    shift 1
    __version
    exit $?
    ;;
  --help)
    shift 1
    __help
    exit $?
    ;;
  --config)
    shift 1
    __gen_config
    exit $?
    ;;
  --reset-config)
    shift 1
    [ -f "$SETUPMGR_CONFIG_DIR/$SETUPMGR_CONFIG_FILE" ] && __rm "$SETUPMGR_CONFIG_DIR/$SETUPMGR_CONFIG_FILE"
    __gen_config
    exit $?
    ;;
  --silent)
    shift 1
    SETUPMGR_SILENT="true"
    ;;
  --force)
    shift 1
    export FORCE_INSTALL="true"
    SETUPMGR_FORCE_INSTALL="true"
    ;;
  --dir)
    CWD_IS_SET="TRUE"
    SETUPMGR_CWD="$2"
    [ -d "$SETUPMGR_CWD" ] || mkdir -p "$SETUPMGR_CWD" |& __devnull
    shift 2
    ;;
  --no-*)
    __options_function_no "$1"
    shift 1
    ;;
  --yes-*)
    __options_function_yes "$1"
    shift 1
    ;;
  --system)
    shift 1
    SETUPMGR_SYSTEM_INSTALL="yes"
    ;;
  --all)
    shift 1
    SETUPMGR_INSTALL_ALL="yes"
    ;;
  --)
    shift 1
    break
    ;;
  esac
done
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Get directory from args
# set -- "$@"
# for arg in "$@"; do
# if [ -d "$arg" ]; then
# SETUPMGR_CWD="$arg" && shift 1 && SET_NEW_ARGS=("$@") && break
# elif [ -f "$arg" ]; then
# SETUPMGR_CWD="$(dirname "$arg" 2>/dev/null)" && shift 1 && SET_NEW_ARGS=("$@") && break
# else
# SET_NEW_ARGS+=("$arg")
# fi
# done
# set -- "${SET_NEW_ARGS[@]}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set directory to first argument
# [ -d "$1" ] && __is_an_option "$1" && SETUPMGR_CWD="$1" && shift 1 || SETUPMGR_CWD="${SETUPMGR_CWD:-$PWD}"
SETUPMGR_CWD="$(realpath "${SETUPMGR_CWD:-$PWD}" 2>/dev/null)"
# if [ -d "$SETUPMGR_CWD" ] && cd "$SETUPMGR_CWD"; then
# if [ "$SETUPMGR_SILENT" != "true" ] && [ "$CWD_SILENCE" != "true" ]; then
# printf_cyan "Setting working dir to $SETUPMGR_CWD"
# fi
# else
# printf_exit "ðŸ’” $SETUPMGR_CWD does not exist ðŸ’”"
# fi
export SETUPMGR_CWD
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set actions based on variables

# - - - - - - - - - - - - - - - - - - - - - - - - -
# Check for required applications/Network check
#requiresudo "$0" "$@" || exit 2     # exit 2 if errors
cmd_exists --error --ask bash curl tar unzip || exit 3 # exit 3 if not found
#am_i_online --error || exit 4           # exit 4 if no internet
# - - - - - - - - - - - - - - - - - - - - - - - - -
# APP Variables overrides
PACKAGE_TMP_DIR="$SETUPMGR_TEMP_DIR"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Actions based on env
[ "$1" = "install" ] && shift
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Export variables

# - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute functions
pushd "/tmp" >/dev/null || true
# - - - - - - - - - - - - - - - - - - - - - - - - -
# begin main app
if [ "$1" = "all" ] || [ "$SETUPMGR_INSTALL_ALL" = "yes" ]; then
  setVal=0
  for app in ${ARRAY//,/ }; do
    eval "$0" "$app"
    retVal=$?
    setVal=$((setVal + retVal))
    printf_newline
  done
  exit $setVal
fi

while [ $# -gt 0 ]; do
  # Auto-handle NODE_NPM_PACKAGES
  if __is_npm_package "$1"; then
    __execute_npm "$1" "$1"
    SETUPMGR_EXIT_STATUS=$?
    shift 1
    continue
  fi
  case "$1" in
  claude)
    shift 1
    __execute_npm "claude" "@claude-ai/claude-cli"
    SETUPMGR_EXIT_STATUS=$?
    ;;
  codex)
    shift 1
    __execute_npm "codex" "codex-cli"
    SETUPMGR_EXIT_STATUS=$?
    ;;
  copilot)
    shift 1
    __execute_npm "copilot" "@github/copilot"
    SETUPMGR_EXIT_STATUS=$?
    ;;
  cortex)
    shift 1
    __execute_npm "cortex" "@louisle/cortexso"
    SETUPMGR_EXIT_STATUS=$?
    ;;
  gemini)
    shift 1
    __execute_npm "gemini" "@google/gemini-cli"
    SETUPMGR_EXIT_STATUS=$?
    ;;
  act)
    shift 1
    __setup_act
    SETUPMGR_EXIT_STATUS=$?
    ;;
  aichat)
    shift 1
    __setup_aichat
    SETUPMGR_EXIT_STATUS=$?
    ;;
  aider)
    shift 1
    __setup_aider
    SETUPMGR_EXIT_STATUS=$?
    ;;
  asdf)
    shift 1
    __setup_asdf
    SETUPMGR_EXIT_STATUS=$?
    ;;
  atuin)
    shift 1
    __setup_atuin
    SETUPMGR_EXIT_STATUS=$?
    ;;
  bat)
    shift 1
    __setup_bat
    SETUPMGR_EXIT_STATUS=$?
    ;;
  bob)
    shift 1
    __setup_bob
    SETUPMGR_EXIT_STATUS=$?
    ;;
  broot)
    shift 1
    __setup_broot
    SETUPMGR_EXIT_STATUS=$?
    ;;
  bun)
    shift 1
    __setup_bun
    SETUPMGR_EXIT_STATUS=$?
    ;;
  caddy)
    shift 1
    __setup_caddy
    SETUPMGR_EXIT_STATUS=$?
    ;;
  coder)
    shift 1
    __setup_coder
    SETUPMGR_EXIT_STATUS=$?
    ;;
  ctop)
    shift 1
    __setup_ctop
    SETUPMGR_EXIT_STATUS=$?
    ;;
  delta)
    shift 1
    __setup_delta
    SETUPMGR_EXIT_STATUS=$?
    ;;
  deno)
    shift 1
    __setup_deno
    SETUPMGR_EXIT_STATUS=$?
    ;;
  devbox)
    shift 1
    __setup_devbox
    SETUPMGR_EXIT_STATUS=$?
    ;;
  direnv)
    shift 1
    __setup_direnv
    SETUPMGR_EXIT_STATUS=$?
    ;;
  dive)
    shift 1
    __setup_dive
    SETUPMGR_EXIT_STATUS=$?
    ;;
  distrobox)
    shift 1
    __setup_distrobox
    SETUPMGR_EXIT_STATUS=$?
    ;;
  dust)
    shift 1
    __setup_dust
    SETUPMGR_EXIT_STATUS=$?
    ;;
  dotnet)
    shift 1
    __setup_dotnet
    SETUPMGR_EXIT_STATUS=$?
    ;;
  exa)
    shift 1
    __setup_exa
    SETUPMGR_EXIT_STATUS=$?
    ;;
  fastfetch)
    shift 1
    __setup_fastfetch
    SETUPMGR_EXIT_STATUS=$?
    ;;
  fabric)
    shift 1
    __setup_fabric
    SETUPMGR_EXIT_STATUS=$?
    ;;
  fd)
    shift 1
    __setup_fd
    SETUPMGR_EXIT_STATUS=$?
    ;;
  fnm)
    shift 1
    __setup_fnm
    SETUPMGR_EXIT_STATUS=$?
    ;;
  fzf)
    shift 1
    __setup_fzf
    SETUPMGR_EXIT_STATUS=$?
    ;;
  garage)
    shift 1
    __setup_garage
    SETUPMGR_EXIT_STATUS=$?
    ;;
  gh)
    shift 1
    __setup_gh
    SETUPMGR_EXIT_STATUS=$?
    ;;
  go)
    shift 1
    __setup_golang
    SETUPMGR_EXIT_STATUS=$?
    ;;
  gohttpserver)
    shift 1
    __setup_gohttpserver
    SETUPMGR_EXIT_STATUS=$?
    ;;
  gpt)
    shift 1
    __setup_gpt
    SETUPMGR_EXIT_STATUS=$?
    ;;
  glow)
    shift 1
    __setup_glow
    SETUPMGR_EXIT_STATUS=$?
    ;;
  gvm)
    shift 1
    __setup_gvm
    SETUPMGR_EXIT_STATUS=$?
    ;;
  helm)
    shift 1
    __setup_helm
    SETUPMGR_EXIT_STATUS=$?
    ;;
  helix)
    shift 1
    __setup_helix
    SETUPMGR_EXIT_STATUS=$?
    ;;
  hyperfine)
    shift 1
    __setup_hyperfine
    SETUPMGR_EXIT_STATUS=$?
    ;;
  incus)
    shift 1
    __setup_incus
    SETUPMGR_EXIT_STATUS=$?
    ;;
  jekyll)
    shift 1
    __setup_jekyll
    SETUPMGR_EXIT_STATUS=$?
    ;;
  jless)
    shift 1
    __setup_jless
    SETUPMGR_EXIT_STATUS=$?
    ;;
  just)
    shift 1
    __setup_just
    SETUPMGR_EXIT_STATUS=$?
    ;;
  kind)
    shift 1
    __setup_kind
    SETUPMGR_EXIT_STATUS=$?
    ;;
  k9s)
    shift 1
    __setup_k9s
    SETUPMGR_EXIT_STATUS=$?
    ;;
  kubectl)
    shift 1
    __setup_kubectl
    SETUPMGR_EXIT_STATUS=$?
    ;;
  lapce)
    shift 1
    __setup_lapce
    SETUPMGR_EXIT_STATUS=$?
    ;;
  lazydocker)
    shift 1
    __setup_lazydocker
    SETUPMGR_EXIT_STATUS=$?
    ;;
  lazygit)
    shift 1
    __setup_lazygit
    SETUPMGR_EXIT_STATUS=$?
    ;;
  lima)
    shift 1
    __setup_lima
    SETUPMGR_EXIT_STATUS=$?
    ;;
  localai)
    shift 1
    __setup_localai
    SETUPMGR_EXIT_STATUS=$?
    ;;
  llama-cpp | llama_cpp)
    shift 1
    __setup_llama_cpp
    SETUPMGR_EXIT_STATUS=$?
    ;;

  llm)
    shift 1
    __setup_llm
    SETUPMGR_EXIT_STATUS=$?
    ;;
  lua)
    shift 1
    __setup_lua
    SETUPMGR_EXIT_STATUS=$?
    ;;
  mc)
    shift 1
    __setup_mc
    SETUPMGR_EXIT_STATUS=$?
    ;;
  minikube)
    shift 1
    __setup_minikube
    SETUPMGR_EXIT_STATUS=$?
    ;;
  mods)
    shift 1
    __setup_mods
    SETUPMGR_EXIT_STATUS=$?
    ;;
  minio)
    shift 1
    __setup_minio
    SETUPMGR_EXIT_STATUS=$?
    ;;
  nix)
    shift 1
    __setup_nix
    SETUPMGR_EXIT_STATUS=$?
    ;;
  nodejs)
    shift 1
    __setup_nodejs
    SETUPMGR_EXIT_STATUS=$?
    ;;
  nvm)
    shift 1
    __setup_nvm
    SETUPMGR_EXIT_STATUS=$?
    ;;
  ollama)
    shift 1
    __setup_ollama
    SETUPMGR_EXIT_STATUS=$?
    ;;
  opentofu)
    shift 1
    __setup_opentofu
    SETUPMGR_EXIT_STATUS=$?
    ;;
  packer)
    shift 1
    __setup_packer
    SETUPMGR_EXIT_STATUS=$?
    ;;
  plandex)
    shift 1
    __setup_plandex
    SETUPMGR_EXIT_STATUS=$?
    ;;
  pipx)
    shift 1
    __setup_pipx
    SETUPMGR_EXIT_STATUS=$?
    ;;
  podman)
    shift 1
    __setup_podman
    SETUPMGR_EXIT_STATUS=$?
    ;;
  powershell)
    shift 1
    __setup_powershell
    SETUPMGR_EXIT_STATUS=$?
    ;;
  procs)
    shift 1
    __setup_procs
    SETUPMGR_EXIT_STATUS=$?
    ;;
  rbenv)
    shift 1
    __setup_rbenv
    SETUPMGR_EXIT_STATUS=$?
    ;;
  ripgrep)
    shift 1
    __setup_ripgrep
    SETUPMGR_EXIT_STATUS=$?
    ;;
  ruff)
    shift 1
    __setup_ruff
    SETUPMGR_EXIT_STATUS=$?
    ;;
  rustup)
    shift 1
    __setup_rustup
    SETUPMGR_EXIT_STATUS=$?
    ;;
  rvm)
    shift 1
    __setup_rvm
    SETUPMGR_EXIT_STATUS=$?
    ;;
  shellcheck)
    shift 1
    __setup_shellcheck
    SETUPMGR_EXIT_STATUS=$?
    ;;
  shfmt)
    shift 1
    __setup_shfmt
    SETUPMGR_EXIT_STATUS=$?
    ;;
  speedtest)
    shift 1
    __setup_speedtest
    SETUPMGR_EXIT_STATUS=$?
    ;;
  starship)
    shift 1
    __setup_starship
    SETUPMGR_EXIT_STATUS=$?
    ;;
  tokei)
    shift 1
    __setup_tokei
    SETUPMGR_EXIT_STATUS=$?
    ;;
  traefik)
    shift 1
    __setup_traefik
    SETUPMGR_EXIT_STATUS=$?
    ;;
  uv)
    shift 1
    __setup_uv
    SETUPMGR_EXIT_STATUS=$?
    ;;
  vagrant)
    shift 1
    __setup_vagrant
    SETUPMGR_EXIT_STATUS=$?
    ;;
  vfox)
    shift 1
    __setup_vfox
    SETUPMGR_EXIT_STATUS=$?
    ;;
  webhookd)
    shift 1
    __setup_webhookd
    SETUPMGR_EXIT_STATUS=$?
    ;;
  yq)
    shift 1
    __setup_yq
    SETUPMGR_EXIT_STATUS=$?
    ;;
  zed)
    shift 1
    __setup_zed
    SETUPMGR_EXIT_STATUS=$?
    ;;
  zellij)
    shift 1
    __setup_zellij
    SETUPMGR_EXIT_STATUS=$?
    ;;
  zig)
    shift 1
    __setup_zig
    SETUPMGR_EXIT_STATUS=$?
    ;;
  zoxide)
    shift 1
    __setup_zoxide
    SETUPMGR_EXIT_STATUS=$?
    ;;
  remove)
    shift 1
    while [ $# -gt 0 ]; do
      __remove_package "$1"
      SETUPMGR_EXIT_STATUS=$((SETUPMGR_EXIT_STATUS + $?))
      shift 1
    done
    ;;
  *)
    break
    ;;
  esac
done
# - - - - - - - - - - - - - - - - - - - - - - - - -
# Set exit code
SETUPMGR_EXIT_STATUS="${SETUPMGR_EXIT_STATUS:-0}"
# - - - - - - - - - - - - - - - - - - - - - - - - -
# End application
# - - - - - - - - - - - - - - - - - - - - - - - - -
# lets exit with code
exit ${SETUPMGR_EXIT_STATUS:-0}
# - - - - - - - - - - - - - - - - - - - - - - - - -
# ex: ts=2 sw=2 et filetype=sh
